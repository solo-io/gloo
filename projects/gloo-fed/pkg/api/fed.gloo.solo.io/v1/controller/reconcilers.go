// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./reconcilers.go -destination mocks/reconcilers.go

// Definitions for the Kubernetes Controllers
package controller

import (
	"context"

	fed_gloo_solo_io_v1 "github.com/solo-io/solo-projects/projects/gloo-fed/pkg/api/fed.gloo.solo.io/v1"

	"github.com/pkg/errors"
	"github.com/solo-io/skv2/pkg/ezkube"
	"github.com/solo-io/skv2/pkg/reconcile"
	"sigs.k8s.io/controller-runtime/pkg/manager"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
)

// Reconcile Upsert events for the FederatedUpstream Resource.
// implemented by the user
type FederatedUpstreamReconciler interface {
	ReconcileFederatedUpstream(obj *fed_gloo_solo_io_v1.FederatedUpstream) (reconcile.Result, error)
}

// Reconcile deletion events for the FederatedUpstream Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type FederatedUpstreamDeletionReconciler interface {
	ReconcileFederatedUpstreamDeletion(req reconcile.Request) error
}

type FederatedUpstreamReconcilerFuncs struct {
	OnReconcileFederatedUpstream         func(obj *fed_gloo_solo_io_v1.FederatedUpstream) (reconcile.Result, error)
	OnReconcileFederatedUpstreamDeletion func(req reconcile.Request) error
}

func (f *FederatedUpstreamReconcilerFuncs) ReconcileFederatedUpstream(obj *fed_gloo_solo_io_v1.FederatedUpstream) (reconcile.Result, error) {
	if f.OnReconcileFederatedUpstream == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileFederatedUpstream(obj)
}

func (f *FederatedUpstreamReconcilerFuncs) ReconcileFederatedUpstreamDeletion(req reconcile.Request) error {
	if f.OnReconcileFederatedUpstreamDeletion == nil {
		return nil
	}
	return f.OnReconcileFederatedUpstreamDeletion(req)
}

// Reconcile and finalize the FederatedUpstream Resource
// implemented by the user
type FederatedUpstreamFinalizer interface {
	FederatedUpstreamReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	FederatedUpstreamFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeFederatedUpstream(obj *fed_gloo_solo_io_v1.FederatedUpstream) error
}

type FederatedUpstreamReconcileLoop interface {
	RunFederatedUpstreamReconciler(ctx context.Context, rec FederatedUpstreamReconciler, predicates ...predicate.Predicate) error
}

type federatedUpstreamReconcileLoop struct {
	loop reconcile.Loop
}

func NewFederatedUpstreamReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) FederatedUpstreamReconcileLoop {
	return &federatedUpstreamReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &fed_gloo_solo_io_v1.FederatedUpstream{}, options),
	}
}

func (c *federatedUpstreamReconcileLoop) RunFederatedUpstreamReconciler(ctx context.Context, reconciler FederatedUpstreamReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericFederatedUpstreamReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(FederatedUpstreamFinalizer); ok {
		reconcilerWrapper = genericFederatedUpstreamFinalizer{
			genericFederatedUpstreamReconciler: genericReconciler,
			finalizingReconciler:               finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericFederatedUpstreamHandler implements a generic reconcile.Reconciler
type genericFederatedUpstreamReconciler struct {
	reconciler FederatedUpstreamReconciler
}

func (r genericFederatedUpstreamReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*fed_gloo_solo_io_v1.FederatedUpstream)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: FederatedUpstream handler received event for %T", object)
	}
	return r.reconciler.ReconcileFederatedUpstream(obj)
}

func (r genericFederatedUpstreamReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(FederatedUpstreamDeletionReconciler); ok {
		return deletionReconciler.ReconcileFederatedUpstreamDeletion(request)
	}
	return nil
}

// genericFederatedUpstreamFinalizer implements a generic reconcile.FinalizingReconciler
type genericFederatedUpstreamFinalizer struct {
	genericFederatedUpstreamReconciler
	finalizingReconciler FederatedUpstreamFinalizer
}

func (r genericFederatedUpstreamFinalizer) FinalizerName() string {
	return r.finalizingReconciler.FederatedUpstreamFinalizerName()
}

func (r genericFederatedUpstreamFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*fed_gloo_solo_io_v1.FederatedUpstream)
	if !ok {
		return errors.Errorf("internal error: FederatedUpstream handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeFederatedUpstream(obj)
}

// Reconcile Upsert events for the FederatedUpstreamGroup Resource.
// implemented by the user
type FederatedUpstreamGroupReconciler interface {
	ReconcileFederatedUpstreamGroup(obj *fed_gloo_solo_io_v1.FederatedUpstreamGroup) (reconcile.Result, error)
}

// Reconcile deletion events for the FederatedUpstreamGroup Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type FederatedUpstreamGroupDeletionReconciler interface {
	ReconcileFederatedUpstreamGroupDeletion(req reconcile.Request) error
}

type FederatedUpstreamGroupReconcilerFuncs struct {
	OnReconcileFederatedUpstreamGroup         func(obj *fed_gloo_solo_io_v1.FederatedUpstreamGroup) (reconcile.Result, error)
	OnReconcileFederatedUpstreamGroupDeletion func(req reconcile.Request) error
}

func (f *FederatedUpstreamGroupReconcilerFuncs) ReconcileFederatedUpstreamGroup(obj *fed_gloo_solo_io_v1.FederatedUpstreamGroup) (reconcile.Result, error) {
	if f.OnReconcileFederatedUpstreamGroup == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileFederatedUpstreamGroup(obj)
}

func (f *FederatedUpstreamGroupReconcilerFuncs) ReconcileFederatedUpstreamGroupDeletion(req reconcile.Request) error {
	if f.OnReconcileFederatedUpstreamGroupDeletion == nil {
		return nil
	}
	return f.OnReconcileFederatedUpstreamGroupDeletion(req)
}

// Reconcile and finalize the FederatedUpstreamGroup Resource
// implemented by the user
type FederatedUpstreamGroupFinalizer interface {
	FederatedUpstreamGroupReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	FederatedUpstreamGroupFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeFederatedUpstreamGroup(obj *fed_gloo_solo_io_v1.FederatedUpstreamGroup) error
}

type FederatedUpstreamGroupReconcileLoop interface {
	RunFederatedUpstreamGroupReconciler(ctx context.Context, rec FederatedUpstreamGroupReconciler, predicates ...predicate.Predicate) error
}

type federatedUpstreamGroupReconcileLoop struct {
	loop reconcile.Loop
}

func NewFederatedUpstreamGroupReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) FederatedUpstreamGroupReconcileLoop {
	return &federatedUpstreamGroupReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &fed_gloo_solo_io_v1.FederatedUpstreamGroup{}, options),
	}
}

func (c *federatedUpstreamGroupReconcileLoop) RunFederatedUpstreamGroupReconciler(ctx context.Context, reconciler FederatedUpstreamGroupReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericFederatedUpstreamGroupReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(FederatedUpstreamGroupFinalizer); ok {
		reconcilerWrapper = genericFederatedUpstreamGroupFinalizer{
			genericFederatedUpstreamGroupReconciler: genericReconciler,
			finalizingReconciler:                    finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericFederatedUpstreamGroupHandler implements a generic reconcile.Reconciler
type genericFederatedUpstreamGroupReconciler struct {
	reconciler FederatedUpstreamGroupReconciler
}

func (r genericFederatedUpstreamGroupReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*fed_gloo_solo_io_v1.FederatedUpstreamGroup)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: FederatedUpstreamGroup handler received event for %T", object)
	}
	return r.reconciler.ReconcileFederatedUpstreamGroup(obj)
}

func (r genericFederatedUpstreamGroupReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(FederatedUpstreamGroupDeletionReconciler); ok {
		return deletionReconciler.ReconcileFederatedUpstreamGroupDeletion(request)
	}
	return nil
}

// genericFederatedUpstreamGroupFinalizer implements a generic reconcile.FinalizingReconciler
type genericFederatedUpstreamGroupFinalizer struct {
	genericFederatedUpstreamGroupReconciler
	finalizingReconciler FederatedUpstreamGroupFinalizer
}

func (r genericFederatedUpstreamGroupFinalizer) FinalizerName() string {
	return r.finalizingReconciler.FederatedUpstreamGroupFinalizerName()
}

func (r genericFederatedUpstreamGroupFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*fed_gloo_solo_io_v1.FederatedUpstreamGroup)
	if !ok {
		return errors.Errorf("internal error: FederatedUpstreamGroup handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeFederatedUpstreamGroup(obj)
}

// Reconcile Upsert events for the FederatedSettings Resource.
// implemented by the user
type FederatedSettingsReconciler interface {
	ReconcileFederatedSettings(obj *fed_gloo_solo_io_v1.FederatedSettings) (reconcile.Result, error)
}

// Reconcile deletion events for the FederatedSettings Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type FederatedSettingsDeletionReconciler interface {
	ReconcileFederatedSettingsDeletion(req reconcile.Request) error
}

type FederatedSettingsReconcilerFuncs struct {
	OnReconcileFederatedSettings         func(obj *fed_gloo_solo_io_v1.FederatedSettings) (reconcile.Result, error)
	OnReconcileFederatedSettingsDeletion func(req reconcile.Request) error
}

func (f *FederatedSettingsReconcilerFuncs) ReconcileFederatedSettings(obj *fed_gloo_solo_io_v1.FederatedSettings) (reconcile.Result, error) {
	if f.OnReconcileFederatedSettings == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileFederatedSettings(obj)
}

func (f *FederatedSettingsReconcilerFuncs) ReconcileFederatedSettingsDeletion(req reconcile.Request) error {
	if f.OnReconcileFederatedSettingsDeletion == nil {
		return nil
	}
	return f.OnReconcileFederatedSettingsDeletion(req)
}

// Reconcile and finalize the FederatedSettings Resource
// implemented by the user
type FederatedSettingsFinalizer interface {
	FederatedSettingsReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	FederatedSettingsFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeFederatedSettings(obj *fed_gloo_solo_io_v1.FederatedSettings) error
}

type FederatedSettingsReconcileLoop interface {
	RunFederatedSettingsReconciler(ctx context.Context, rec FederatedSettingsReconciler, predicates ...predicate.Predicate) error
}

type federatedSettingsReconcileLoop struct {
	loop reconcile.Loop
}

func NewFederatedSettingsReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) FederatedSettingsReconcileLoop {
	return &federatedSettingsReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &fed_gloo_solo_io_v1.FederatedSettings{}, options),
	}
}

func (c *federatedSettingsReconcileLoop) RunFederatedSettingsReconciler(ctx context.Context, reconciler FederatedSettingsReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericFederatedSettingsReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(FederatedSettingsFinalizer); ok {
		reconcilerWrapper = genericFederatedSettingsFinalizer{
			genericFederatedSettingsReconciler: genericReconciler,
			finalizingReconciler:               finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericFederatedSettingsHandler implements a generic reconcile.Reconciler
type genericFederatedSettingsReconciler struct {
	reconciler FederatedSettingsReconciler
}

func (r genericFederatedSettingsReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*fed_gloo_solo_io_v1.FederatedSettings)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: FederatedSettings handler received event for %T", object)
	}
	return r.reconciler.ReconcileFederatedSettings(obj)
}

func (r genericFederatedSettingsReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(FederatedSettingsDeletionReconciler); ok {
		return deletionReconciler.ReconcileFederatedSettingsDeletion(request)
	}
	return nil
}

// genericFederatedSettingsFinalizer implements a generic reconcile.FinalizingReconciler
type genericFederatedSettingsFinalizer struct {
	genericFederatedSettingsReconciler
	finalizingReconciler FederatedSettingsFinalizer
}

func (r genericFederatedSettingsFinalizer) FinalizerName() string {
	return r.finalizingReconciler.FederatedSettingsFinalizerName()
}

func (r genericFederatedSettingsFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*fed_gloo_solo_io_v1.FederatedSettings)
	if !ok {
		return errors.Errorf("internal error: FederatedSettings handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeFederatedSettings(obj)
}
