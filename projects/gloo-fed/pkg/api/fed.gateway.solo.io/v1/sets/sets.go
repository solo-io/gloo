// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./sets.go -destination mocks/sets.go

package v1sets

import (
	fed_gateway_solo_io_v1 "github.com/solo-io/solo-projects/projects/gloo-fed/pkg/api/fed.gateway.solo.io/v1"

	"github.com/rotisserie/eris"
	sksets "github.com/solo-io/skv2/contrib/pkg/sets"
	"github.com/solo-io/skv2/pkg/ezkube"
	"k8s.io/apimachinery/pkg/util/sets"
)

type FederatedGatewaySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*fed_gateway_solo_io_v1.FederatedGateway) bool) []*fed_gateway_solo_io_v1.FederatedGateway
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*fed_gateway_solo_io_v1.FederatedGateway) bool) []*fed_gateway_solo_io_v1.FederatedGateway
	// Return the Set as a map of key to resource.
	Map() map[string]*fed_gateway_solo_io_v1.FederatedGateway
	// Insert a resource into the set.
	Insert(federatedGateway ...*fed_gateway_solo_io_v1.FederatedGateway)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(federatedGatewaySet FederatedGatewaySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(federatedGateway ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(federatedGateway ezkube.ResourceId)
	// Return the union with the provided set
	Union(set FederatedGatewaySet) FederatedGatewaySet
	// Return the difference with the provided set
	Difference(set FederatedGatewaySet) FederatedGatewaySet
	// Return the intersection with the provided set
	Intersection(set FederatedGatewaySet) FederatedGatewaySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*fed_gateway_solo_io_v1.FederatedGateway, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another FederatedGatewaySet
	Delta(newSet FederatedGatewaySet) sksets.ResourceDelta
	// Create a deep copy of the current FederatedGatewaySet
	Clone() FederatedGatewaySet
}

func makeGenericFederatedGatewaySet(federatedGatewayList []*fed_gateway_solo_io_v1.FederatedGateway) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range federatedGatewayList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type federatedGatewaySet struct {
	set sksets.ResourceSet
}

func NewFederatedGatewaySet(federatedGatewayList ...*fed_gateway_solo_io_v1.FederatedGateway) FederatedGatewaySet {
	return &federatedGatewaySet{set: makeGenericFederatedGatewaySet(federatedGatewayList)}
}

func NewFederatedGatewaySetFromList(federatedGatewayList *fed_gateway_solo_io_v1.FederatedGatewayList) FederatedGatewaySet {
	list := make([]*fed_gateway_solo_io_v1.FederatedGateway, 0, len(federatedGatewayList.Items))
	for idx := range federatedGatewayList.Items {
		list = append(list, &federatedGatewayList.Items[idx])
	}
	return &federatedGatewaySet{set: makeGenericFederatedGatewaySet(list)}
}

func (s *federatedGatewaySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *federatedGatewaySet) List(filterResource ...func(*fed_gateway_solo_io_v1.FederatedGateway) bool) []*fed_gateway_solo_io_v1.FederatedGateway {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*fed_gateway_solo_io_v1.FederatedGateway))
		})
	}

	objs := s.Generic().List(genericFilters...)
	federatedGatewayList := make([]*fed_gateway_solo_io_v1.FederatedGateway, 0, len(objs))
	for _, obj := range objs {
		federatedGatewayList = append(federatedGatewayList, obj.(*fed_gateway_solo_io_v1.FederatedGateway))
	}
	return federatedGatewayList
}

func (s *federatedGatewaySet) UnsortedList(filterResource ...func(*fed_gateway_solo_io_v1.FederatedGateway) bool) []*fed_gateway_solo_io_v1.FederatedGateway {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*fed_gateway_solo_io_v1.FederatedGateway))
		})
	}

	var federatedGatewayList []*fed_gateway_solo_io_v1.FederatedGateway
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		federatedGatewayList = append(federatedGatewayList, obj.(*fed_gateway_solo_io_v1.FederatedGateway))
	}
	return federatedGatewayList
}

func (s *federatedGatewaySet) Map() map[string]*fed_gateway_solo_io_v1.FederatedGateway {
	if s == nil {
		return nil
	}

	newMap := map[string]*fed_gateway_solo_io_v1.FederatedGateway{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*fed_gateway_solo_io_v1.FederatedGateway)
	}
	return newMap
}

func (s *federatedGatewaySet) Insert(
	federatedGatewayList ...*fed_gateway_solo_io_v1.FederatedGateway,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range federatedGatewayList {
		s.Generic().Insert(obj)
	}
}

func (s *federatedGatewaySet) Has(federatedGateway ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(federatedGateway)
}

func (s *federatedGatewaySet) Equal(
	federatedGatewaySet FederatedGatewaySet,
) bool {
	if s == nil {
		return federatedGatewaySet == nil
	}
	return s.Generic().Equal(federatedGatewaySet.Generic())
}

func (s *federatedGatewaySet) Delete(FederatedGateway ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(FederatedGateway)
}

func (s *federatedGatewaySet) Union(set FederatedGatewaySet) FederatedGatewaySet {
	if s == nil {
		return set
	}
	return NewFederatedGatewaySet(append(s.List(), set.List()...)...)
}

func (s *federatedGatewaySet) Difference(set FederatedGatewaySet) FederatedGatewaySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &federatedGatewaySet{set: newSet}
}

func (s *federatedGatewaySet) Intersection(set FederatedGatewaySet) FederatedGatewaySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var federatedGatewayList []*fed_gateway_solo_io_v1.FederatedGateway
	for _, obj := range newSet.List() {
		federatedGatewayList = append(federatedGatewayList, obj.(*fed_gateway_solo_io_v1.FederatedGateway))
	}
	return NewFederatedGatewaySet(federatedGatewayList...)
}

func (s *federatedGatewaySet) Find(id ezkube.ResourceId) (*fed_gateway_solo_io_v1.FederatedGateway, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find FederatedGateway %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&fed_gateway_solo_io_v1.FederatedGateway{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*fed_gateway_solo_io_v1.FederatedGateway), nil
}

func (s *federatedGatewaySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *federatedGatewaySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *federatedGatewaySet) Delta(newSet FederatedGatewaySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *federatedGatewaySet) Clone() FederatedGatewaySet {
	if s == nil {
		return nil
	}
	return &federatedGatewaySet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type FederatedVirtualServiceSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*fed_gateway_solo_io_v1.FederatedVirtualService) bool) []*fed_gateway_solo_io_v1.FederatedVirtualService
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*fed_gateway_solo_io_v1.FederatedVirtualService) bool) []*fed_gateway_solo_io_v1.FederatedVirtualService
	// Return the Set as a map of key to resource.
	Map() map[string]*fed_gateway_solo_io_v1.FederatedVirtualService
	// Insert a resource into the set.
	Insert(federatedVirtualService ...*fed_gateway_solo_io_v1.FederatedVirtualService)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(federatedVirtualServiceSet FederatedVirtualServiceSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(federatedVirtualService ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(federatedVirtualService ezkube.ResourceId)
	// Return the union with the provided set
	Union(set FederatedVirtualServiceSet) FederatedVirtualServiceSet
	// Return the difference with the provided set
	Difference(set FederatedVirtualServiceSet) FederatedVirtualServiceSet
	// Return the intersection with the provided set
	Intersection(set FederatedVirtualServiceSet) FederatedVirtualServiceSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*fed_gateway_solo_io_v1.FederatedVirtualService, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another FederatedVirtualServiceSet
	Delta(newSet FederatedVirtualServiceSet) sksets.ResourceDelta
	// Create a deep copy of the current FederatedVirtualServiceSet
	Clone() FederatedVirtualServiceSet
}

func makeGenericFederatedVirtualServiceSet(federatedVirtualServiceList []*fed_gateway_solo_io_v1.FederatedVirtualService) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range federatedVirtualServiceList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type federatedVirtualServiceSet struct {
	set sksets.ResourceSet
}

func NewFederatedVirtualServiceSet(federatedVirtualServiceList ...*fed_gateway_solo_io_v1.FederatedVirtualService) FederatedVirtualServiceSet {
	return &federatedVirtualServiceSet{set: makeGenericFederatedVirtualServiceSet(federatedVirtualServiceList)}
}

func NewFederatedVirtualServiceSetFromList(federatedVirtualServiceList *fed_gateway_solo_io_v1.FederatedVirtualServiceList) FederatedVirtualServiceSet {
	list := make([]*fed_gateway_solo_io_v1.FederatedVirtualService, 0, len(federatedVirtualServiceList.Items))
	for idx := range federatedVirtualServiceList.Items {
		list = append(list, &federatedVirtualServiceList.Items[idx])
	}
	return &federatedVirtualServiceSet{set: makeGenericFederatedVirtualServiceSet(list)}
}

func (s *federatedVirtualServiceSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *federatedVirtualServiceSet) List(filterResource ...func(*fed_gateway_solo_io_v1.FederatedVirtualService) bool) []*fed_gateway_solo_io_v1.FederatedVirtualService {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*fed_gateway_solo_io_v1.FederatedVirtualService))
		})
	}

	objs := s.Generic().List(genericFilters...)
	federatedVirtualServiceList := make([]*fed_gateway_solo_io_v1.FederatedVirtualService, 0, len(objs))
	for _, obj := range objs {
		federatedVirtualServiceList = append(federatedVirtualServiceList, obj.(*fed_gateway_solo_io_v1.FederatedVirtualService))
	}
	return federatedVirtualServiceList
}

func (s *federatedVirtualServiceSet) UnsortedList(filterResource ...func(*fed_gateway_solo_io_v1.FederatedVirtualService) bool) []*fed_gateway_solo_io_v1.FederatedVirtualService {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*fed_gateway_solo_io_v1.FederatedVirtualService))
		})
	}

	var federatedVirtualServiceList []*fed_gateway_solo_io_v1.FederatedVirtualService
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		federatedVirtualServiceList = append(federatedVirtualServiceList, obj.(*fed_gateway_solo_io_v1.FederatedVirtualService))
	}
	return federatedVirtualServiceList
}

func (s *federatedVirtualServiceSet) Map() map[string]*fed_gateway_solo_io_v1.FederatedVirtualService {
	if s == nil {
		return nil
	}

	newMap := map[string]*fed_gateway_solo_io_v1.FederatedVirtualService{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*fed_gateway_solo_io_v1.FederatedVirtualService)
	}
	return newMap
}

func (s *federatedVirtualServiceSet) Insert(
	federatedVirtualServiceList ...*fed_gateway_solo_io_v1.FederatedVirtualService,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range federatedVirtualServiceList {
		s.Generic().Insert(obj)
	}
}

func (s *federatedVirtualServiceSet) Has(federatedVirtualService ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(federatedVirtualService)
}

func (s *federatedVirtualServiceSet) Equal(
	federatedVirtualServiceSet FederatedVirtualServiceSet,
) bool {
	if s == nil {
		return federatedVirtualServiceSet == nil
	}
	return s.Generic().Equal(federatedVirtualServiceSet.Generic())
}

func (s *federatedVirtualServiceSet) Delete(FederatedVirtualService ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(FederatedVirtualService)
}

func (s *federatedVirtualServiceSet) Union(set FederatedVirtualServiceSet) FederatedVirtualServiceSet {
	if s == nil {
		return set
	}
	return NewFederatedVirtualServiceSet(append(s.List(), set.List()...)...)
}

func (s *federatedVirtualServiceSet) Difference(set FederatedVirtualServiceSet) FederatedVirtualServiceSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &federatedVirtualServiceSet{set: newSet}
}

func (s *federatedVirtualServiceSet) Intersection(set FederatedVirtualServiceSet) FederatedVirtualServiceSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var federatedVirtualServiceList []*fed_gateway_solo_io_v1.FederatedVirtualService
	for _, obj := range newSet.List() {
		federatedVirtualServiceList = append(federatedVirtualServiceList, obj.(*fed_gateway_solo_io_v1.FederatedVirtualService))
	}
	return NewFederatedVirtualServiceSet(federatedVirtualServiceList...)
}

func (s *federatedVirtualServiceSet) Find(id ezkube.ResourceId) (*fed_gateway_solo_io_v1.FederatedVirtualService, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find FederatedVirtualService %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&fed_gateway_solo_io_v1.FederatedVirtualService{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*fed_gateway_solo_io_v1.FederatedVirtualService), nil
}

func (s *federatedVirtualServiceSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *federatedVirtualServiceSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *federatedVirtualServiceSet) Delta(newSet FederatedVirtualServiceSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *federatedVirtualServiceSet) Clone() FederatedVirtualServiceSet {
	if s == nil {
		return nil
	}
	return &federatedVirtualServiceSet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type FederatedRouteTableSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*fed_gateway_solo_io_v1.FederatedRouteTable) bool) []*fed_gateway_solo_io_v1.FederatedRouteTable
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*fed_gateway_solo_io_v1.FederatedRouteTable) bool) []*fed_gateway_solo_io_v1.FederatedRouteTable
	// Return the Set as a map of key to resource.
	Map() map[string]*fed_gateway_solo_io_v1.FederatedRouteTable
	// Insert a resource into the set.
	Insert(federatedRouteTable ...*fed_gateway_solo_io_v1.FederatedRouteTable)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(federatedRouteTableSet FederatedRouteTableSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(federatedRouteTable ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(federatedRouteTable ezkube.ResourceId)
	// Return the union with the provided set
	Union(set FederatedRouteTableSet) FederatedRouteTableSet
	// Return the difference with the provided set
	Difference(set FederatedRouteTableSet) FederatedRouteTableSet
	// Return the intersection with the provided set
	Intersection(set FederatedRouteTableSet) FederatedRouteTableSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*fed_gateway_solo_io_v1.FederatedRouteTable, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another FederatedRouteTableSet
	Delta(newSet FederatedRouteTableSet) sksets.ResourceDelta
	// Create a deep copy of the current FederatedRouteTableSet
	Clone() FederatedRouteTableSet
}

func makeGenericFederatedRouteTableSet(federatedRouteTableList []*fed_gateway_solo_io_v1.FederatedRouteTable) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range federatedRouteTableList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type federatedRouteTableSet struct {
	set sksets.ResourceSet
}

func NewFederatedRouteTableSet(federatedRouteTableList ...*fed_gateway_solo_io_v1.FederatedRouteTable) FederatedRouteTableSet {
	return &federatedRouteTableSet{set: makeGenericFederatedRouteTableSet(federatedRouteTableList)}
}

func NewFederatedRouteTableSetFromList(federatedRouteTableList *fed_gateway_solo_io_v1.FederatedRouteTableList) FederatedRouteTableSet {
	list := make([]*fed_gateway_solo_io_v1.FederatedRouteTable, 0, len(federatedRouteTableList.Items))
	for idx := range federatedRouteTableList.Items {
		list = append(list, &federatedRouteTableList.Items[idx])
	}
	return &federatedRouteTableSet{set: makeGenericFederatedRouteTableSet(list)}
}

func (s *federatedRouteTableSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *federatedRouteTableSet) List(filterResource ...func(*fed_gateway_solo_io_v1.FederatedRouteTable) bool) []*fed_gateway_solo_io_v1.FederatedRouteTable {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*fed_gateway_solo_io_v1.FederatedRouteTable))
		})
	}

	objs := s.Generic().List(genericFilters...)
	federatedRouteTableList := make([]*fed_gateway_solo_io_v1.FederatedRouteTable, 0, len(objs))
	for _, obj := range objs {
		federatedRouteTableList = append(federatedRouteTableList, obj.(*fed_gateway_solo_io_v1.FederatedRouteTable))
	}
	return federatedRouteTableList
}

func (s *federatedRouteTableSet) UnsortedList(filterResource ...func(*fed_gateway_solo_io_v1.FederatedRouteTable) bool) []*fed_gateway_solo_io_v1.FederatedRouteTable {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*fed_gateway_solo_io_v1.FederatedRouteTable))
		})
	}

	var federatedRouteTableList []*fed_gateway_solo_io_v1.FederatedRouteTable
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		federatedRouteTableList = append(federatedRouteTableList, obj.(*fed_gateway_solo_io_v1.FederatedRouteTable))
	}
	return federatedRouteTableList
}

func (s *federatedRouteTableSet) Map() map[string]*fed_gateway_solo_io_v1.FederatedRouteTable {
	if s == nil {
		return nil
	}

	newMap := map[string]*fed_gateway_solo_io_v1.FederatedRouteTable{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*fed_gateway_solo_io_v1.FederatedRouteTable)
	}
	return newMap
}

func (s *federatedRouteTableSet) Insert(
	federatedRouteTableList ...*fed_gateway_solo_io_v1.FederatedRouteTable,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range federatedRouteTableList {
		s.Generic().Insert(obj)
	}
}

func (s *federatedRouteTableSet) Has(federatedRouteTable ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(federatedRouteTable)
}

func (s *federatedRouteTableSet) Equal(
	federatedRouteTableSet FederatedRouteTableSet,
) bool {
	if s == nil {
		return federatedRouteTableSet == nil
	}
	return s.Generic().Equal(federatedRouteTableSet.Generic())
}

func (s *federatedRouteTableSet) Delete(FederatedRouteTable ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(FederatedRouteTable)
}

func (s *federatedRouteTableSet) Union(set FederatedRouteTableSet) FederatedRouteTableSet {
	if s == nil {
		return set
	}
	return NewFederatedRouteTableSet(append(s.List(), set.List()...)...)
}

func (s *federatedRouteTableSet) Difference(set FederatedRouteTableSet) FederatedRouteTableSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &federatedRouteTableSet{set: newSet}
}

func (s *federatedRouteTableSet) Intersection(set FederatedRouteTableSet) FederatedRouteTableSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var federatedRouteTableList []*fed_gateway_solo_io_v1.FederatedRouteTable
	for _, obj := range newSet.List() {
		federatedRouteTableList = append(federatedRouteTableList, obj.(*fed_gateway_solo_io_v1.FederatedRouteTable))
	}
	return NewFederatedRouteTableSet(federatedRouteTableList...)
}

func (s *federatedRouteTableSet) Find(id ezkube.ResourceId) (*fed_gateway_solo_io_v1.FederatedRouteTable, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find FederatedRouteTable %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&fed_gateway_solo_io_v1.FederatedRouteTable{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*fed_gateway_solo_io_v1.FederatedRouteTable), nil
}

func (s *federatedRouteTableSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *federatedRouteTableSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *federatedRouteTableSet) Delta(newSet FederatedRouteTableSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *federatedRouteTableSet) Clone() FederatedRouteTableSet {
	if s == nil {
		return nil
	}
	return &federatedRouteTableSet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}
