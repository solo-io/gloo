// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.6.1
// source: github.com/solo-io/gloo/projects/gloo/api/v1/listener_options.proto

package v1

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	als "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/options/als"
	proxy_protocol "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/options/proxy_protocol"
	_ "github.com/solo-io/protoc-gen-ext/extproto"
	core "github.com/solo-io/solo-kit/pkg/api/external/envoy/api/v2/core"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Optional, feature-specific configuration that lives on gateways.
// Each ListenerOption object contains configuration for a specific feature.
// Note to developers: new Listener plugins must be added to this struct
// to be usable by Gloo. (plugins currently need to be compiled into Gloo)
type ListenerOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Configuration for access logging in a filter like the HttpConnectionManager.
	AccessLoggingService *als.AccessLoggingService `protobuf:"bytes,1,opt,name=access_logging_service,json=accessLoggingService,proto3" json:"access_logging_service,omitempty"`
	// Extensions will be passed along from Listeners, Gateways, VirtualServices, Routes, and Route tables to the
	// underlying Proxy, making them useful for controllers, validation tools, etc. which interact with kubernetes yaml.
	//
	// Some sample use cases:
	// * controllers, deployment pipelines, helm charts, etc. which wish to use extensions as a kind of opaque metadata.
	// * In the future, Gloo may support gRPC-based plugins which communicate with the Gloo translator out-of-process.
	// Opaque Extensions enables development of out-of-process plugins without requiring recompiling & redeploying Gloo's API.
	Extensions *Extensions `protobuf:"bytes,2,opt,name=extensions,proto3" json:"extensions,omitempty"`
	// Soft limit on size of the listener's new connection read and write buffers. If unspecified, defaults to 1MiB
	// For more info, check out the [Envoy docs](https://www.envoyproxy.io/docs/envoy/v1.14.1/api-v2/api/v2/listener.proto)
	PerConnectionBufferLimitBytes *wrapperspb.UInt32Value `protobuf:"bytes,3,opt,name=per_connection_buffer_limit_bytes,json=perConnectionBufferLimitBytes,proto3" json:"per_connection_buffer_limit_bytes,omitempty"`
	// Additional socket options that may not be present in Envoy source code or
	// precompiled binaries.
	SocketOptions []*core.SocketOption `protobuf:"bytes,4,rep,name=socket_options,json=socketOptions,proto3" json:"socket_options,omitempty"`
	// Enable ProxyProtocol support for this listener.
	ProxyProtocol *proxy_protocol.ProxyProtocol `protobuf:"bytes,5,opt,name=proxy_protocol,json=proxyProtocol,proto3" json:"proxy_protocol,omitempty"`
	// Configuration for listener connection balancing.
	ConnectionBalanceConfig *ConnectionBalanceConfig `protobuf:"bytes,6,opt,name=connection_balance_config,json=connectionBalanceConfig,proto3" json:"connection_balance_config,omitempty"`
	// If enabled this sets up an early access logging service for the listener.
	// Added initially to support listener level logging for HTTP listeners.
	// For more info see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/listener/v3/listener.proto#envoy-v3-api-field-config-listener-v3-listener-access-log
	ListenerAccessLoggingService *als.AccessLoggingService `protobuf:"bytes,7,opt,name=listener_access_logging_service,json=listenerAccessLoggingService,proto3" json:"listener_access_logging_service,omitempty"`
	// If true, will wrap all filter chains in the listener with a TCP stats transport socket, which is a
	// passthrough listener that can report low-level Linux TCP stats, useful for diagnosis
	// and triage.
	TcpStats      *wrapperspb.BoolValue `protobuf:"bytes,8,opt,name=tcp_stats,json=tcpStats,proto3" json:"tcp_stats,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListenerOptions) Reset() {
	*x = ListenerOptions{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListenerOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListenerOptions) ProtoMessage() {}

func (x *ListenerOptions) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListenerOptions.ProtoReflect.Descriptor instead.
func (*ListenerOptions) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_rawDescGZIP(), []int{0}
}

func (x *ListenerOptions) GetAccessLoggingService() *als.AccessLoggingService {
	if x != nil {
		return x.AccessLoggingService
	}
	return nil
}

func (x *ListenerOptions) GetExtensions() *Extensions {
	if x != nil {
		return x.Extensions
	}
	return nil
}

func (x *ListenerOptions) GetPerConnectionBufferLimitBytes() *wrapperspb.UInt32Value {
	if x != nil {
		return x.PerConnectionBufferLimitBytes
	}
	return nil
}

func (x *ListenerOptions) GetSocketOptions() []*core.SocketOption {
	if x != nil {
		return x.SocketOptions
	}
	return nil
}

func (x *ListenerOptions) GetProxyProtocol() *proxy_protocol.ProxyProtocol {
	if x != nil {
		return x.ProxyProtocol
	}
	return nil
}

func (x *ListenerOptions) GetConnectionBalanceConfig() *ConnectionBalanceConfig {
	if x != nil {
		return x.ConnectionBalanceConfig
	}
	return nil
}

func (x *ListenerOptions) GetListenerAccessLoggingService() *als.AccessLoggingService {
	if x != nil {
		return x.ListenerAccessLoggingService
	}
	return nil
}

func (x *ListenerOptions) GetTcpStats() *wrapperspb.BoolValue {
	if x != nil {
		return x.TcpStats
	}
	return nil
}

// Configuration for listener connection balancing.
type ConnectionBalanceConfig struct {
	state         protoimpl.MessageState                `protogen:"open.v1"`
	ExactBalance  *ConnectionBalanceConfig_ExactBalance `protobuf:"bytes,1,opt,name=exact_balance,json=exactBalance,proto3" json:"exact_balance,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnectionBalanceConfig) Reset() {
	*x = ConnectionBalanceConfig{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnectionBalanceConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectionBalanceConfig) ProtoMessage() {}

func (x *ConnectionBalanceConfig) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectionBalanceConfig.ProtoReflect.Descriptor instead.
func (*ConnectionBalanceConfig) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_rawDescGZIP(), []int{1}
}

func (x *ConnectionBalanceConfig) GetExactBalance() *ConnectionBalanceConfig_ExactBalance {
	if x != nil {
		return x.ExactBalance
	}
	return nil
}

// A connection balancer implementation that does exact balancing. This means that a lock is
// held during balancing so that connection counts are nearly exactly balanced between worker
// threads. This is "nearly" exact in the sense that a connection might close in parallel thus
// making the counts incorrect, but this should be rectified on the next accept. This balancer
// sacrifices accept throughput for accuracy and should be used when there are a small number of
// connections that rarely cycle (e.g., service mesh gRPC egress).
type ConnectionBalanceConfig_ExactBalance struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnectionBalanceConfig_ExactBalance) Reset() {
	*x = ConnectionBalanceConfig_ExactBalance{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnectionBalanceConfig_ExactBalance) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectionBalanceConfig_ExactBalance) ProtoMessage() {}

func (x *ConnectionBalanceConfig_ExactBalance) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectionBalanceConfig_ExactBalance.ProtoReflect.Descriptor instead.
func (*ConnectionBalanceConfig_ExactBalance) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_rawDescGZIP(), []int{1, 0}
}

var File_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto protoreflect.FileDescriptor

const file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_rawDesc = "" +
	"\n" +
	"Cgithub.com/solo-io/gloo/projects/gloo/api/v1/listener_options.proto\x12\fgloo.solo.io\x1a\x12extproto/ext.proto\x1a=github.com/solo-io/gloo/projects/gloo/api/v1/extensions.proto\x1aNgithub.com/solo-io/solo-kit/api/external/envoy/api/v2/core/socket_option.proto\x1aXgithub.com/solo-io/gloo/projects/gloo/api/v1/options/proxy_protocol/proxy_protocol.proto\x1aBgithub.com/solo-io/gloo/projects/gloo/api/v1/options/als/als.proto\x1a\x1egoogle/protobuf/wrappers.proto\"\xd7\x05\n" +
	"\x0fListenerOptions\x12d\n" +
	"\x16access_logging_service\x18\x01 \x01(\v2..als.options.gloo.solo.io.AccessLoggingServiceR\x14accessLoggingService\x128\n" +
	"\n" +
	"extensions\x18\x02 \x01(\v2\x18.gloo.solo.io.ExtensionsR\n" +
	"extensions\x12f\n" +
	"!per_connection_buffer_limit_bytes\x18\x03 \x01(\v2\x1c.google.protobuf.UInt32ValueR\x1dperConnectionBufferLimitBytes\x12N\n" +
	"\x0esocket_options\x18\x04 \x03(\v2'.solo.io.envoy.api.v2.core.SocketOptionR\rsocketOptions\x12Y\n" +
	"\x0eproxy_protocol\x18\x05 \x01(\v22.proxy_protocol.options.gloo.solo.io.ProxyProtocolR\rproxyProtocol\x12a\n" +
	"\x19connection_balance_config\x18\x06 \x01(\v2%.gloo.solo.io.ConnectionBalanceConfigR\x17connectionBalanceConfig\x12u\n" +
	"\x1flistener_access_logging_service\x18\a \x01(\v2..als.options.gloo.solo.io.AccessLoggingServiceR\x1clistenerAccessLoggingService\x127\n" +
	"\ttcp_stats\x18\b \x01(\v2\x1a.google.protobuf.BoolValueR\btcpStats\"\x82\x01\n" +
	"\x17ConnectionBalanceConfig\x12W\n" +
	"\rexact_balance\x18\x01 \x01(\v22.gloo.solo.io.ConnectionBalanceConfig.ExactBalanceR\fexactBalance\x1a\x0e\n" +
	"\fExactBalanceB>\xb8\xf5\x04\x01\xc0\xf5\x04\x01\xd0\xf5\x04\x01Z0github.com/solo-io/gloo/projects/gloo/pkg/api/v1b\x06proto3"

var (
	file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_rawDescOnce sync.Once
	file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_rawDescData []byte
)

func file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_rawDescGZIP() []byte {
	file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_rawDescOnce.Do(func() {
		file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_rawDesc), len(file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_rawDesc)))
	})
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_rawDescData
}

var file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_goTypes = []any{
	(*ListenerOptions)(nil),                      // 0: gloo.solo.io.ListenerOptions
	(*ConnectionBalanceConfig)(nil),              // 1: gloo.solo.io.ConnectionBalanceConfig
	(*ConnectionBalanceConfig_ExactBalance)(nil), // 2: gloo.solo.io.ConnectionBalanceConfig.ExactBalance
	(*als.AccessLoggingService)(nil),             // 3: als.options.gloo.solo.io.AccessLoggingService
	(*Extensions)(nil),                           // 4: gloo.solo.io.Extensions
	(*wrapperspb.UInt32Value)(nil),               // 5: google.protobuf.UInt32Value
	(*core.SocketOption)(nil),                    // 6: solo.io.envoy.api.v2.core.SocketOption
	(*proxy_protocol.ProxyProtocol)(nil),         // 7: proxy_protocol.options.gloo.solo.io.ProxyProtocol
	(*wrapperspb.BoolValue)(nil),                 // 8: google.protobuf.BoolValue
}
var file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_depIdxs = []int32{
	3, // 0: gloo.solo.io.ListenerOptions.access_logging_service:type_name -> als.options.gloo.solo.io.AccessLoggingService
	4, // 1: gloo.solo.io.ListenerOptions.extensions:type_name -> gloo.solo.io.Extensions
	5, // 2: gloo.solo.io.ListenerOptions.per_connection_buffer_limit_bytes:type_name -> google.protobuf.UInt32Value
	6, // 3: gloo.solo.io.ListenerOptions.socket_options:type_name -> solo.io.envoy.api.v2.core.SocketOption
	7, // 4: gloo.solo.io.ListenerOptions.proxy_protocol:type_name -> proxy_protocol.options.gloo.solo.io.ProxyProtocol
	1, // 5: gloo.solo.io.ListenerOptions.connection_balance_config:type_name -> gloo.solo.io.ConnectionBalanceConfig
	3, // 6: gloo.solo.io.ListenerOptions.listener_access_logging_service:type_name -> als.options.gloo.solo.io.AccessLoggingService
	8, // 7: gloo.solo.io.ListenerOptions.tcp_stats:type_name -> google.protobuf.BoolValue
	2, // 8: gloo.solo.io.ConnectionBalanceConfig.exact_balance:type_name -> gloo.solo.io.ConnectionBalanceConfig.ExactBalance
	9, // [9:9] is the sub-list for method output_type
	9, // [9:9] is the sub-list for method input_type
	9, // [9:9] is the sub-list for extension type_name
	9, // [9:9] is the sub-list for extension extendee
	0, // [0:9] is the sub-list for field type_name
}

func init() { file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_init() }
func file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_init() {
	if File_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto != nil {
		return
	}
	file_github_com_solo_io_gloo_projects_gloo_api_v1_extensions_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_rawDesc), len(file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   3,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_goTypes,
		DependencyIndexes: file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_depIdxs,
		MessageInfos:      file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_msgTypes,
	}.Build()
	File_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto = out.File
	file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_goTypes = nil
	file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_depIdxs = nil
}
