// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.6.1
// source: github.com/solo-io/gloo/projects/gloo/api/v1/proxy.proto

package v1

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	v3 "github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/core/v3"
	v31 "github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/type/matcher/v3"
	matchers "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/core/matchers"
	filters "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/filters"
	dynamic_forward_proxy "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/options/dynamic_forward_proxy"
	ssl "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/ssl"
	_ "github.com/solo-io/protoc-gen-ext/extproto"
	core "github.com/solo-io/solo-kit/pkg/api/v1/resources/core"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	anypb "google.golang.org/protobuf/types/known/anypb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type RedirectAction_RedirectResponseCode int32

const (
	// Moved Permanently HTTP Status Code - 301.
	RedirectAction_MOVED_PERMANENTLY RedirectAction_RedirectResponseCode = 0
	// Found HTTP Status Code - 302.
	RedirectAction_FOUND RedirectAction_RedirectResponseCode = 1
	// See Other HTTP Status Code - 303.
	RedirectAction_SEE_OTHER RedirectAction_RedirectResponseCode = 2
	// Temporary Redirect HTTP Status Code - 307.
	RedirectAction_TEMPORARY_REDIRECT RedirectAction_RedirectResponseCode = 3
	// Permanent Redirect HTTP Status Code - 308.
	RedirectAction_PERMANENT_REDIRECT RedirectAction_RedirectResponseCode = 4
)

// Enum value maps for RedirectAction_RedirectResponseCode.
var (
	RedirectAction_RedirectResponseCode_name = map[int32]string{
		0: "MOVED_PERMANENTLY",
		1: "FOUND",
		2: "SEE_OTHER",
		3: "TEMPORARY_REDIRECT",
		4: "PERMANENT_REDIRECT",
	}
	RedirectAction_RedirectResponseCode_value = map[string]int32{
		"MOVED_PERMANENTLY":  0,
		"FOUND":              1,
		"SEE_OTHER":          2,
		"TEMPORARY_REDIRECT": 3,
		"PERMANENT_REDIRECT": 4,
	}
)

func (x RedirectAction_RedirectResponseCode) Enum() *RedirectAction_RedirectResponseCode {
	p := new(RedirectAction_RedirectResponseCode)
	*p = x
	return p
}

func (x RedirectAction_RedirectResponseCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RedirectAction_RedirectResponseCode) Descriptor() protoreflect.EnumDescriptor {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_enumTypes[0].Descriptor()
}

func (RedirectAction_RedirectResponseCode) Type() protoreflect.EnumType {
	return &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_enumTypes[0]
}

func (x RedirectAction_RedirectResponseCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RedirectAction_RedirectResponseCode.Descriptor instead.
func (RedirectAction_RedirectResponseCode) EnumDescriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{19, 0}
}

// A Proxy is a container for the entire set of configuration that will to be applied to one or more Proxy instances.
// Proxies can be understood as a set of listeners, represents a different bind address/port where the proxy will listen
// for connections. Each listener has its own set of configuration.
//
// If any of the sub-resources within a listener is declared invalid (e.g. due to invalid user configuration), the
// proxy will be marked invalid by Gloo.
//
// Proxy instances that register with Gloo are assigned the proxy configuration corresponding with
// a proxy-specific identifier.
// In the case of Envoy, proxy instances are identified by their Node ID. Node IDs must match a existing Proxy
// Node ID can be specified in Envoy with the `--service-node` flag, or in the Envoy instance's bootstrap config.
type Proxy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This field is populated when the proxy compression is turned on.
	CompressedSpec string `protobuf:"bytes,3,opt,name=compressedSpec,proto3" json:"compressedSpec,omitempty"`
	// Define here each listener the proxy should create.
	// Listeners define the a set of behaviors for a single bind address/port where the proxy will listen
	// If no listeners are specified, the instances configured with the proxy resource will not accept connections.
	Listeners []*Listener `protobuf:"bytes,2,rep,name=listeners,proto3" json:"listeners,omitempty"`
	// NamespacedStatuses indicates the validation status of this resource.
	// NamespacedStatuses is read-only by clients, and set by gloo during validation
	NamespacedStatuses *core.NamespacedStatuses `protobuf:"bytes,8,opt,name=namespaced_statuses,json=namespacedStatuses,proto3" json:"namespaced_statuses,omitempty"`
	// Metadata contains the object metadata for this resource
	Metadata      *core.Metadata `protobuf:"bytes,7,opt,name=metadata,proto3" json:"metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Proxy) Reset() {
	*x = Proxy{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Proxy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Proxy) ProtoMessage() {}

func (x *Proxy) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Proxy.ProtoReflect.Descriptor instead.
func (*Proxy) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{0}
}

func (x *Proxy) GetCompressedSpec() string {
	if x != nil {
		return x.CompressedSpec
	}
	return ""
}

func (x *Proxy) GetListeners() []*Listener {
	if x != nil {
		return x.Listeners
	}
	return nil
}

func (x *Proxy) GetNamespacedStatuses() *core.NamespacedStatuses {
	if x != nil {
		return x.NamespacedStatuses
	}
	return nil
}

func (x *Proxy) GetMetadata() *core.Metadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// Listeners define the address:port where the proxy will listen for incoming connections
// A Listener accepts connections (currently only HTTP is supported) and apply user-defined behavior for those connections,
// e.g. performing SSL termination, HTTP retries, and rate limiting.
type Listener struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// the name of the listener. names must be unique for each listener within a proxy
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// the bind address for the listener.
	// both ipv4 and ipv6 formats are supported
	BindAddress string `protobuf:"bytes,2,opt,name=bind_address,json=bindAddress,proto3" json:"bind_address,omitempty"`
	// the port to bind on
	// ports numbers must be unique for listeners within a proxy
	BindPort uint32 `protobuf:"varint,3,opt,name=bind_port,json=bindPort,proto3" json:"bind_port,omitempty"`
	// Listeners can listen for HTTP, TCP (unsupported), and UDP (unsupported) connections
	//
	// Types that are valid to be assigned to ListenerType:
	//
	//	*Listener_HttpListener
	//	*Listener_TcpListener
	//	*Listener_HybridListener
	//	*Listener_AggregateListener
	ListenerType isListener_ListenerType `protobuf_oneof:"ListenerType"`
	// SSL Config is optional for the listener. If provided, the listener will serve TLS for connections on this port.
	// Multiple SslConfigs are supported for the purpose of SNI. Be aware that the SNI domain provided in the SSL Config.
	// This is set to the aggregated list of SslConfigs that are defined on the selected VirtualServices
	SslConfigurations []*ssl.SslConfig `protobuf:"bytes,6,rep,name=ssl_configurations,json=sslConfigurations,proto3" json:"ssl_configurations,omitempty"`
	// Enable ProxyProtocol support for this listener.
	// Deprecated: prefer setting the listener option.
	// If configured, the listener option (filter config) overrides any setting here.
	//
	// Deprecated: Marked as deprecated in github.com/solo-io/gloo/projects/gloo/api/v1/proxy.proto.
	UseProxyProto *wrapperspb.BoolValue `protobuf:"bytes,7,opt,name=use_proxy_proto,json=useProxyProto,proto3" json:"use_proxy_proto,omitempty"`
	// top level options
	Options *ListenerOptions `protobuf:"bytes,8,opt,name=options,proto3" json:"options,omitempty"`
	// Types that are valid to be assigned to OpaqueMetadata:
	//
	//	*Listener_Metadata
	//	*Listener_MetadataStatic
	OpaqueMetadata isListener_OpaqueMetadata `protobuf_oneof:"opaque_metadata"`
	// Route Configuration Options
	RouteOptions  *RouteConfigurationOptions `protobuf:"bytes,10,opt,name=route_options,json=routeOptions,proto3" json:"route_options,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Listener) Reset() {
	*x = Listener{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Listener) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Listener) ProtoMessage() {}

func (x *Listener) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Listener.ProtoReflect.Descriptor instead.
func (*Listener) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{1}
}

func (x *Listener) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Listener) GetBindAddress() string {
	if x != nil {
		return x.BindAddress
	}
	return ""
}

func (x *Listener) GetBindPort() uint32 {
	if x != nil {
		return x.BindPort
	}
	return 0
}

func (x *Listener) GetListenerType() isListener_ListenerType {
	if x != nil {
		return x.ListenerType
	}
	return nil
}

func (x *Listener) GetHttpListener() *HttpListener {
	if x != nil {
		if x, ok := x.ListenerType.(*Listener_HttpListener); ok {
			return x.HttpListener
		}
	}
	return nil
}

func (x *Listener) GetTcpListener() *TcpListener {
	if x != nil {
		if x, ok := x.ListenerType.(*Listener_TcpListener); ok {
			return x.TcpListener
		}
	}
	return nil
}

func (x *Listener) GetHybridListener() *HybridListener {
	if x != nil {
		if x, ok := x.ListenerType.(*Listener_HybridListener); ok {
			return x.HybridListener
		}
	}
	return nil
}

func (x *Listener) GetAggregateListener() *AggregateListener {
	if x != nil {
		if x, ok := x.ListenerType.(*Listener_AggregateListener); ok {
			return x.AggregateListener
		}
	}
	return nil
}

func (x *Listener) GetSslConfigurations() []*ssl.SslConfig {
	if x != nil {
		return x.SslConfigurations
	}
	return nil
}

// Deprecated: Marked as deprecated in github.com/solo-io/gloo/projects/gloo/api/v1/proxy.proto.
func (x *Listener) GetUseProxyProto() *wrapperspb.BoolValue {
	if x != nil {
		return x.UseProxyProto
	}
	return nil
}

func (x *Listener) GetOptions() *ListenerOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *Listener) GetOpaqueMetadata() isListener_OpaqueMetadata {
	if x != nil {
		return x.OpaqueMetadata
	}
	return nil
}

func (x *Listener) GetMetadata() *structpb.Struct {
	if x != nil {
		if x, ok := x.OpaqueMetadata.(*Listener_Metadata); ok {
			return x.Metadata
		}
	}
	return nil
}

func (x *Listener) GetMetadataStatic() *SourceMetadata {
	if x != nil {
		if x, ok := x.OpaqueMetadata.(*Listener_MetadataStatic); ok {
			return x.MetadataStatic
		}
	}
	return nil
}

func (x *Listener) GetRouteOptions() *RouteConfigurationOptions {
	if x != nil {
		return x.RouteOptions
	}
	return nil
}

type isListener_ListenerType interface {
	isListener_ListenerType()
}

type Listener_HttpListener struct {
	// contains configuration options for Gloo's HTTP-level features including request-based routing
	HttpListener *HttpListener `protobuf:"bytes,4,opt,name=http_listener,json=httpListener,proto3,oneof"`
}

type Listener_TcpListener struct {
	// contains configuration options for Gloo's TCP-level features
	TcpListener *TcpListener `protobuf:"bytes,5,opt,name=tcp_listener,json=tcpListener,proto3,oneof"`
}

type Listener_HybridListener struct {
	// contains any number of configuration options for Gloo's HTTP and/or TCP-level features
	HybridListener *HybridListener `protobuf:"bytes,11,opt,name=hybrid_listener,json=hybridListener,proto3,oneof"`
}

type Listener_AggregateListener struct {
	// contains any number of configuration options for Gloo's HTTP and/or TCP-level features
	// avoids duplicating definitions by separating resources and relationships between resources
	AggregateListener *AggregateListener `protobuf:"bytes,13,opt,name=aggregate_listener,json=aggregateListener,proto3,oneof"`
}

func (*Listener_HttpListener) isListener_ListenerType() {}

func (*Listener_TcpListener) isListener_ListenerType() {}

func (*Listener_HybridListener) isListener_ListenerType() {}

func (*Listener_AggregateListener) isListener_ListenerType() {}

type isListener_OpaqueMetadata interface {
	isListener_OpaqueMetadata()
}

type Listener_Metadata struct {
	// Metadata for the individual route
	// This data is opaque to Gloo, used
	// by controllers to track ownership of routes within a proxy
	// as they are typically generated by a controller (such as the gateway)
	// Deprecated: prefer the any field below
	Metadata *structpb.Struct `protobuf:"bytes,9,opt,name=metadata,proto3,oneof"`
}

type Listener_MetadataStatic struct {
	// Inline metadata used by gloo controller to track ownership.
	// See [uses of static metadata](https://github.com/solo-io/gloo/tree/main/devel/architecture/static_metadata.md) for specific uses
	MetadataStatic *SourceMetadata `protobuf:"bytes,12,opt,name=metadata_static,json=metadataStatic,proto3,oneof"`
}

func (*Listener_Metadata) isListener_OpaqueMetadata() {}

func (*Listener_MetadataStatic) isListener_OpaqueMetadata() {}

type TcpListener struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of filter chains to match on for this listener
	TcpHosts []*TcpHost `protobuf:"bytes,1,rep,name=tcp_hosts,json=tcpHosts,proto3" json:"tcp_hosts,omitempty"`
	// Options contains top-level configuration to be applied to a listener.
	// Listener config is applied to traffic for the given listener.
	// Some configuration here can be overridden in
	// Virtual Host Options configuration or Route Options configuration
	Options *TcpListenerOptions `protobuf:"bytes,8,opt,name=options,proto3" json:"options,omitempty"`
	// prefix for addressing envoy stats for the tcp proxy
	StatPrefix string `protobuf:"bytes,3,opt,name=stat_prefix,json=statPrefix,proto3" json:"stat_prefix,omitempty"`
	// Additional arbitrary network Filters that will be inserted directly into xDS.
	CustomNetworkFilters []*CustomEnvoyFilter `protobuf:"bytes,4,rep,name=custom_network_filters,json=customNetworkFilters,proto3" json:"custom_network_filters,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *TcpListener) Reset() {
	*x = TcpListener{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TcpListener) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TcpListener) ProtoMessage() {}

func (x *TcpListener) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TcpListener.ProtoReflect.Descriptor instead.
func (*TcpListener) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{2}
}

func (x *TcpListener) GetTcpHosts() []*TcpHost {
	if x != nil {
		return x.TcpHosts
	}
	return nil
}

func (x *TcpListener) GetOptions() *TcpListenerOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *TcpListener) GetStatPrefix() string {
	if x != nil {
		return x.StatPrefix
	}
	return ""
}

func (x *TcpListener) GetCustomNetworkFilters() []*CustomEnvoyFilter {
	if x != nil {
		return x.CustomNetworkFilters
	}
	return nil
}

type TcpHost struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// the logical name of the tcp host. names must be unique for each tcp host within a listener
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// If provided, the Gateway will serve TLS/SSL traffic for this set of routes
	SslConfig     *ssl.SslConfig     `protobuf:"bytes,3,opt,name=ssl_config,json=sslConfig,proto3" json:"ssl_config,omitempty"`
	Destination   *TcpHost_TcpAction `protobuf:"bytes,4,opt,name=destination,proto3" json:"destination,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TcpHost) Reset() {
	*x = TcpHost{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TcpHost) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TcpHost) ProtoMessage() {}

func (x *TcpHost) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TcpHost.ProtoReflect.Descriptor instead.
func (*TcpHost) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{3}
}

func (x *TcpHost) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TcpHost) GetSslConfig() *ssl.SslConfig {
	if x != nil {
		return x.SslConfig
	}
	return nil
}

func (x *TcpHost) GetDestination() *TcpHost_TcpAction {
	if x != nil {
		return x.Destination
	}
	return nil
}

// Use this listener to configure proxy behavior for any HTTP-level features including defining routes (via virtual services).
// HttpListeners also contain optional configuration that applies globally across all virtual hosts on the listener.
// Some traffic policies can be configured to work both on the listener and virtual host level (e.g., the rate limit feature)
type HttpListener struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// the set of virtual hosts that will be accessible by clients connecting to this listener.
	// at least one virtual host must be specified for this listener to be active (else connections will be refused)
	// the set of domains for each virtual host must be unique, or the config will be considered invalid
	VirtualHosts []*VirtualHost `protobuf:"bytes,1,rep,name=virtual_hosts,json=virtualHosts,proto3" json:"virtual_hosts,omitempty"`
	// HttpListenerOptions contains optional top-level configuration to be applied to a listener.
	// Listener config is applied to traffic for the given listener.
	// Some configuration here can be overridden in VirtualHostOptions configuration, RouteOptions configuration,
	// or WeightedDestinationOptions configuration.
	Options *HttpListenerOptions `protobuf:"bytes,2,opt,name=options,proto3" json:"options,omitempty"`
	// prefix for addressing envoy stats for the http connection manager
	StatPrefix string `protobuf:"bytes,3,opt,name=stat_prefix,json=statPrefix,proto3" json:"stat_prefix,omitempty"`
	// Additional arbitrary HTTPFilters that will be inserted directly into xDS.
	CustomHttpFilters []*CustomEnvoyFilter `protobuf:"bytes,4,rep,name=custom_http_filters,json=customHttpFilters,proto3" json:"custom_http_filters,omitempty"`
	// Additional arbitrary network Filters that will be inserted directly into xDS.
	CustomNetworkFilters []*CustomEnvoyFilter `protobuf:"bytes,5,rep,name=custom_network_filters,json=customNetworkFilters,proto3" json:"custom_network_filters,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *HttpListener) Reset() {
	*x = HttpListener{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HttpListener) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpListener) ProtoMessage() {}

func (x *HttpListener) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HttpListener.ProtoReflect.Descriptor instead.
func (*HttpListener) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{4}
}

func (x *HttpListener) GetVirtualHosts() []*VirtualHost {
	if x != nil {
		return x.VirtualHosts
	}
	return nil
}

func (x *HttpListener) GetOptions() *HttpListenerOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *HttpListener) GetStatPrefix() string {
	if x != nil {
		return x.StatPrefix
	}
	return ""
}

func (x *HttpListener) GetCustomHttpFilters() []*CustomEnvoyFilter {
	if x != nil {
		return x.CustomHttpFilters
	}
	return nil
}

func (x *HttpListener) GetCustomNetworkFilters() []*CustomEnvoyFilter {
	if x != nil {
		return x.CustomNetworkFilters
	}
	return nil
}

type HybridListener struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	MatchedListeners []*MatchedListener     `protobuf:"bytes,1,rep,name=matched_listeners,json=matchedListeners,proto3" json:"matched_listeners,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *HybridListener) Reset() {
	*x = HybridListener{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HybridListener) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HybridListener) ProtoMessage() {}

func (x *HybridListener) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HybridListener.ProtoReflect.Descriptor instead.
func (*HybridListener) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{5}
}

func (x *HybridListener) GetMatchedListeners() []*MatchedListener {
	if x != nil {
		return x.MatchedListeners
	}
	return nil
}

type MatchedListener struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Matchers are used to define unique matching criteria for each MatchedListener
	// Each MatchedListener within a HybridListener must have a unique Matcher
	// If multiple matchers in a HybridListener are identical, the HybridListener will not be accepted
	// Empty Matchers are effectively catch-alls, and there can be no more than one empty Matcher per HybridListener
	Matcher *Matcher `protobuf:"bytes,1,opt,name=matcher,proto3" json:"matcher,omitempty"`
	// Types that are valid to be assigned to ListenerType:
	//
	//	*MatchedListener_HttpListener
	//	*MatchedListener_TcpListener
	ListenerType isMatchedListener_ListenerType `protobuf_oneof:"ListenerType"`
	// SSL Config is optional for the MatchedListener. If provided, the listener will serve TLS for connections.
	// Multiple SslConfigs are supported for the purpose of SNI. Be aware that the SNI domain provided in the SSL Config.
	// This is set to the aggregated list of SslConfigs that are defined on the selected VirtualServices
	SslConfigurations []*ssl.SslConfig `protobuf:"bytes,4,rep,name=ssl_configurations,json=sslConfigurations,proto3" json:"ssl_configurations,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *MatchedListener) Reset() {
	*x = MatchedListener{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MatchedListener) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MatchedListener) ProtoMessage() {}

func (x *MatchedListener) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MatchedListener.ProtoReflect.Descriptor instead.
func (*MatchedListener) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{6}
}

func (x *MatchedListener) GetMatcher() *Matcher {
	if x != nil {
		return x.Matcher
	}
	return nil
}

func (x *MatchedListener) GetListenerType() isMatchedListener_ListenerType {
	if x != nil {
		return x.ListenerType
	}
	return nil
}

func (x *MatchedListener) GetHttpListener() *HttpListener {
	if x != nil {
		if x, ok := x.ListenerType.(*MatchedListener_HttpListener); ok {
			return x.HttpListener
		}
	}
	return nil
}

func (x *MatchedListener) GetTcpListener() *TcpListener {
	if x != nil {
		if x, ok := x.ListenerType.(*MatchedListener_TcpListener); ok {
			return x.TcpListener
		}
	}
	return nil
}

func (x *MatchedListener) GetSslConfigurations() []*ssl.SslConfig {
	if x != nil {
		return x.SslConfigurations
	}
	return nil
}

type isMatchedListener_ListenerType interface {
	isMatchedListener_ListenerType()
}

type MatchedListener_HttpListener struct {
	HttpListener *HttpListener `protobuf:"bytes,2,opt,name=http_listener,json=httpListener,proto3,oneof"`
}

type MatchedListener_TcpListener struct {
	TcpListener *TcpListener `protobuf:"bytes,3,opt,name=tcp_listener,json=tcpListener,proto3,oneof"`
}

func (*MatchedListener_HttpListener) isMatchedListener_ListenerType() {}

func (*MatchedListener_TcpListener) isMatchedListener_ListenerType() {}

type MatchedTcpListener struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Matchers are used to define unique matching criteria for each MatchedListener
	// These are overridden by tcphost sni mutators
	Matcher *Matcher `protobuf:"bytes,1,opt,name=matcher,proto3" json:"matcher,omitempty"`
	// The actual tcp listener to be used for this matcher in the aggregate listener
	TcpListener   *TcpListener `protobuf:"bytes,2,opt,name=tcp_listener,json=tcpListener,proto3" json:"tcp_listener,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MatchedTcpListener) Reset() {
	*x = MatchedTcpListener{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MatchedTcpListener) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MatchedTcpListener) ProtoMessage() {}

func (x *MatchedTcpListener) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MatchedTcpListener.ProtoReflect.Descriptor instead.
func (*MatchedTcpListener) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{7}
}

func (x *MatchedTcpListener) GetMatcher() *Matcher {
	if x != nil {
		return x.Matcher
	}
	return nil
}

func (x *MatchedTcpListener) GetTcpListener() *TcpListener {
	if x != nil {
		return x.TcpListener
	}
	return nil
}

type Matcher struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Gloo use SNI domains as matching criteria for Gateway selection
	// The other ssl_config properties will be applied to the outputFilterChain's transport socket
	// SslConfig from VirtualServices will be ignored in a MatchedGateway
	SslConfig *ssl.SslConfig `protobuf:"bytes,1,opt,name=ssl_config,json=sslConfig,proto3" json:"ssl_config,omitempty"`
	// Source addresses to match. This value is either the actual addresses used to connect,
	// or addresses that are overridden by using PROXY protocol or original_src.
	SourcePrefixRanges []*v3.CidrRange `protobuf:"bytes,2,rep,name=source_prefix_ranges,json=sourcePrefixRanges,proto3" json:"source_prefix_ranges,omitempty"`
	// Destination addresses to match. This value is either the actual addresses used to connect,
	// or addresses that are overridden by using PROXY protocol or original_dst.
	PrefixRanges []*v3.CidrRange `protobuf:"bytes,4,rep,name=prefix_ranges,json=prefixRanges,proto3" json:"prefix_ranges,omitempty"`
	// Optional destination port to consider in determining a filter chain match.
	// Filter chains that specify the destination port of incoming traffic are the most specific match.
	// If no filter chain specifies the exact destination port,
	// the filter chains which do not specify ports are the most specific match.
	DestinationPort         *wrapperspb.UInt32Value `protobuf:"bytes,5,opt,name=destination_port,json=destinationPort,proto3" json:"destination_port,omitempty"`
	PassthroughCipherSuites []string                `protobuf:"bytes,3,rep,name=passthrough_cipher_suites,json=passthroughCipherSuites,proto3" json:"passthrough_cipher_suites,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *Matcher) Reset() {
	*x = Matcher{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Matcher) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Matcher) ProtoMessage() {}

func (x *Matcher) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Matcher.ProtoReflect.Descriptor instead.
func (*Matcher) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{8}
}

func (x *Matcher) GetSslConfig() *ssl.SslConfig {
	if x != nil {
		return x.SslConfig
	}
	return nil
}

func (x *Matcher) GetSourcePrefixRanges() []*v3.CidrRange {
	if x != nil {
		return x.SourcePrefixRanges
	}
	return nil
}

func (x *Matcher) GetPrefixRanges() []*v3.CidrRange {
	if x != nil {
		return x.PrefixRanges
	}
	return nil
}

func (x *Matcher) GetDestinationPort() *wrapperspb.UInt32Value {
	if x != nil {
		return x.DestinationPort
	}
	return nil
}

func (x *Matcher) GetPassthroughCipherSuites() []string {
	if x != nil {
		return x.PassthroughCipherSuites
	}
	return nil
}

// An AggregateListener defines a set of Gloo configuration which will map to a unique set of FilterChains on a Listener
type AggregateListener struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The aggregate set of resources available on this listener
	HttpResources *AggregateListener_HttpResources `protobuf:"bytes,1,opt,name=http_resources,json=httpResources,proto3" json:"http_resources,omitempty"`
	// The set of HttpFilterChains to create on this listener
	HttpFilterChains []*AggregateListener_HttpFilterChain `protobuf:"bytes,2,rep,name=http_filter_chains,json=httpFilterChains,proto3" json:"http_filter_chains,omitempty"`
	// The set of TcpListeners to create on this listener
	TcpListeners  []*MatchedTcpListener `protobuf:"bytes,3,rep,name=tcp_listeners,json=tcpListeners,proto3" json:"tcp_listeners,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AggregateListener) Reset() {
	*x = AggregateListener{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AggregateListener) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AggregateListener) ProtoMessage() {}

func (x *AggregateListener) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AggregateListener.ProtoReflect.Descriptor instead.
func (*AggregateListener) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{9}
}

func (x *AggregateListener) GetHttpResources() *AggregateListener_HttpResources {
	if x != nil {
		return x.HttpResources
	}
	return nil
}

func (x *AggregateListener) GetHttpFilterChains() []*AggregateListener_HttpFilterChain {
	if x != nil {
		return x.HttpFilterChains
	}
	return nil
}

func (x *AggregateListener) GetTcpListeners() []*MatchedTcpListener {
	if x != nil {
		return x.TcpListeners
	}
	return nil
}

// Virtual Hosts group an ordered list of routes under one or more domains.
// Each Virtual Host has a logical name, which must be unique for the http listener.
// An HTTP request is first matched to a virtual host based on its host header, then to a route within the virtual host.
// If a request is not matched to any virtual host or a route therein, the target proxy will reply with a 404.
type VirtualHost struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// the logical name of the virtual host. names must be unique for each virtual host within a listener
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The list of domains (i.e.: matching the `Host` header of a request) that belong to this virtual host.
	// Note that the wildcard will not match the empty string. e.g. “*-bar.foo.com” will match “baz-bar.foo.com”
	// but not “-bar.foo.com”. Additionally, a special entry “*” is allowed which will match any host/authority header.
	// Only a single virtual host in the entire route configuration can match on “*”. A domain must be unique across all
	// virtual hosts or the config will be invalidated by Gloo
	// Domains on virtual hosts obey the same rules as [Envoy Virtual Hosts](https://github.com/envoyproxy/envoy/blob/main/api/envoy/api/v2/route/route.proto)
	Domains []string `protobuf:"bytes,2,rep,name=domains,proto3" json:"domains,omitempty"`
	// The list of HTTP routes define routing actions to be taken for incoming HTTP requests whose host header matches
	// this virtual host. If the request matches more than one route in the list, the first route matched will be selected.
	// If the list of routes is empty, the virtual host will be ignored by Gloo.
	Routes []*Route `protobuf:"bytes,3,rep,name=routes,proto3" json:"routes,omitempty"`
	// Virtual host options contain additional configuration to be applied to all traffic served by the Virtual Host.
	// Some configuration here can be overridden by Route Options.
	Options *VirtualHostOptions `protobuf:"bytes,4,opt,name=options,proto3" json:"options,omitempty"`
	// Types that are valid to be assigned to OpaqueMetadata:
	//
	//	*VirtualHost_Metadata
	//	*VirtualHost_MetadataStatic
	OpaqueMetadata isVirtualHost_OpaqueMetadata `protobuf_oneof:"opaque_metadata"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *VirtualHost) Reset() {
	*x = VirtualHost{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VirtualHost) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VirtualHost) ProtoMessage() {}

func (x *VirtualHost) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VirtualHost.ProtoReflect.Descriptor instead.
func (*VirtualHost) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{10}
}

func (x *VirtualHost) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *VirtualHost) GetDomains() []string {
	if x != nil {
		return x.Domains
	}
	return nil
}

func (x *VirtualHost) GetRoutes() []*Route {
	if x != nil {
		return x.Routes
	}
	return nil
}

func (x *VirtualHost) GetOptions() *VirtualHostOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *VirtualHost) GetOpaqueMetadata() isVirtualHost_OpaqueMetadata {
	if x != nil {
		return x.OpaqueMetadata
	}
	return nil
}

func (x *VirtualHost) GetMetadata() *structpb.Struct {
	if x != nil {
		if x, ok := x.OpaqueMetadata.(*VirtualHost_Metadata); ok {
			return x.Metadata
		}
	}
	return nil
}

func (x *VirtualHost) GetMetadataStatic() *SourceMetadata {
	if x != nil {
		if x, ok := x.OpaqueMetadata.(*VirtualHost_MetadataStatic); ok {
			return x.MetadataStatic
		}
	}
	return nil
}

type isVirtualHost_OpaqueMetadata interface {
	isVirtualHost_OpaqueMetadata()
}

type VirtualHost_Metadata struct {
	// Metadata for the individual route
	// This data is opaque to Gloo, used
	// by controllers to track ownership of routes within a proxy
	// as they are typically generated by a controller (such as the gateway)
	// Deprecated: prefer the any field below
	Metadata *structpb.Struct `protobuf:"bytes,6,opt,name=metadata,proto3,oneof"`
}

type VirtualHost_MetadataStatic struct {
	// Inline metadata used by gloo controller to track ownership
	MetadataStatic *SourceMetadata `protobuf:"bytes,7,opt,name=metadata_static,json=metadataStatic,proto3,oneof"`
}

func (*VirtualHost_Metadata) isVirtualHost_OpaqueMetadata() {}

func (*VirtualHost_MetadataStatic) isVirtualHost_OpaqueMetadata() {}

// *
// Routes declare the entry points on virtual hosts and the action to take for matched requests.
type Route struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Matchers contain parameters for matching requests (i.e., based on HTTP path, headers, etc.)
	// If empty, the route will match all requests (i.e, a single "/" path prefix matcher)
	Matchers []*matchers.Matcher `protobuf:"bytes,1,rep,name=matchers,proto3" json:"matchers,omitempty"`
	// The Route Action Defines what action the proxy should take when a request matches the route.
	//
	// Types that are valid to be assigned to Action:
	//
	//	*Route_RouteAction
	//	*Route_RedirectAction
	//	*Route_DirectResponseAction
	//	*Route_GraphqlApiRef
	Action isRoute_Action `protobuf_oneof:"action"`
	// Route Options extend the behavior of routes.
	// Route options include configuration such as retries, rate limiting, and request/response transformation.
	Options *RouteOptions `protobuf:"bytes,5,opt,name=options,proto3" json:"options,omitempty"`
	// Types that are valid to be assigned to OpaqueMetadata:
	//
	//	*Route_Metadata
	//	*Route_MetadataStatic
	OpaqueMetadata isRoute_OpaqueMetadata `protobuf_oneof:"opaque_metadata"`
	// The name provides a convenience for users to be able to refer to a route by name.
	// It includes names of vs, route, and route table ancestors of the route.
	Name          string `protobuf:"bytes,7,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Route) Reset() {
	*x = Route{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Route) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Route) ProtoMessage() {}

func (x *Route) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Route.ProtoReflect.Descriptor instead.
func (*Route) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{11}
}

func (x *Route) GetMatchers() []*matchers.Matcher {
	if x != nil {
		return x.Matchers
	}
	return nil
}

func (x *Route) GetAction() isRoute_Action {
	if x != nil {
		return x.Action
	}
	return nil
}

func (x *Route) GetRouteAction() *RouteAction {
	if x != nil {
		if x, ok := x.Action.(*Route_RouteAction); ok {
			return x.RouteAction
		}
	}
	return nil
}

func (x *Route) GetRedirectAction() *RedirectAction {
	if x != nil {
		if x, ok := x.Action.(*Route_RedirectAction); ok {
			return x.RedirectAction
		}
	}
	return nil
}

func (x *Route) GetDirectResponseAction() *DirectResponseAction {
	if x != nil {
		if x, ok := x.Action.(*Route_DirectResponseAction); ok {
			return x.DirectResponseAction
		}
	}
	return nil
}

// Deprecated: Marked as deprecated in github.com/solo-io/gloo/projects/gloo/api/v1/proxy.proto.
func (x *Route) GetGraphqlApiRef() *core.ResourceRef {
	if x != nil {
		if x, ok := x.Action.(*Route_GraphqlApiRef); ok {
			return x.GraphqlApiRef
		}
	}
	return nil
}

func (x *Route) GetOptions() *RouteOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *Route) GetOpaqueMetadata() isRoute_OpaqueMetadata {
	if x != nil {
		return x.OpaqueMetadata
	}
	return nil
}

func (x *Route) GetMetadata() *structpb.Struct {
	if x != nil {
		if x, ok := x.OpaqueMetadata.(*Route_Metadata); ok {
			return x.Metadata
		}
	}
	return nil
}

func (x *Route) GetMetadataStatic() *SourceMetadata {
	if x != nil {
		if x, ok := x.OpaqueMetadata.(*Route_MetadataStatic); ok {
			return x.MetadataStatic
		}
	}
	return nil
}

func (x *Route) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type isRoute_Action interface {
	isRoute_Action()
}

type Route_RouteAction struct {
	// This action is the primary action to be selected for most routes. The RouteAction tells the proxy to
	// route requests to an upstream.
	RouteAction *RouteAction `protobuf:"bytes,2,opt,name=route_action,json=routeAction,proto3,oneof"`
}

type Route_RedirectAction struct {
	// Redirect actions tell the proxy to return a redirect response to the downstream client
	RedirectAction *RedirectAction `protobuf:"bytes,3,opt,name=redirect_action,json=redirectAction,proto3,oneof"`
}

type Route_DirectResponseAction struct {
	// Return an arbitrary HTTP response directly, without proxying.
	DirectResponseAction *DirectResponseAction `protobuf:"bytes,4,opt,name=direct_response_action,json=directResponseAction,proto3,oneof"`
}

type Route_GraphqlApiRef struct {
	// Deprecated, Enterprise-Only: This feature is deprecated and will be removed in a future release. APIs are versioned as alpha and subject to change.
	// A reference to a GraphQLApi CR. Resolution of the client request to upstream(s) will be delegated to
	// the resolution policies defined in the GraphQLApi CR. If configured, the graphql filter will operate
	// instead of the envoy router filter, so configuration (such as retries) that applies to the router filter
	// will not be applied.
	//
	// Deprecated: Marked as deprecated in github.com/solo-io/gloo/projects/gloo/api/v1/proxy.proto.
	GraphqlApiRef *core.ResourceRef `protobuf:"bytes,8,opt,name=graphql_api_ref,json=graphqlApiRef,proto3,oneof"`
}

func (*Route_RouteAction) isRoute_Action() {}

func (*Route_RedirectAction) isRoute_Action() {}

func (*Route_DirectResponseAction) isRoute_Action() {}

func (*Route_GraphqlApiRef) isRoute_Action() {}

type isRoute_OpaqueMetadata interface {
	isRoute_OpaqueMetadata()
}

type Route_Metadata struct {
	// Metadata for the individual route
	// This data is opaque to Gloo, used
	// by controllers to track ownership of routes within a proxy
	// as they are typically generated by a controller (such as the gateway)
	// Deprecated: prefer the any field below
	Metadata *structpb.Struct `protobuf:"bytes,6,opt,name=metadata,proto3,oneof"`
}

type Route_MetadataStatic struct {
	// Inline metadata used by gloo controller to track ownership
	MetadataStatic *SourceMetadata `protobuf:"bytes,9,opt,name=metadata_static,json=metadataStatic,proto3,oneof"`
}

func (*Route_Metadata) isRoute_OpaqueMetadata() {}

func (*Route_MetadataStatic) isRoute_OpaqueMetadata() {}

// RouteActions are used to route matched requests to upstreams.
type RouteAction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Defines the destination upstream for routing
	// Some destinations require additional configuration for the route (e.g. AWS upstreams require a function name
	// to be specified).
	//
	// Types that are valid to be assigned to Destination:
	//
	//	*RouteAction_Single
	//	*RouteAction_Multi
	//	*RouteAction_UpstreamGroup
	//	*RouteAction_ClusterHeader
	//	*RouteAction_DynamicForwardProxy
	Destination   isRouteAction_Destination `protobuf_oneof:"destination"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RouteAction) Reset() {
	*x = RouteAction{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RouteAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteAction) ProtoMessage() {}

func (x *RouteAction) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteAction.ProtoReflect.Descriptor instead.
func (*RouteAction) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{12}
}

func (x *RouteAction) GetDestination() isRouteAction_Destination {
	if x != nil {
		return x.Destination
	}
	return nil
}

func (x *RouteAction) GetSingle() *Destination {
	if x != nil {
		if x, ok := x.Destination.(*RouteAction_Single); ok {
			return x.Single
		}
	}
	return nil
}

func (x *RouteAction) GetMulti() *MultiDestination {
	if x != nil {
		if x, ok := x.Destination.(*RouteAction_Multi); ok {
			return x.Multi
		}
	}
	return nil
}

func (x *RouteAction) GetUpstreamGroup() *core.ResourceRef {
	if x != nil {
		if x, ok := x.Destination.(*RouteAction_UpstreamGroup); ok {
			return x.UpstreamGroup
		}
	}
	return nil
}

func (x *RouteAction) GetClusterHeader() string {
	if x != nil {
		if x, ok := x.Destination.(*RouteAction_ClusterHeader); ok {
			return x.ClusterHeader
		}
	}
	return ""
}

func (x *RouteAction) GetDynamicForwardProxy() *dynamic_forward_proxy.PerRouteConfig {
	if x != nil {
		if x, ok := x.Destination.(*RouteAction_DynamicForwardProxy); ok {
			return x.DynamicForwardProxy
		}
	}
	return nil
}

type isRouteAction_Destination interface {
	isRouteAction_Destination()
}

type RouteAction_Single struct {
	// Use SingleDestination to route to a single upstream
	Single *Destination `protobuf:"bytes,1,opt,name=single,proto3,oneof"`
}

type RouteAction_Multi struct {
	// Use MultiDestination to load balance requests between multiple upstreams (by weight)
	Multi *MultiDestination `protobuf:"bytes,2,opt,name=multi,proto3,oneof"`
}

type RouteAction_UpstreamGroup struct {
	// Use a reference to an upstream group for routing.
	UpstreamGroup *core.ResourceRef `protobuf:"bytes,3,opt,name=upstream_group,json=upstreamGroup,proto3,oneof"`
}

type RouteAction_ClusterHeader struct {
	// Envoy will determine the cluster to route to by reading the value of the HTTP header named by cluster_header from the request headers.
	// If the header is not found or the referenced cluster does not exist, Envoy will return a 404 response.
	// Avoid using this whenever possible, it does not allow for custom filter configuration based on Virtual Host.
	ClusterHeader string `protobuf:"bytes,4,opt,name=cluster_header,json=clusterHeader,proto3,oneof"`
}

type RouteAction_DynamicForwardProxy struct {
	// Route requests to a custom dynamic forward proxy envoy cluster.
	// Envoy will route based on the DNS response (cached) or pause requests
	// (for a configurable amount of time on the listener) until DNS has resolved for
	// the host header rewrite as provided here.
	// For more, see https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/http/http_proxy
	DynamicForwardProxy *dynamic_forward_proxy.PerRouteConfig `protobuf:"bytes,5,opt,name=dynamic_forward_proxy,json=dynamicForwardProxy,proto3,oneof"`
}

func (*RouteAction_Single) isRouteAction_Destination() {}

func (*RouteAction_Multi) isRouteAction_Destination() {}

func (*RouteAction_UpstreamGroup) isRouteAction_Destination() {}

func (*RouteAction_ClusterHeader) isRouteAction_Destination() {}

func (*RouteAction_DynamicForwardProxy) isRouteAction_Destination() {}

// Destinations define routable destinations for proxied requests.
type Destination struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	//	The type of the destination
	//
	// Types that are valid to be assigned to DestinationType:
	//
	//	*Destination_Upstream
	//	*Destination_Kube
	//	*Destination_Consul
	DestinationType isDestination_DestinationType `protobuf_oneof:"destination_type"`
	// Some upstreams utilize options which require or permit additional configuration on routes targeting them.
	// gRPC upstreams, for example, allow specifying REST-style parameters for JSON-to-gRPC transcoding in the
	// destination config. If the destination config is required for the upstream and not provided by the user,
	// Gloo will invalidate the destination and its parent resources.
	DestinationSpec *DestinationSpec `protobuf:"bytes,2,opt,name=destination_spec,json=destinationSpec,proto3" json:"destination_spec,omitempty"`
	// If specified, traffic will only be routed to a subset of the upstream. If upstream doesn't
	// contain the specified subset, we will fallback to normal upstream routing.
	Subset        *Subset `protobuf:"bytes,3,opt,name=subset,proto3" json:"subset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Destination) Reset() {
	*x = Destination{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Destination) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Destination) ProtoMessage() {}

func (x *Destination) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Destination.ProtoReflect.Descriptor instead.
func (*Destination) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{13}
}

func (x *Destination) GetDestinationType() isDestination_DestinationType {
	if x != nil {
		return x.DestinationType
	}
	return nil
}

func (x *Destination) GetUpstream() *core.ResourceRef {
	if x != nil {
		if x, ok := x.DestinationType.(*Destination_Upstream); ok {
			return x.Upstream
		}
	}
	return nil
}

func (x *Destination) GetKube() *KubernetesServiceDestination {
	if x != nil {
		if x, ok := x.DestinationType.(*Destination_Kube); ok {
			return x.Kube
		}
	}
	return nil
}

func (x *Destination) GetConsul() *ConsulServiceDestination {
	if x != nil {
		if x, ok := x.DestinationType.(*Destination_Consul); ok {
			return x.Consul
		}
	}
	return nil
}

func (x *Destination) GetDestinationSpec() *DestinationSpec {
	if x != nil {
		return x.DestinationSpec
	}
	return nil
}

func (x *Destination) GetSubset() *Subset {
	if x != nil {
		return x.Subset
	}
	return nil
}

type isDestination_DestinationType interface {
	isDestination_DestinationType()
}

type Destination_Upstream struct {
	// Route requests to a Gloo upstream
	Upstream *core.ResourceRef `protobuf:"bytes,10,opt,name=upstream,proto3,oneof"`
}

type Destination_Kube struct {
	// Route requests to a kubernetes service
	Kube *KubernetesServiceDestination `protobuf:"bytes,11,opt,name=kube,proto3,oneof"`
}

type Destination_Consul struct {
	// Route requests to a consul service
	Consul *ConsulServiceDestination `protobuf:"bytes,12,opt,name=consul,proto3,oneof"`
}

func (*Destination_Upstream) isDestination_DestinationType() {}

func (*Destination_Kube) isDestination_DestinationType() {}

func (*Destination_Consul) isDestination_DestinationType() {}

// Identifies a port on a kubernetes service to route traffic to.
type KubernetesServiceDestination struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The target service
	Ref *core.ResourceRef `protobuf:"bytes,1,opt,name=ref,proto3" json:"ref,omitempty"`
	// The port attribute of the service
	Port          uint32 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesServiceDestination) Reset() {
	*x = KubernetesServiceDestination{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesServiceDestination) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesServiceDestination) ProtoMessage() {}

func (x *KubernetesServiceDestination) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesServiceDestination.ProtoReflect.Descriptor instead.
func (*KubernetesServiceDestination) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{14}
}

func (x *KubernetesServiceDestination) GetRef() *core.ResourceRef {
	if x != nil {
		return x.Ref
	}
	return nil
}

func (x *KubernetesServiceDestination) GetPort() uint32 {
	if x != nil {
		return x.Port
	}
	return 0
}

// Identifies a [Consul](https://www.consul.io/) [service](https://www.consul.io/docs/agent/services.html) to route traffic to.
// Multiple Consul services with the same name can present distinct sets of tags, listen of different ports, and live in
// multiple data centers (see an example [here](https://www.consul.io/docs/agent/services.html#multiple-service-definitions)).
// You can target the desired subset of services via the fields in this configuration. Gloo will detect the correspondent
// IP addresses and ports and load balance traffic between them.
type ConsulServiceDestination struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the target service. This field is required.
	ServiceName string `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	// If provided, load balance traffic only between services matching all the given tags.
	Tags []string `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`
	// If provided, load balance traffic only between services running in the given
	// [data centers](https://www.consul.io/docs/internals/architecture.html).
	DataCenters   []string `protobuf:"bytes,3,rep,name=data_centers,json=dataCenters,proto3" json:"data_centers,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConsulServiceDestination) Reset() {
	*x = ConsulServiceDestination{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConsulServiceDestination) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConsulServiceDestination) ProtoMessage() {}

func (x *ConsulServiceDestination) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConsulServiceDestination.ProtoReflect.Descriptor instead.
func (*ConsulServiceDestination) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{15}
}

func (x *ConsulServiceDestination) GetServiceName() string {
	if x != nil {
		return x.ServiceName
	}
	return ""
}

func (x *ConsulServiceDestination) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

func (x *ConsulServiceDestination) GetDataCenters() []string {
	if x != nil {
		return x.DataCenters
	}
	return nil
}

type UpstreamGroup struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The destinations that are part of this upstream group.
	Destinations []*WeightedDestination `protobuf:"bytes,1,rep,name=destinations,proto3" json:"destinations,omitempty"`
	// NamespacedStatuses indicates the validation status of this resource.
	// NamespacedStatuses is read-only by clients, and set by gloo during validation
	NamespacedStatuses *core.NamespacedStatuses `protobuf:"bytes,8,opt,name=namespaced_statuses,json=namespacedStatuses,proto3" json:"namespaced_statuses,omitempty"`
	// Metadata contains the object metadata for this resource
	Metadata      *core.Metadata `protobuf:"bytes,7,opt,name=metadata,proto3" json:"metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpstreamGroup) Reset() {
	*x = UpstreamGroup{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpstreamGroup) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpstreamGroup) ProtoMessage() {}

func (x *UpstreamGroup) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpstreamGroup.ProtoReflect.Descriptor instead.
func (*UpstreamGroup) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{16}
}

func (x *UpstreamGroup) GetDestinations() []*WeightedDestination {
	if x != nil {
		return x.Destinations
	}
	return nil
}

func (x *UpstreamGroup) GetNamespacedStatuses() *core.NamespacedStatuses {
	if x != nil {
		return x.NamespacedStatuses
	}
	return nil
}

func (x *UpstreamGroup) GetMetadata() *core.Metadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// MultiDestination is a container for a set of weighted destinations. Gloo will load balance traffic for a single
// route across multiple destinations according to their specified weights.
type MultiDestination struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This list must contain at least one destination with a weight greater than 0.
	// Otherwise, the listener for this route becomes invalid, which causes an error for the parent proxy resource.
	Destinations  []*WeightedDestination `protobuf:"bytes,1,rep,name=destinations,proto3" json:"destinations,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultiDestination) Reset() {
	*x = MultiDestination{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultiDestination) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultiDestination) ProtoMessage() {}

func (x *MultiDestination) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultiDestination.ProtoReflect.Descriptor instead.
func (*MultiDestination) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{17}
}

func (x *MultiDestination) GetDestinations() []*WeightedDestination {
	if x != nil {
		return x.Destinations
	}
	return nil
}

// WeightedDestination attaches a weight to a single destination.
type WeightedDestination struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	Destination *Destination           `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	// Weight must be zero or greater -if no weight is passed it will default to 0 -
	// Routing to each destination is balanced according to the ratio of the destination’s weight to the total
	// weight on a route. For example, if the weight for one destination is 2, and the total weight of all
	// destinations on the route is 6, the destination receives 2/6 of the traffic. Note that a weight of 0
	// routes no traffic to the destination.
	Weight *wrapperspb.UInt32Value `protobuf:"bytes,2,opt,name=weight,proto3" json:"weight,omitempty"`
	// Apply configuration to traffic that is sent to this weighted destination
	Options       *WeightedDestinationOptions `protobuf:"bytes,3,opt,name=options,proto3" json:"options,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WeightedDestination) Reset() {
	*x = WeightedDestination{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WeightedDestination) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WeightedDestination) ProtoMessage() {}

func (x *WeightedDestination) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WeightedDestination.ProtoReflect.Descriptor instead.
func (*WeightedDestination) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{18}
}

func (x *WeightedDestination) GetDestination() *Destination {
	if x != nil {
		return x.Destination
	}
	return nil
}

func (x *WeightedDestination) GetWeight() *wrapperspb.UInt32Value {
	if x != nil {
		return x.Weight
	}
	return nil
}

func (x *WeightedDestination) GetOptions() *WeightedDestinationOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// Notice: RedirectAction is copied directly from https://github.com/envoyproxy/envoy/blob/main/api/envoy/api/v2/route/route.proto
type RedirectAction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The host portion of the URL will be swapped with this value.
	HostRedirect string `protobuf:"bytes,1,opt,name=host_redirect,json=hostRedirect,proto3" json:"host_redirect,omitempty"`
	// Types that are valid to be assigned to PathRewriteSpecifier:
	//
	//	*RedirectAction_PathRedirect
	//	*RedirectAction_PrefixRewrite
	//	*RedirectAction_RegexRewrite
	PathRewriteSpecifier isRedirectAction_PathRewriteSpecifier `protobuf_oneof:"path_rewrite_specifier"`
	// The HTTP status code to use in the redirect response. The default response
	// code is MOVED_PERMANENTLY (301).
	ResponseCode RedirectAction_RedirectResponseCode `protobuf:"varint,3,opt,name=response_code,json=responseCode,proto3,enum=gloo.solo.io.RedirectAction_RedirectResponseCode" json:"response_code,omitempty"`
	// The scheme portion of the URL will be swapped with "https".
	HttpsRedirect bool `protobuf:"varint,4,opt,name=https_redirect,json=httpsRedirect,proto3" json:"https_redirect,omitempty"`
	// Indicates that during redirection, the query portion of the URL will
	// be removed. Default value is false.
	StripQuery bool `protobuf:"varint,6,opt,name=strip_query,json=stripQuery,proto3" json:"strip_query,omitempty"`
	// Which port to redirect to if different than original.
	PortRedirect  *wrapperspb.UInt32Value `protobuf:"bytes,7,opt,name=port_redirect,json=portRedirect,proto3" json:"port_redirect,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RedirectAction) Reset() {
	*x = RedirectAction{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RedirectAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RedirectAction) ProtoMessage() {}

func (x *RedirectAction) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RedirectAction.ProtoReflect.Descriptor instead.
func (*RedirectAction) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{19}
}

func (x *RedirectAction) GetHostRedirect() string {
	if x != nil {
		return x.HostRedirect
	}
	return ""
}

func (x *RedirectAction) GetPathRewriteSpecifier() isRedirectAction_PathRewriteSpecifier {
	if x != nil {
		return x.PathRewriteSpecifier
	}
	return nil
}

func (x *RedirectAction) GetPathRedirect() string {
	if x != nil {
		if x, ok := x.PathRewriteSpecifier.(*RedirectAction_PathRedirect); ok {
			return x.PathRedirect
		}
	}
	return ""
}

func (x *RedirectAction) GetPrefixRewrite() string {
	if x != nil {
		if x, ok := x.PathRewriteSpecifier.(*RedirectAction_PrefixRewrite); ok {
			return x.PrefixRewrite
		}
	}
	return ""
}

func (x *RedirectAction) GetRegexRewrite() *v31.RegexMatchAndSubstitute {
	if x != nil {
		if x, ok := x.PathRewriteSpecifier.(*RedirectAction_RegexRewrite); ok {
			return x.RegexRewrite
		}
	}
	return nil
}

func (x *RedirectAction) GetResponseCode() RedirectAction_RedirectResponseCode {
	if x != nil {
		return x.ResponseCode
	}
	return RedirectAction_MOVED_PERMANENTLY
}

func (x *RedirectAction) GetHttpsRedirect() bool {
	if x != nil {
		return x.HttpsRedirect
	}
	return false
}

func (x *RedirectAction) GetStripQuery() bool {
	if x != nil {
		return x.StripQuery
	}
	return false
}

func (x *RedirectAction) GetPortRedirect() *wrapperspb.UInt32Value {
	if x != nil {
		return x.PortRedirect
	}
	return nil
}

type isRedirectAction_PathRewriteSpecifier interface {
	isRedirectAction_PathRewriteSpecifier()
}

type RedirectAction_PathRedirect struct {
	// The path portion of the URL will be swapped with this value.
	PathRedirect string `protobuf:"bytes,2,opt,name=path_redirect,json=pathRedirect,proto3,oneof"`
}

type RedirectAction_PrefixRewrite struct {
	// Indicates that during redirection, the matched prefix (or path)
	// should be swapped with this value. This option allows redirect URLs be dynamically created
	// based on the request.
	//
	//	Pay attention to the use of trailing slashes as mentioned in
	//	`RouteAction`'s `prefix_rewrite`.
	PrefixRewrite string `protobuf:"bytes,5,opt,name=prefix_rewrite,json=prefixRewrite,proto3,oneof"`
}

type RedirectAction_RegexRewrite struct {
	// Indicates that during forwarding, portions of the path that match the
	// pattern should be rewritten, even allowing the substitution of capture
	// groups from the pattern into the new path as specified by the rewrite
	// substitution string. This is useful to allow application paths to be
	// rewritten in a way that is aware of segments with variable content like
	// identifiers. The router filter will place the original path as it was
	// before the rewrite into the :ref:`x-envoy-original-path
	// <config_http_filters_router_x-envoy-original-path>` header.
	//
	// Only one of :ref:`prefix_rewrite <envoy_api_field_config.route.v3.RouteAction.prefix_rewrite>`
	// or *regex_rewrite* may be specified.
	//
	// Examples using Google's [RE2](https://github.com/google/re2) engine:
	//
	//   - The path pattern `^/service/([^/]+)(/.*)$` paired with a substitution
	//     string of `\2/instance/\1` would transform `/service/foo/v1/api`
	//     into `/v1/api/instance/foo`.
	//
	//   - The pattern `one` paired with a substitution string of `two` would
	//     transform `/xxx/one/yyy/one/zzz` into `/xxx/two/yyy/two/zzz`.
	//
	//   - The pattern `^(.*?)one(.*)$` paired with a substitution string of
	//     `\1two\2` would replace only the first occurrence of `one`,
	//     transforming path `/xxx/one/yyy/one/zzz` into `/xxx/two/yyy/one/zzz`.
	//
	//   - The pattern `(?i)/xxx/` paired with a substitution string of `/yyy/`
	//     would do a case-insensitive match and transform path `/aaa/XxX/bbb` to
	//     `/aaa/yyy/bbb`.
	RegexRewrite *v31.RegexMatchAndSubstitute `protobuf:"bytes,32,opt,name=regex_rewrite,json=regexRewrite,proto3,oneof"`
}

func (*RedirectAction_PathRedirect) isRedirectAction_PathRewriteSpecifier() {}

func (*RedirectAction_PrefixRewrite) isRedirectAction_PathRewriteSpecifier() {}

func (*RedirectAction_RegexRewrite) isRedirectAction_PathRewriteSpecifier() {}

// DirectResponseAction is copied directly from https://github.com/envoyproxy/envoy/blob/main/api/envoy/api/v2/route/route.proto
type DirectResponseAction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Specifies the HTTP response status to be returned.
	Status uint32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	// Specifies the content of the response body. If this setting is omitted,
	// no body is included in the generated response.
	//
	//	Note: Headers can be specified using the Header Modification feature in the enclosing
	//	Route, Virtual Host, or Listener options.
	Body          string `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DirectResponseAction) Reset() {
	*x = DirectResponseAction{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DirectResponseAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DirectResponseAction) ProtoMessage() {}

func (x *DirectResponseAction) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DirectResponseAction.ProtoReflect.Descriptor instead.
func (*DirectResponseAction) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{20}
}

func (x *DirectResponseAction) GetStatus() uint32 {
	if x != nil {
		return x.Status
	}
	return 0
}

func (x *DirectResponseAction) GetBody() string {
	if x != nil {
		return x.Body
	}
	return ""
}

// SourceMetadata is an internal message used to track ownership of nested proxy objects:
// - Listener
// - VirtualHost
// - Route
type SourceMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A list of sources
	Sources       []*SourceMetadata_SourceRef `protobuf:"bytes,1,rep,name=sources,proto3" json:"sources,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SourceMetadata) Reset() {
	*x = SourceMetadata{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SourceMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SourceMetadata) ProtoMessage() {}

func (x *SourceMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SourceMetadata.ProtoReflect.Descriptor instead.
func (*SourceMetadata) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{21}
}

func (x *SourceMetadata) GetSources() []*SourceMetadata_SourceRef {
	if x != nil {
		return x.Sources
	}
	return nil
}

// CustomEnvoyFilter contains an arbitrary filter.
// These may be HTTPFilters or NetworkFilters, depending on the context they're used.
type CustomEnvoyFilter struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Determines filter ordering.
	FilterStage *filters.FilterStage `protobuf:"bytes,1,opt,name=filter_stage,json=filterStage,proto3" json:"filter_stage,omitempty"`
	// The name of the filter configuration.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Filter specific configuration.
	Config        *anypb.Any `protobuf:"bytes,3,opt,name=config,proto3" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CustomEnvoyFilter) Reset() {
	*x = CustomEnvoyFilter{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CustomEnvoyFilter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CustomEnvoyFilter) ProtoMessage() {}

func (x *CustomEnvoyFilter) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CustomEnvoyFilter.ProtoReflect.Descriptor instead.
func (*CustomEnvoyFilter) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{22}
}

func (x *CustomEnvoyFilter) GetFilterStage() *filters.FilterStage {
	if x != nil {
		return x.FilterStage
	}
	return nil
}

func (x *CustomEnvoyFilter) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CustomEnvoyFilter) GetConfig() *anypb.Any {
	if x != nil {
		return x.Config
	}
	return nil
}

// Name of the destinations the gateway can route to.
// Note: the destination spec and subsets are not supported in this context and will be ignored.
type TcpHost_TcpAction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Destination:
	//
	//	*TcpHost_TcpAction_Single
	//	*TcpHost_TcpAction_Multi
	//	*TcpHost_TcpAction_UpstreamGroup
	//	*TcpHost_TcpAction_ForwardSniClusterName
	Destination   isTcpHost_TcpAction_Destination `protobuf_oneof:"destination"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TcpHost_TcpAction) Reset() {
	*x = TcpHost_TcpAction{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TcpHost_TcpAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TcpHost_TcpAction) ProtoMessage() {}

func (x *TcpHost_TcpAction) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TcpHost_TcpAction.ProtoReflect.Descriptor instead.
func (*TcpHost_TcpAction) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{3, 0}
}

func (x *TcpHost_TcpAction) GetDestination() isTcpHost_TcpAction_Destination {
	if x != nil {
		return x.Destination
	}
	return nil
}

func (x *TcpHost_TcpAction) GetSingle() *Destination {
	if x != nil {
		if x, ok := x.Destination.(*TcpHost_TcpAction_Single); ok {
			return x.Single
		}
	}
	return nil
}

func (x *TcpHost_TcpAction) GetMulti() *MultiDestination {
	if x != nil {
		if x, ok := x.Destination.(*TcpHost_TcpAction_Multi); ok {
			return x.Multi
		}
	}
	return nil
}

func (x *TcpHost_TcpAction) GetUpstreamGroup() *core.ResourceRef {
	if x != nil {
		if x, ok := x.Destination.(*TcpHost_TcpAction_UpstreamGroup); ok {
			return x.UpstreamGroup
		}
	}
	return nil
}

func (x *TcpHost_TcpAction) GetForwardSniClusterName() *emptypb.Empty {
	if x != nil {
		if x, ok := x.Destination.(*TcpHost_TcpAction_ForwardSniClusterName); ok {
			return x.ForwardSniClusterName
		}
	}
	return nil
}

type isTcpHost_TcpAction_Destination interface {
	isTcpHost_TcpAction_Destination()
}

type TcpHost_TcpAction_Single struct {
	// Use SingleDestination to route to a single upstream
	Single *Destination `protobuf:"bytes,1,opt,name=single,proto3,oneof"`
}

type TcpHost_TcpAction_Multi struct {
	// Use MultiDestination to load balance requests between multiple upstreams (by weight)
	Multi *MultiDestination `protobuf:"bytes,2,opt,name=multi,proto3,oneof"`
}

type TcpHost_TcpAction_UpstreamGroup struct {
	// Use a reference to an upstream group for routing.
	UpstreamGroup *core.ResourceRef `protobuf:"bytes,3,opt,name=upstream_group,json=upstreamGroup,proto3,oneof"`
}

type TcpHost_TcpAction_ForwardSniClusterName struct {
	// Forwards the request to a cluster name matching the TLS SNI name
	// https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/filter/network/sni_cluster/empty/sni_cluster
	// Note: This filter will only work properly with TLS connections in which the upstream SNI domain is specified
	ForwardSniClusterName *emptypb.Empty `protobuf:"bytes,4,opt,name=forward_sni_cluster_name,json=forwardSniClusterName,proto3,oneof"`
}

func (*TcpHost_TcpAction_Single) isTcpHost_TcpAction_Destination() {}

func (*TcpHost_TcpAction_Multi) isTcpHost_TcpAction_Destination() {}

func (*TcpHost_TcpAction_UpstreamGroup) isTcpHost_TcpAction_Destination() {}

func (*TcpHost_TcpAction_ForwardSniClusterName) isTcpHost_TcpAction_Destination() {}

type AggregateListener_HttpResources struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Set of VirtualHosts available on this Listener, indexed by name
	VirtualHosts map[string]*VirtualHost `protobuf:"bytes,1,rep,name=virtual_hosts,json=virtualHosts,proto3" json:"virtual_hosts,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Set of HttpListenerOptions available on this Listener, indexed by hash
	HttpOptions   map[string]*HttpListenerOptions `protobuf:"bytes,2,rep,name=http_options,json=httpOptions,proto3" json:"http_options,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AggregateListener_HttpResources) Reset() {
	*x = AggregateListener_HttpResources{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AggregateListener_HttpResources) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AggregateListener_HttpResources) ProtoMessage() {}

func (x *AggregateListener_HttpResources) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AggregateListener_HttpResources.ProtoReflect.Descriptor instead.
func (*AggregateListener_HttpResources) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{9, 0}
}

func (x *AggregateListener_HttpResources) GetVirtualHosts() map[string]*VirtualHost {
	if x != nil {
		return x.VirtualHosts
	}
	return nil
}

func (x *AggregateListener_HttpResources) GetHttpOptions() map[string]*HttpListenerOptions {
	if x != nil {
		return x.HttpOptions
	}
	return nil
}

type AggregateListener_HttpFilterChain struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Matching criteria used to generate both the FilterChainMatch and TransportSocket for the Envoy FilterChain
	Matcher *Matcher `protobuf:"bytes,1,opt,name=matcher,proto3" json:"matcher,omitempty"`
	// The ref pointing to HttpListenerOptions which are used to configure the HCM on this HttpFilterChain
	// Corresponds to an entry in the HttpResources.HttpOptions map
	HttpOptionsRef string `protobuf:"bytes,2,opt,name=http_options_ref,json=httpOptionsRef,proto3" json:"http_options_ref,omitempty"`
	// The set of refs pointing to VirtualHosts which are available on this HttpFilterChain
	// Each ref corresponds to an entry in the HttpResources.VirtualHosts map
	VirtualHostRefs []string `protobuf:"bytes,3,rep,name=virtual_host_refs,json=virtualHostRefs,proto3" json:"virtual_host_refs,omitempty"`
	// Additional arbitrary HTTPFilters that will be inserted directly into xDS.
	CustomHttpFilters []*CustomEnvoyFilter `protobuf:"bytes,37,rep,name=custom_http_filters,json=customHttpFilters,proto3" json:"custom_http_filters,omitempty"`
	// Additional arbitrary network Filters that will be inserted directly into xDS.
	CustomNetworkFilters []*CustomEnvoyFilter `protobuf:"bytes,38,rep,name=custom_network_filters,json=customNetworkFilters,proto3" json:"custom_network_filters,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *AggregateListener_HttpFilterChain) Reset() {
	*x = AggregateListener_HttpFilterChain{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AggregateListener_HttpFilterChain) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AggregateListener_HttpFilterChain) ProtoMessage() {}

func (x *AggregateListener_HttpFilterChain) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AggregateListener_HttpFilterChain.ProtoReflect.Descriptor instead.
func (*AggregateListener_HttpFilterChain) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{9, 1}
}

func (x *AggregateListener_HttpFilterChain) GetMatcher() *Matcher {
	if x != nil {
		return x.Matcher
	}
	return nil
}

func (x *AggregateListener_HttpFilterChain) GetHttpOptionsRef() string {
	if x != nil {
		return x.HttpOptionsRef
	}
	return ""
}

func (x *AggregateListener_HttpFilterChain) GetVirtualHostRefs() []string {
	if x != nil {
		return x.VirtualHostRefs
	}
	return nil
}

func (x *AggregateListener_HttpFilterChain) GetCustomHttpFilters() []*CustomEnvoyFilter {
	if x != nil {
		return x.CustomHttpFilters
	}
	return nil
}

func (x *AggregateListener_HttpFilterChain) GetCustomNetworkFilters() []*CustomEnvoyFilter {
	if x != nil {
		return x.CustomNetworkFilters
	}
	return nil
}

type SourceMetadata_SourceRef struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The resource being referenced
	ResourceRef *core.ResourceRef `protobuf:"bytes,1,opt,name=resource_ref,json=resourceRef,proto3" json:"resource_ref,omitempty"`
	// The resource Kind
	ResourceKind string `protobuf:"bytes,2,opt,name=resource_kind,json=resourceKind,proto3" json:"resource_kind,omitempty"`
	// The observed generation of the resource
	ObservedGeneration int64 `protobuf:"varint,3,opt,name=observed_generation,json=observedGeneration,proto3" json:"observed_generation,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *SourceMetadata_SourceRef) Reset() {
	*x = SourceMetadata_SourceRef{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SourceMetadata_SourceRef) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SourceMetadata_SourceRef) ProtoMessage() {}

func (x *SourceMetadata_SourceRef) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SourceMetadata_SourceRef.ProtoReflect.Descriptor instead.
func (*SourceMetadata_SourceRef) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP(), []int{21, 0}
}

func (x *SourceMetadata_SourceRef) GetResourceRef() *core.ResourceRef {
	if x != nil {
		return x.ResourceRef
	}
	return nil
}

func (x *SourceMetadata_SourceRef) GetResourceKind() string {
	if x != nil {
		return x.ResourceKind
	}
	return ""
}

func (x *SourceMetadata_SourceRef) GetObservedGeneration() int64 {
	if x != nil {
		return x.ObservedGeneration
	}
	return 0
}

var File_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto protoreflect.FileDescriptor

const file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDesc = "" +
	"\n" +
	"8github.com/solo-io/gloo/projects/gloo/api/v1/proxy.proto\x12\fgloo.solo.io\x1a\x1egoogle/protobuf/wrappers.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a\x1cgoogle/protobuf/struct.proto\x1a\x19google/protobuf/any.proto\x1a\x12extproto/ext.proto\x1a1github.com/solo-io/solo-kit/api/v1/metadata.proto\x1a/github.com/solo-io/solo-kit/api/v1/status.proto\x1a,github.com/solo-io/solo-kit/api/v1/ref.proto\x1a1github.com/solo-io/solo-kit/api/v1/solo-kit.proto\x1aCgithub.com/solo-io/gloo/projects/gloo/api/v1/listener_options.proto\x1aHgithub.com/solo-io/gloo/projects/gloo/api/v1/http_listener_options.proto\x1aGgithub.com/solo-io/gloo/projects/gloo/api/v1/tcp_listener_options.proto\x1aGgithub.com/solo-io/gloo/projects/gloo/api/v1/virtual_host_options.proto\x1a@github.com/solo-io/gloo/projects/gloo/api/v1/route_options.proto\x1aNgithub.com/solo-io/gloo/projects/gloo/api/v1/route_configuration_options.proto\x1aOgithub.com/solo-io/gloo/projects/gloo/api/v1/weighted_destination_options.proto\x1a:github.com/solo-io/gloo/projects/gloo/api/v1/ssl/ssl.proto\x1a9github.com/solo-io/gloo/projects/gloo/api/v1/subset.proto\x1aCgithub.com/solo-io/gloo/projects/gloo/api/v1/destination_spec.proto\x1aAgithub.com/solo-io/gloo/projects/gloo/api/v1/filters/stages.proto\x1aIgithub.com/solo-io/gloo/projects/gloo/api/v1/core/matchers/matchers.proto\x1aUgithub.com/solo-io/gloo/projects/gloo/api/external/envoy/config/core/v3/address.proto\x1afgithub.com/solo-io/gloo/projects/gloo/api/v1/options/dynamic_forward_proxy/dynamic_forward_proxy.proto\x1aTgithub.com/solo-io/gloo/projects/gloo/api/external/envoy/type/matcher/v3/regex.proto\"\x8b\x02\n" +
	"\x05Proxy\x12&\n" +
	"\x0ecompressedSpec\x18\x03 \x01(\tR\x0ecompressedSpec\x124\n" +
	"\tlisteners\x18\x02 \x03(\v2\x16.gloo.solo.io.ListenerR\tlisteners\x12W\n" +
	"\x13namespaced_statuses\x18\b \x01(\v2 .core.solo.io.NamespacedStatusesB\x04\xb8\xf5\x04\x01R\x12namespacedStatuses\x122\n" +
	"\bmetadata\x18\a \x01(\v2\x16.core.solo.io.MetadataR\bmetadata:\x11\x82\xf1\x04\r\n" +
	"\x02px\x12\aproxiesJ\x04\b\x06\x10\a\"\xc2\x06\n" +
	"\bListener\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12!\n" +
	"\fbind_address\x18\x02 \x01(\tR\vbindAddress\x12\x1b\n" +
	"\tbind_port\x18\x03 \x01(\rR\bbindPort\x12A\n" +
	"\rhttp_listener\x18\x04 \x01(\v2\x1a.gloo.solo.io.HttpListenerH\x00R\fhttpListener\x12>\n" +
	"\ftcp_listener\x18\x05 \x01(\v2\x19.gloo.solo.io.TcpListenerH\x00R\vtcpListener\x12G\n" +
	"\x0fhybrid_listener\x18\v \x01(\v2\x1c.gloo.solo.io.HybridListenerH\x00R\x0ehybridListener\x12P\n" +
	"\x12aggregate_listener\x18\r \x01(\v2\x1f.gloo.solo.io.AggregateListenerH\x00R\x11aggregateListener\x12F\n" +
	"\x12ssl_configurations\x18\x06 \x03(\v2\x17.gloo.solo.io.SslConfigR\x11sslConfigurations\x12F\n" +
	"\x0fuse_proxy_proto\x18\a \x01(\v2\x1a.google.protobuf.BoolValueB\x02\x18\x01R\ruseProxyProto\x127\n" +
	"\aoptions\x18\b \x01(\v2\x1d.gloo.solo.io.ListenerOptionsR\aoptions\x12;\n" +
	"\bmetadata\x18\t \x01(\v2\x17.google.protobuf.StructB\x04\xb8\xf5\x04\x01H\x01R\bmetadata\x12M\n" +
	"\x0fmetadata_static\x18\f \x01(\v2\x1c.gloo.solo.io.SourceMetadataB\x04\xb8\xf5\x04\x01H\x01R\x0emetadataStatic\x12L\n" +
	"\rroute_options\x18\n" +
	" \x01(\v2'.gloo.solo.io.RouteConfigurationOptionsR\frouteOptionsB\x0e\n" +
	"\fListenerTypeB\x11\n" +
	"\x0fopaque_metadata\"\xf5\x01\n" +
	"\vTcpListener\x122\n" +
	"\ttcp_hosts\x18\x01 \x03(\v2\x15.gloo.solo.io.TcpHostR\btcpHosts\x12:\n" +
	"\aoptions\x18\b \x01(\v2 .gloo.solo.io.TcpListenerOptionsR\aoptions\x12\x1f\n" +
	"\vstat_prefix\x18\x03 \x01(\tR\n" +
	"statPrefix\x12U\n" +
	"\x16custom_network_filters\x18\x04 \x03(\v2\x1f.gloo.solo.io.CustomEnvoyFilterR\x14customNetworkFilters\"\xbf\x03\n" +
	"\aTcpHost\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x126\n" +
	"\n" +
	"ssl_config\x18\x03 \x01(\v2\x17.gloo.solo.io.SslConfigR\tsslConfig\x12A\n" +
	"\vdestination\x18\x04 \x01(\v2\x1f.gloo.solo.io.TcpHost.TcpActionR\vdestination\x1a\x9e\x02\n" +
	"\tTcpAction\x123\n" +
	"\x06single\x18\x01 \x01(\v2\x19.gloo.solo.io.DestinationH\x00R\x06single\x126\n" +
	"\x05multi\x18\x02 \x01(\v2\x1e.gloo.solo.io.MultiDestinationH\x00R\x05multi\x12B\n" +
	"\x0eupstream_group\x18\x03 \x01(\v2\x19.core.solo.io.ResourceRefH\x00R\rupstreamGroup\x12Q\n" +
	"\x18forward_sni_cluster_name\x18\x04 \x01(\v2\x16.google.protobuf.EmptyH\x00R\x15forwardSniClusterNameB\r\n" +
	"\vdestinationJ\x04\b\x02\x10\x03\"\xd4\x02\n" +
	"\fHttpListener\x12>\n" +
	"\rvirtual_hosts\x18\x01 \x03(\v2\x19.gloo.solo.io.VirtualHostR\fvirtualHosts\x12;\n" +
	"\aoptions\x18\x02 \x01(\v2!.gloo.solo.io.HttpListenerOptionsR\aoptions\x12\x1f\n" +
	"\vstat_prefix\x18\x03 \x01(\tR\n" +
	"statPrefix\x12O\n" +
	"\x13custom_http_filters\x18\x04 \x03(\v2\x1f.gloo.solo.io.CustomEnvoyFilterR\x11customHttpFilters\x12U\n" +
	"\x16custom_network_filters\x18\x05 \x03(\v2\x1f.gloo.solo.io.CustomEnvoyFilterR\x14customNetworkFilters\"\\\n" +
	"\x0eHybridListener\x12J\n" +
	"\x11matched_listeners\x18\x01 \x03(\v2\x1d.gloo.solo.io.MatchedListenerR\x10matchedListeners\"\x9d\x02\n" +
	"\x0fMatchedListener\x12/\n" +
	"\amatcher\x18\x01 \x01(\v2\x15.gloo.solo.io.MatcherR\amatcher\x12A\n" +
	"\rhttp_listener\x18\x02 \x01(\v2\x1a.gloo.solo.io.HttpListenerH\x00R\fhttpListener\x12>\n" +
	"\ftcp_listener\x18\x03 \x01(\v2\x19.gloo.solo.io.TcpListenerH\x00R\vtcpListener\x12F\n" +
	"\x12ssl_configurations\x18\x04 \x03(\v2\x17.gloo.solo.io.SslConfigR\x11sslConfigurationsB\x0e\n" +
	"\fListenerType\"\x83\x01\n" +
	"\x12MatchedTcpListener\x12/\n" +
	"\amatcher\x18\x01 \x01(\v2\x15.gloo.solo.io.MatcherR\amatcher\x12<\n" +
	"\ftcp_listener\x18\x02 \x01(\v2\x19.gloo.solo.io.TcpListenerR\vtcpListener\"\xef\x02\n" +
	"\aMatcher\x126\n" +
	"\n" +
	"ssl_config\x18\x01 \x01(\v2\x17.gloo.solo.io.SslConfigR\tsslConfig\x12Y\n" +
	"\x14source_prefix_ranges\x18\x02 \x03(\v2'.solo.io.envoy.config.core.v3.CidrRangeR\x12sourcePrefixRanges\x12L\n" +
	"\rprefix_ranges\x18\x04 \x03(\v2'.solo.io.envoy.config.core.v3.CidrRangeR\fprefixRanges\x12G\n" +
	"\x10destination_port\x18\x05 \x01(\v2\x1c.google.protobuf.UInt32ValueR\x0fdestinationPort\x12:\n" +
	"\x19passthrough_cipher_suites\x18\x03 \x03(\tR\x17passthroughCipherSuites\"\xec\a\n" +
	"\x11AggregateListener\x12T\n" +
	"\x0ehttp_resources\x18\x01 \x01(\v2-.gloo.solo.io.AggregateListener.HttpResourcesR\rhttpResources\x12]\n" +
	"\x12http_filter_chains\x18\x02 \x03(\v2/.gloo.solo.io.AggregateListener.HttpFilterChainR\x10httpFilterChains\x12E\n" +
	"\rtcp_listeners\x18\x03 \x03(\v2 .gloo.solo.io.MatchedTcpListenerR\ftcpListeners\x1a\x97\x03\n" +
	"\rHttpResources\x12d\n" +
	"\rvirtual_hosts\x18\x01 \x03(\v2?.gloo.solo.io.AggregateListener.HttpResources.VirtualHostsEntryR\fvirtualHosts\x12a\n" +
	"\fhttp_options\x18\x02 \x03(\v2>.gloo.solo.io.AggregateListener.HttpResources.HttpOptionsEntryR\vhttpOptions\x1aZ\n" +
	"\x11VirtualHostsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12/\n" +
	"\x05value\x18\x02 \x01(\v2\x19.gloo.solo.io.VirtualHostR\x05value:\x028\x01\x1aa\n" +
	"\x10HttpOptionsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x127\n" +
	"\x05value\x18\x02 \x01(\v2!.gloo.solo.io.HttpListenerOptionsR\x05value:\x028\x01\x1a\xc0\x02\n" +
	"\x0fHttpFilterChain\x12/\n" +
	"\amatcher\x18\x01 \x01(\v2\x15.gloo.solo.io.MatcherR\amatcher\x12(\n" +
	"\x10http_options_ref\x18\x02 \x01(\tR\x0ehttpOptionsRef\x12*\n" +
	"\x11virtual_host_refs\x18\x03 \x03(\tR\x0fvirtualHostRefs\x12O\n" +
	"\x13custom_http_filters\x18% \x03(\v2\x1f.gloo.solo.io.CustomEnvoyFilterR\x11customHttpFilters\x12U\n" +
	"\x16custom_network_filters\x18& \x03(\v2\x1f.gloo.solo.io.CustomEnvoyFilterR\x14customNetworkFilters\"\xc3\x02\n" +
	"\vVirtualHost\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x18\n" +
	"\adomains\x18\x02 \x03(\tR\adomains\x12+\n" +
	"\x06routes\x18\x03 \x03(\v2\x13.gloo.solo.io.RouteR\x06routes\x12:\n" +
	"\aoptions\x18\x04 \x01(\v2 .gloo.solo.io.VirtualHostOptionsR\aoptions\x12;\n" +
	"\bmetadata\x18\x06 \x01(\v2\x17.google.protobuf.StructB\x04\xb8\xf5\x04\x01H\x00R\bmetadata\x12M\n" +
	"\x0fmetadata_static\x18\a \x01(\v2\x1c.gloo.solo.io.SourceMetadataB\x04\xb8\xf5\x04\x01H\x00R\x0emetadataStaticB\x11\n" +
	"\x0fopaque_metadata\"\xe9\x04\n" +
	"\x05Route\x12?\n" +
	"\bmatchers\x18\x01 \x03(\v2#.matchers.core.gloo.solo.io.MatcherR\bmatchers\x12>\n" +
	"\froute_action\x18\x02 \x01(\v2\x19.gloo.solo.io.RouteActionH\x00R\vrouteAction\x12G\n" +
	"\x0fredirect_action\x18\x03 \x01(\v2\x1c.gloo.solo.io.RedirectActionH\x00R\x0eredirectAction\x12Z\n" +
	"\x16direct_response_action\x18\x04 \x01(\v2\".gloo.solo.io.DirectResponseActionH\x00R\x14directResponseAction\x12G\n" +
	"\x0fgraphql_api_ref\x18\b \x01(\v2\x19.core.solo.io.ResourceRefB\x02\x18\x01H\x00R\rgraphqlApiRef\x124\n" +
	"\aoptions\x18\x05 \x01(\v2\x1a.gloo.solo.io.RouteOptionsR\aoptions\x12;\n" +
	"\bmetadata\x18\x06 \x01(\v2\x17.google.protobuf.StructB\x04\xb8\xf5\x04\x01H\x01R\bmetadata\x12M\n" +
	"\x0fmetadata_static\x18\t \x01(\v2\x1c.gloo.solo.io.SourceMetadataB\x04\xb8\xf5\x04\x01H\x01R\x0emetadataStatic\x12\x12\n" +
	"\x04name\x18\a \x01(\tR\x04nameB\b\n" +
	"\x06actionB\x11\n" +
	"\x0fopaque_metadata\"\xd6\x02\n" +
	"\vRouteAction\x123\n" +
	"\x06single\x18\x01 \x01(\v2\x19.gloo.solo.io.DestinationH\x00R\x06single\x126\n" +
	"\x05multi\x18\x02 \x01(\v2\x1e.gloo.solo.io.MultiDestinationH\x00R\x05multi\x12B\n" +
	"\x0eupstream_group\x18\x03 \x01(\v2\x19.core.solo.io.ResourceRefH\x00R\rupstreamGroup\x12'\n" +
	"\x0ecluster_header\x18\x04 \x01(\tH\x00R\rclusterHeader\x12^\n" +
	"\x15dynamic_forward_proxy\x18\x05 \x01(\v2(.dfp.options.gloo.solo.io.PerRouteConfigH\x00R\x13dynamicForwardProxyB\r\n" +
	"\vdestination\"\xd6\x02\n" +
	"\vDestination\x127\n" +
	"\bupstream\x18\n" +
	" \x01(\v2\x19.core.solo.io.ResourceRefH\x00R\bupstream\x12@\n" +
	"\x04kube\x18\v \x01(\v2*.gloo.solo.io.KubernetesServiceDestinationH\x00R\x04kube\x12@\n" +
	"\x06consul\x18\f \x01(\v2&.gloo.solo.io.ConsulServiceDestinationH\x00R\x06consul\x12H\n" +
	"\x10destination_spec\x18\x02 \x01(\v2\x1d.gloo.solo.io.DestinationSpecR\x0fdestinationSpec\x12,\n" +
	"\x06subset\x18\x03 \x01(\v2\x14.gloo.solo.io.SubsetR\x06subsetB\x12\n" +
	"\x10destination_type\"_\n" +
	"\x1cKubernetesServiceDestination\x12+\n" +
	"\x03ref\x18\x01 \x01(\v2\x19.core.solo.io.ResourceRefR\x03ref\x12\x12\n" +
	"\x04port\x18\x02 \x01(\rR\x04port\"t\n" +
	"\x18ConsulServiceDestination\x12!\n" +
	"\fservice_name\x18\x01 \x01(\tR\vserviceName\x12\x12\n" +
	"\x04tags\x18\x02 \x03(\tR\x04tags\x12!\n" +
	"\fdata_centers\x18\x03 \x03(\tR\vdataCenters\"\x84\x02\n" +
	"\rUpstreamGroup\x12E\n" +
	"\fdestinations\x18\x01 \x03(\v2!.gloo.solo.io.WeightedDestinationR\fdestinations\x12W\n" +
	"\x13namespaced_statuses\x18\b \x01(\v2 .core.solo.io.NamespacedStatusesB\x04\xb8\xf5\x04\x01R\x12namespacedStatuses\x122\n" +
	"\bmetadata\x18\a \x01(\v2\x16.core.solo.io.MetadataR\bmetadata:\x19\x82\xf1\x04\x15\n" +
	"\x02ug\x12\x0fupstream_groupsJ\x04\b\x06\x10\a\"Y\n" +
	"\x10MultiDestination\x12E\n" +
	"\fdestinations\x18\x01 \x03(\v2!.gloo.solo.io.WeightedDestinationR\fdestinations\"\xcc\x01\n" +
	"\x13WeightedDestination\x12;\n" +
	"\vdestination\x18\x01 \x01(\v2\x19.gloo.solo.io.DestinationR\vdestination\x124\n" +
	"\x06weight\x18\x02 \x01(\v2\x1c.google.protobuf.UInt32ValueR\x06weight\x12B\n" +
	"\aoptions\x18\x03 \x01(\v2(.gloo.solo.io.WeightedDestinationOptionsR\aoptions\"\xda\x04\n" +
	"\x0eRedirectAction\x12#\n" +
	"\rhost_redirect\x18\x01 \x01(\tR\fhostRedirect\x12%\n" +
	"\rpath_redirect\x18\x02 \x01(\tH\x00R\fpathRedirect\x12'\n" +
	"\x0eprefix_rewrite\x18\x05 \x01(\tH\x00R\rprefixRewrite\x12]\n" +
	"\rregex_rewrite\x18  \x01(\v26.solo.io.envoy.type.matcher.v3.RegexMatchAndSubstituteH\x00R\fregexRewrite\x12V\n" +
	"\rresponse_code\x18\x03 \x01(\x0e21.gloo.solo.io.RedirectAction.RedirectResponseCodeR\fresponseCode\x12%\n" +
	"\x0ehttps_redirect\x18\x04 \x01(\bR\rhttpsRedirect\x12\x1f\n" +
	"\vstrip_query\x18\x06 \x01(\bR\n" +
	"stripQuery\x12A\n" +
	"\rport_redirect\x18\a \x01(\v2\x1c.google.protobuf.UInt32ValueR\fportRedirect\"w\n" +
	"\x14RedirectResponseCode\x12\x15\n" +
	"\x11MOVED_PERMANENTLY\x10\x00\x12\t\n" +
	"\x05FOUND\x10\x01\x12\r\n" +
	"\tSEE_OTHER\x10\x02\x12\x16\n" +
	"\x12TEMPORARY_REDIRECT\x10\x03\x12\x16\n" +
	"\x12PERMANENT_REDIRECT\x10\x04B\x18\n" +
	"\x16path_rewrite_specifier\"B\n" +
	"\x14DirectResponseAction\x12\x16\n" +
	"\x06status\x18\x01 \x01(\rR\x06status\x12\x12\n" +
	"\x04body\x18\x02 \x01(\tR\x04body\"\xf4\x01\n" +
	"\x0eSourceMetadata\x12@\n" +
	"\asources\x18\x01 \x03(\v2&.gloo.solo.io.SourceMetadata.SourceRefR\asources\x1a\x9f\x01\n" +
	"\tSourceRef\x12<\n" +
	"\fresource_ref\x18\x01 \x01(\v2\x19.core.solo.io.ResourceRefR\vresourceRef\x12#\n" +
	"\rresource_kind\x18\x02 \x01(\tR\fresourceKind\x12/\n" +
	"\x13observed_generation\x18\x03 \x01(\x03R\x12observedGeneration\"\x9b\x01\n" +
	"\x11CustomEnvoyFilter\x12D\n" +
	"\ffilter_stage\x18\x01 \x01(\v2!.filters.gloo.solo.io.FilterStageR\vfilterStage\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12,\n" +
	"\x06config\x18\x03 \x01(\v2\x14.google.protobuf.AnyR\x06configB>\xb8\xf5\x04\x01\xc0\xf5\x04\x01\xd0\xf5\x04\x01Z0github.com/solo-io/gloo/projects/gloo/pkg/api/v1b\x06proto3"

var (
	file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescOnce sync.Once
	file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescData []byte
)

func file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescGZIP() []byte {
	file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescOnce.Do(func() {
		file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDesc), len(file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDesc)))
	})
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDescData
}

var file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes = make([]protoimpl.MessageInfo, 29)
var file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_goTypes = []any{
	(RedirectAction_RedirectResponseCode)(0),  // 0: gloo.solo.io.RedirectAction.RedirectResponseCode
	(*Proxy)(nil),                             // 1: gloo.solo.io.Proxy
	(*Listener)(nil),                          // 2: gloo.solo.io.Listener
	(*TcpListener)(nil),                       // 3: gloo.solo.io.TcpListener
	(*TcpHost)(nil),                           // 4: gloo.solo.io.TcpHost
	(*HttpListener)(nil),                      // 5: gloo.solo.io.HttpListener
	(*HybridListener)(nil),                    // 6: gloo.solo.io.HybridListener
	(*MatchedListener)(nil),                   // 7: gloo.solo.io.MatchedListener
	(*MatchedTcpListener)(nil),                // 8: gloo.solo.io.MatchedTcpListener
	(*Matcher)(nil),                           // 9: gloo.solo.io.Matcher
	(*AggregateListener)(nil),                 // 10: gloo.solo.io.AggregateListener
	(*VirtualHost)(nil),                       // 11: gloo.solo.io.VirtualHost
	(*Route)(nil),                             // 12: gloo.solo.io.Route
	(*RouteAction)(nil),                       // 13: gloo.solo.io.RouteAction
	(*Destination)(nil),                       // 14: gloo.solo.io.Destination
	(*KubernetesServiceDestination)(nil),      // 15: gloo.solo.io.KubernetesServiceDestination
	(*ConsulServiceDestination)(nil),          // 16: gloo.solo.io.ConsulServiceDestination
	(*UpstreamGroup)(nil),                     // 17: gloo.solo.io.UpstreamGroup
	(*MultiDestination)(nil),                  // 18: gloo.solo.io.MultiDestination
	(*WeightedDestination)(nil),               // 19: gloo.solo.io.WeightedDestination
	(*RedirectAction)(nil),                    // 20: gloo.solo.io.RedirectAction
	(*DirectResponseAction)(nil),              // 21: gloo.solo.io.DirectResponseAction
	(*SourceMetadata)(nil),                    // 22: gloo.solo.io.SourceMetadata
	(*CustomEnvoyFilter)(nil),                 // 23: gloo.solo.io.CustomEnvoyFilter
	(*TcpHost_TcpAction)(nil),                 // 24: gloo.solo.io.TcpHost.TcpAction
	(*AggregateListener_HttpResources)(nil),   // 25: gloo.solo.io.AggregateListener.HttpResources
	(*AggregateListener_HttpFilterChain)(nil), // 26: gloo.solo.io.AggregateListener.HttpFilterChain
	nil,                                          // 27: gloo.solo.io.AggregateListener.HttpResources.VirtualHostsEntry
	nil,                                          // 28: gloo.solo.io.AggregateListener.HttpResources.HttpOptionsEntry
	(*SourceMetadata_SourceRef)(nil),             // 29: gloo.solo.io.SourceMetadata.SourceRef
	(*core.NamespacedStatuses)(nil),              // 30: core.solo.io.NamespacedStatuses
	(*core.Metadata)(nil),                        // 31: core.solo.io.Metadata
	(*ssl.SslConfig)(nil),                        // 32: gloo.solo.io.SslConfig
	(*wrapperspb.BoolValue)(nil),                 // 33: google.protobuf.BoolValue
	(*ListenerOptions)(nil),                      // 34: gloo.solo.io.ListenerOptions
	(*structpb.Struct)(nil),                      // 35: google.protobuf.Struct
	(*RouteConfigurationOptions)(nil),            // 36: gloo.solo.io.RouteConfigurationOptions
	(*TcpListenerOptions)(nil),                   // 37: gloo.solo.io.TcpListenerOptions
	(*HttpListenerOptions)(nil),                  // 38: gloo.solo.io.HttpListenerOptions
	(*v3.CidrRange)(nil),                         // 39: solo.io.envoy.config.core.v3.CidrRange
	(*wrapperspb.UInt32Value)(nil),               // 40: google.protobuf.UInt32Value
	(*VirtualHostOptions)(nil),                   // 41: gloo.solo.io.VirtualHostOptions
	(*matchers.Matcher)(nil),                     // 42: matchers.core.gloo.solo.io.Matcher
	(*core.ResourceRef)(nil),                     // 43: core.solo.io.ResourceRef
	(*RouteOptions)(nil),                         // 44: gloo.solo.io.RouteOptions
	(*dynamic_forward_proxy.PerRouteConfig)(nil), // 45: dfp.options.gloo.solo.io.PerRouteConfig
	(*DestinationSpec)(nil),                      // 46: gloo.solo.io.DestinationSpec
	(*Subset)(nil),                               // 47: gloo.solo.io.Subset
	(*WeightedDestinationOptions)(nil),           // 48: gloo.solo.io.WeightedDestinationOptions
	(*v31.RegexMatchAndSubstitute)(nil),          // 49: solo.io.envoy.type.matcher.v3.RegexMatchAndSubstitute
	(*filters.FilterStage)(nil),                  // 50: filters.gloo.solo.io.FilterStage
	(*anypb.Any)(nil),                            // 51: google.protobuf.Any
	(*emptypb.Empty)(nil),                        // 52: google.protobuf.Empty
}
var file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_depIdxs = []int32{
	2,  // 0: gloo.solo.io.Proxy.listeners:type_name -> gloo.solo.io.Listener
	30, // 1: gloo.solo.io.Proxy.namespaced_statuses:type_name -> core.solo.io.NamespacedStatuses
	31, // 2: gloo.solo.io.Proxy.metadata:type_name -> core.solo.io.Metadata
	5,  // 3: gloo.solo.io.Listener.http_listener:type_name -> gloo.solo.io.HttpListener
	3,  // 4: gloo.solo.io.Listener.tcp_listener:type_name -> gloo.solo.io.TcpListener
	6,  // 5: gloo.solo.io.Listener.hybrid_listener:type_name -> gloo.solo.io.HybridListener
	10, // 6: gloo.solo.io.Listener.aggregate_listener:type_name -> gloo.solo.io.AggregateListener
	32, // 7: gloo.solo.io.Listener.ssl_configurations:type_name -> gloo.solo.io.SslConfig
	33, // 8: gloo.solo.io.Listener.use_proxy_proto:type_name -> google.protobuf.BoolValue
	34, // 9: gloo.solo.io.Listener.options:type_name -> gloo.solo.io.ListenerOptions
	35, // 10: gloo.solo.io.Listener.metadata:type_name -> google.protobuf.Struct
	22, // 11: gloo.solo.io.Listener.metadata_static:type_name -> gloo.solo.io.SourceMetadata
	36, // 12: gloo.solo.io.Listener.route_options:type_name -> gloo.solo.io.RouteConfigurationOptions
	4,  // 13: gloo.solo.io.TcpListener.tcp_hosts:type_name -> gloo.solo.io.TcpHost
	37, // 14: gloo.solo.io.TcpListener.options:type_name -> gloo.solo.io.TcpListenerOptions
	23, // 15: gloo.solo.io.TcpListener.custom_network_filters:type_name -> gloo.solo.io.CustomEnvoyFilter
	32, // 16: gloo.solo.io.TcpHost.ssl_config:type_name -> gloo.solo.io.SslConfig
	24, // 17: gloo.solo.io.TcpHost.destination:type_name -> gloo.solo.io.TcpHost.TcpAction
	11, // 18: gloo.solo.io.HttpListener.virtual_hosts:type_name -> gloo.solo.io.VirtualHost
	38, // 19: gloo.solo.io.HttpListener.options:type_name -> gloo.solo.io.HttpListenerOptions
	23, // 20: gloo.solo.io.HttpListener.custom_http_filters:type_name -> gloo.solo.io.CustomEnvoyFilter
	23, // 21: gloo.solo.io.HttpListener.custom_network_filters:type_name -> gloo.solo.io.CustomEnvoyFilter
	7,  // 22: gloo.solo.io.HybridListener.matched_listeners:type_name -> gloo.solo.io.MatchedListener
	9,  // 23: gloo.solo.io.MatchedListener.matcher:type_name -> gloo.solo.io.Matcher
	5,  // 24: gloo.solo.io.MatchedListener.http_listener:type_name -> gloo.solo.io.HttpListener
	3,  // 25: gloo.solo.io.MatchedListener.tcp_listener:type_name -> gloo.solo.io.TcpListener
	32, // 26: gloo.solo.io.MatchedListener.ssl_configurations:type_name -> gloo.solo.io.SslConfig
	9,  // 27: gloo.solo.io.MatchedTcpListener.matcher:type_name -> gloo.solo.io.Matcher
	3,  // 28: gloo.solo.io.MatchedTcpListener.tcp_listener:type_name -> gloo.solo.io.TcpListener
	32, // 29: gloo.solo.io.Matcher.ssl_config:type_name -> gloo.solo.io.SslConfig
	39, // 30: gloo.solo.io.Matcher.source_prefix_ranges:type_name -> solo.io.envoy.config.core.v3.CidrRange
	39, // 31: gloo.solo.io.Matcher.prefix_ranges:type_name -> solo.io.envoy.config.core.v3.CidrRange
	40, // 32: gloo.solo.io.Matcher.destination_port:type_name -> google.protobuf.UInt32Value
	25, // 33: gloo.solo.io.AggregateListener.http_resources:type_name -> gloo.solo.io.AggregateListener.HttpResources
	26, // 34: gloo.solo.io.AggregateListener.http_filter_chains:type_name -> gloo.solo.io.AggregateListener.HttpFilterChain
	8,  // 35: gloo.solo.io.AggregateListener.tcp_listeners:type_name -> gloo.solo.io.MatchedTcpListener
	12, // 36: gloo.solo.io.VirtualHost.routes:type_name -> gloo.solo.io.Route
	41, // 37: gloo.solo.io.VirtualHost.options:type_name -> gloo.solo.io.VirtualHostOptions
	35, // 38: gloo.solo.io.VirtualHost.metadata:type_name -> google.protobuf.Struct
	22, // 39: gloo.solo.io.VirtualHost.metadata_static:type_name -> gloo.solo.io.SourceMetadata
	42, // 40: gloo.solo.io.Route.matchers:type_name -> matchers.core.gloo.solo.io.Matcher
	13, // 41: gloo.solo.io.Route.route_action:type_name -> gloo.solo.io.RouteAction
	20, // 42: gloo.solo.io.Route.redirect_action:type_name -> gloo.solo.io.RedirectAction
	21, // 43: gloo.solo.io.Route.direct_response_action:type_name -> gloo.solo.io.DirectResponseAction
	43, // 44: gloo.solo.io.Route.graphql_api_ref:type_name -> core.solo.io.ResourceRef
	44, // 45: gloo.solo.io.Route.options:type_name -> gloo.solo.io.RouteOptions
	35, // 46: gloo.solo.io.Route.metadata:type_name -> google.protobuf.Struct
	22, // 47: gloo.solo.io.Route.metadata_static:type_name -> gloo.solo.io.SourceMetadata
	14, // 48: gloo.solo.io.RouteAction.single:type_name -> gloo.solo.io.Destination
	18, // 49: gloo.solo.io.RouteAction.multi:type_name -> gloo.solo.io.MultiDestination
	43, // 50: gloo.solo.io.RouteAction.upstream_group:type_name -> core.solo.io.ResourceRef
	45, // 51: gloo.solo.io.RouteAction.dynamic_forward_proxy:type_name -> dfp.options.gloo.solo.io.PerRouteConfig
	43, // 52: gloo.solo.io.Destination.upstream:type_name -> core.solo.io.ResourceRef
	15, // 53: gloo.solo.io.Destination.kube:type_name -> gloo.solo.io.KubernetesServiceDestination
	16, // 54: gloo.solo.io.Destination.consul:type_name -> gloo.solo.io.ConsulServiceDestination
	46, // 55: gloo.solo.io.Destination.destination_spec:type_name -> gloo.solo.io.DestinationSpec
	47, // 56: gloo.solo.io.Destination.subset:type_name -> gloo.solo.io.Subset
	43, // 57: gloo.solo.io.KubernetesServiceDestination.ref:type_name -> core.solo.io.ResourceRef
	19, // 58: gloo.solo.io.UpstreamGroup.destinations:type_name -> gloo.solo.io.WeightedDestination
	30, // 59: gloo.solo.io.UpstreamGroup.namespaced_statuses:type_name -> core.solo.io.NamespacedStatuses
	31, // 60: gloo.solo.io.UpstreamGroup.metadata:type_name -> core.solo.io.Metadata
	19, // 61: gloo.solo.io.MultiDestination.destinations:type_name -> gloo.solo.io.WeightedDestination
	14, // 62: gloo.solo.io.WeightedDestination.destination:type_name -> gloo.solo.io.Destination
	40, // 63: gloo.solo.io.WeightedDestination.weight:type_name -> google.protobuf.UInt32Value
	48, // 64: gloo.solo.io.WeightedDestination.options:type_name -> gloo.solo.io.WeightedDestinationOptions
	49, // 65: gloo.solo.io.RedirectAction.regex_rewrite:type_name -> solo.io.envoy.type.matcher.v3.RegexMatchAndSubstitute
	0,  // 66: gloo.solo.io.RedirectAction.response_code:type_name -> gloo.solo.io.RedirectAction.RedirectResponseCode
	40, // 67: gloo.solo.io.RedirectAction.port_redirect:type_name -> google.protobuf.UInt32Value
	29, // 68: gloo.solo.io.SourceMetadata.sources:type_name -> gloo.solo.io.SourceMetadata.SourceRef
	50, // 69: gloo.solo.io.CustomEnvoyFilter.filter_stage:type_name -> filters.gloo.solo.io.FilterStage
	51, // 70: gloo.solo.io.CustomEnvoyFilter.config:type_name -> google.protobuf.Any
	14, // 71: gloo.solo.io.TcpHost.TcpAction.single:type_name -> gloo.solo.io.Destination
	18, // 72: gloo.solo.io.TcpHost.TcpAction.multi:type_name -> gloo.solo.io.MultiDestination
	43, // 73: gloo.solo.io.TcpHost.TcpAction.upstream_group:type_name -> core.solo.io.ResourceRef
	52, // 74: gloo.solo.io.TcpHost.TcpAction.forward_sni_cluster_name:type_name -> google.protobuf.Empty
	27, // 75: gloo.solo.io.AggregateListener.HttpResources.virtual_hosts:type_name -> gloo.solo.io.AggregateListener.HttpResources.VirtualHostsEntry
	28, // 76: gloo.solo.io.AggregateListener.HttpResources.http_options:type_name -> gloo.solo.io.AggregateListener.HttpResources.HttpOptionsEntry
	9,  // 77: gloo.solo.io.AggregateListener.HttpFilterChain.matcher:type_name -> gloo.solo.io.Matcher
	23, // 78: gloo.solo.io.AggregateListener.HttpFilterChain.custom_http_filters:type_name -> gloo.solo.io.CustomEnvoyFilter
	23, // 79: gloo.solo.io.AggregateListener.HttpFilterChain.custom_network_filters:type_name -> gloo.solo.io.CustomEnvoyFilter
	11, // 80: gloo.solo.io.AggregateListener.HttpResources.VirtualHostsEntry.value:type_name -> gloo.solo.io.VirtualHost
	38, // 81: gloo.solo.io.AggregateListener.HttpResources.HttpOptionsEntry.value:type_name -> gloo.solo.io.HttpListenerOptions
	43, // 82: gloo.solo.io.SourceMetadata.SourceRef.resource_ref:type_name -> core.solo.io.ResourceRef
	83, // [83:83] is the sub-list for method output_type
	83, // [83:83] is the sub-list for method input_type
	83, // [83:83] is the sub-list for extension type_name
	83, // [83:83] is the sub-list for extension extendee
	0,  // [0:83] is the sub-list for field type_name
}

func init() { file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_init() }
func file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_init() {
	if File_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto != nil {
		return
	}
	file_github_com_solo_io_gloo_projects_gloo_api_v1_listener_options_proto_init()
	file_github_com_solo_io_gloo_projects_gloo_api_v1_http_listener_options_proto_init()
	file_github_com_solo_io_gloo_projects_gloo_api_v1_tcp_listener_options_proto_init()
	file_github_com_solo_io_gloo_projects_gloo_api_v1_virtual_host_options_proto_init()
	file_github_com_solo_io_gloo_projects_gloo_api_v1_route_options_proto_init()
	file_github_com_solo_io_gloo_projects_gloo_api_v1_route_configuration_options_proto_init()
	file_github_com_solo_io_gloo_projects_gloo_api_v1_weighted_destination_options_proto_init()
	file_github_com_solo_io_gloo_projects_gloo_api_v1_subset_proto_init()
	file_github_com_solo_io_gloo_projects_gloo_api_v1_destination_spec_proto_init()
	file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[1].OneofWrappers = []any{
		(*Listener_HttpListener)(nil),
		(*Listener_TcpListener)(nil),
		(*Listener_HybridListener)(nil),
		(*Listener_AggregateListener)(nil),
		(*Listener_Metadata)(nil),
		(*Listener_MetadataStatic)(nil),
	}
	file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[6].OneofWrappers = []any{
		(*MatchedListener_HttpListener)(nil),
		(*MatchedListener_TcpListener)(nil),
	}
	file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[10].OneofWrappers = []any{
		(*VirtualHost_Metadata)(nil),
		(*VirtualHost_MetadataStatic)(nil),
	}
	file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[11].OneofWrappers = []any{
		(*Route_RouteAction)(nil),
		(*Route_RedirectAction)(nil),
		(*Route_DirectResponseAction)(nil),
		(*Route_GraphqlApiRef)(nil),
		(*Route_Metadata)(nil),
		(*Route_MetadataStatic)(nil),
	}
	file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[12].OneofWrappers = []any{
		(*RouteAction_Single)(nil),
		(*RouteAction_Multi)(nil),
		(*RouteAction_UpstreamGroup)(nil),
		(*RouteAction_ClusterHeader)(nil),
		(*RouteAction_DynamicForwardProxy)(nil),
	}
	file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[13].OneofWrappers = []any{
		(*Destination_Upstream)(nil),
		(*Destination_Kube)(nil),
		(*Destination_Consul)(nil),
	}
	file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[19].OneofWrappers = []any{
		(*RedirectAction_PathRedirect)(nil),
		(*RedirectAction_PrefixRewrite)(nil),
		(*RedirectAction_RegexRewrite)(nil),
	}
	file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes[23].OneofWrappers = []any{
		(*TcpHost_TcpAction_Single)(nil),
		(*TcpHost_TcpAction_Multi)(nil),
		(*TcpHost_TcpAction_UpstreamGroup)(nil),
		(*TcpHost_TcpAction_ForwardSniClusterName)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDesc), len(file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   29,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_goTypes,
		DependencyIndexes: file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_depIdxs,
		EnumInfos:         file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_enumTypes,
		MessageInfos:      file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_msgTypes,
	}.Build()
	File_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto = out.File
	file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_goTypes = nil
	file_github_com_solo_io_gloo_projects_gloo_api_v1_proxy_proto_depIdxs = nil
}
