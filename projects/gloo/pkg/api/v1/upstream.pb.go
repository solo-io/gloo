// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v6.33.1
// source: github.com/solo-io/gloo/projects/gloo/api/v1/upstream.proto

package v1

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	cluster "github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/api/v2/cluster"
	core1 "github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/api/v2/core"
	circuit_breaker "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/circuit_breaker"
	ai "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/ai"
	gcp "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/gcp"
	aws "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/options/aws"
	ec2 "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/options/aws/ec2"
	azure "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/options/azure"
	consul "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/options/consul"
	kubernetes "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/options/kubernetes"
	pipe "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/options/pipe"
	static "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/options/static"
	ssl "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/ssl"
	_ "github.com/solo-io/protoc-gen-ext/extproto"
	core "github.com/solo-io/solo-kit/pkg/api/v1/resources/core"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Upstream_ClusterProtocolSelection int32

const (
	// Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
	// If http2_protocol_options are
	// present, HTTP2 will be used, otherwise HTTP1.1 will be used.
	Upstream_USE_CONFIGURED_PROTOCOL Upstream_ClusterProtocolSelection = 0
	// Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection.
	Upstream_USE_DOWNSTREAM_PROTOCOL Upstream_ClusterProtocolSelection = 1
)

// Enum value maps for Upstream_ClusterProtocolSelection.
var (
	Upstream_ClusterProtocolSelection_name = map[int32]string{
		0: "USE_CONFIGURED_PROTOCOL",
		1: "USE_DOWNSTREAM_PROTOCOL",
	}
	Upstream_ClusterProtocolSelection_value = map[string]int32{
		"USE_CONFIGURED_PROTOCOL": 0,
		"USE_DOWNSTREAM_PROTOCOL": 1,
	}
)

func (x Upstream_ClusterProtocolSelection) Enum() *Upstream_ClusterProtocolSelection {
	p := new(Upstream_ClusterProtocolSelection)
	*p = x
	return p
}

func (x Upstream_ClusterProtocolSelection) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Upstream_ClusterProtocolSelection) Descriptor() protoreflect.EnumDescriptor {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_enumTypes[0].Descriptor()
}

func (Upstream_ClusterProtocolSelection) Type() protoreflect.EnumType {
	return &file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_enumTypes[0]
}

func (x Upstream_ClusterProtocolSelection) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Upstream_ClusterProtocolSelection.Descriptor instead.
func (Upstream_ClusterProtocolSelection) EnumDescriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_rawDescGZIP(), []int{0, 0}
}

// Upstreams represent destination for routing HTTP requests. Upstreams can be compared to
// [clusters](https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto) in Envoy terminology.
// Each upstream in Gloo has a type. Supported types include `static`, `kubernetes`, `aws`, `consul`, and more.
// Each upstream type is handled by a corresponding Gloo plugin. (plugins currently need to be compiled into Gloo)
type Upstream struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// NamespacedStatuses indicates the validation status of this resource.
	// NamespacedStatuses is read-only by clients, and set by gloo during validation
	NamespacedStatuses *core.NamespacedStatuses `protobuf:"bytes,23,opt,name=namespaced_statuses,json=namespacedStatuses,proto3" json:"namespaced_statuses,omitempty"`
	// Metadata contains the object metadata for this resource
	Metadata *core.Metadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Upstreams and their configuration can be automatically by Gloo Discovery
	// if this upstream is created or modified by Discovery, metadata about the operation will be placed here.
	DiscoveryMetadata *DiscoveryMetadata `protobuf:"bytes,3,opt,name=discovery_metadata,json=discoveryMetadata,proto3" json:"discovery_metadata,omitempty"`
	// SslConfig contains the options necessary to configure envoy to originate TLS to an upstream.
	SslConfig *ssl.UpstreamSslConfig `protobuf:"bytes,4,opt,name=ssl_config,json=sslConfig,proto3" json:"ssl_config,omitempty"`
	// Circuit breakers for this upstream. if not set, the defaults ones from the Gloo settings will be used.
	// if those are not set, [envoy's defaults](https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/circuit_breaker.proto#envoy-api-msg-cluster-circuitbreakers)
	// will be used.
	CircuitBreakers *circuit_breaker.CircuitBreakerConfig `protobuf:"bytes,5,opt,name=circuit_breakers,json=circuitBreakers,proto3" json:"circuit_breakers,omitempty"`
	// Settings for the load balancer that sends requests to the Upstream. The load balancing method is set to round robin by default.
	LoadBalancerConfig *LoadBalancerConfig       `protobuf:"bytes,6,opt,name=load_balancer_config,json=loadBalancerConfig,proto3" json:"load_balancer_config,omitempty"`
	HealthChecks       []*core1.HealthCheck      `protobuf:"bytes,8,rep,name=health_checks,json=healthChecks,proto3" json:"health_checks,omitempty"`
	OutlierDetection   *cluster.OutlierDetection `protobuf:"bytes,9,opt,name=outlier_detection,json=outlierDetection,proto3" json:"outlier_detection,omitempty"`
	// Note to developers: new Upstream plugins must be added to this oneof field
	// to be usable by Gloo. (plugins currently need to be compiled into Gloo)
	//
	// Types that are valid to be assigned to UpstreamType:
	//
	//	*Upstream_Kube
	//	*Upstream_Static
	//	*Upstream_Pipe
	//	*Upstream_Aws
	//	*Upstream_Azure
	//	*Upstream_Consul
	//	*Upstream_AwsEc2
	//	*Upstream_Gcp
	//	*Upstream_Ai
	UpstreamType isUpstream_UpstreamType `protobuf_oneof:"upstream_type"`
	// Failover endpoints for this upstream. If omitted (the default) no failovers will be applied.
	Failover *Failover `protobuf:"bytes,18,opt,name=failover,proto3" json:"failover,omitempty"`
	// HTTP/1 connection configurations
	ConnectionConfig *ConnectionConfig `protobuf:"bytes,7,opt,name=connection_config,json=connectionConfig,proto3" json:"connection_config,omitempty"`
	// Determines how Envoy selects the protocol used to speak to upstream hosts.
	ProtocolSelection Upstream_ClusterProtocolSelection `protobuf:"varint,25,opt,name=protocol_selection,json=protocolSelection,proto3,enum=gloo.solo.io.Upstream_ClusterProtocolSelection" json:"protocol_selection,omitempty"`
	// Use http2 when communicating with this upstream
	// this field is evaluated `true` for upstreams
	// with a grpc service spec. otherwise defaults to `false`
	UseHttp2 *wrapperspb.BoolValue `protobuf:"bytes,10,opt,name=use_http2,json=useHttp2,proto3" json:"use_http2,omitempty"`
	// (UInt32Value) Initial stream-level flow-control window size.
	// Valid values range from 65535 (2^16 - 1, HTTP/2 default) to 2147483647 (2^31 - 1, HTTP/2 maximum)
	// and defaults to 268435456 (256 * 1024 * 1024).
	// NOTE: 65535 is the initial window size from HTTP/2 spec.
	// We only support increasing the default window size now, so itâ€™s also the minimum.
	// This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream
	// in the HTTP/2 codec buffers. Once the buffer reaches this pointer,
	// watermark callbacks will fire to stop the flow of data to the codec buffers.
	// Requires UseHttp2 to be true to be acknowledged.
	InitialStreamWindowSize *wrapperspb.UInt32Value `protobuf:"bytes,19,opt,name=initial_stream_window_size,json=initialStreamWindowSize,proto3" json:"initial_stream_window_size,omitempty"`
	// (UInt32Value) Similar to initial_stream_window_size, but for connection-level flow-control window.
	// Currently, this has the same minimum/maximum/default as initial_stream_window_size.
	// Requires UseHttp2 to be true to be acknowledged.
	InitialConnectionWindowSize *wrapperspb.UInt32Value `protobuf:"bytes,20,opt,name=initial_connection_window_size,json=initialConnectionWindowSize,proto3" json:"initial_connection_window_size,omitempty"`
	// (UInt32Value) Maximum concurrent streams allowed for peer on one HTTP/2 connection.
	// Valid values range from 1 to 2147483647 (2^31 - 1) and defaults to 2147483647.
	// Requires UseHttp2 to be true to be acknowledged.
	MaxConcurrentStreams *wrapperspb.UInt32Value `protobuf:"bytes,24,opt,name=max_concurrent_streams,json=maxConcurrentStreams,proto3" json:"max_concurrent_streams,omitempty"`
	// Allows invalid HTTP messaging and headers. When this option is disabled (default), then
	// the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However,
	// when this option is enabled, only the offending stream is terminated.
	//
	// This overrides any HCM :ref:`stream_error_on_invalid_http_messaging
	// <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`
	//
	// See [RFC7540, sec. 8.1](https://datatracker.ietf.org/doc/html/rfc7540#section-8.1) for details.
	OverrideStreamErrorOnInvalidHttpMessage *wrapperspb.BoolValue `protobuf:"bytes,26,opt,name=override_stream_error_on_invalid_http_message,json=overrideStreamErrorOnInvalidHttpMessage,proto3" json:"override_stream_error_on_invalid_http_message,omitempty"`
	// Tells Envoy that the upstream is an HTTP proxy that supports [HTTP CONNECT method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT).
	// The hostname is the destination of the tunnel established by the proxy.
	// Some Envoy Command Operators (.e.g `%REQUESTED_SERVER_NAME%`) are supported allowing for dynamic destinations.
	//
	// For example, setting to: host.com:443 and making a request routed to the upstream such as `curl <envoy>:<port>/v1`
	// would result in the following request:
	//
	//	CONNECT host.com:443 HTTP/1.1
	//	host: host.com:443
	//
	//	GET /v1 HTTP/1.1
	//	host: <envoy>:<port>
	//	user-agent: curl/7.64.1
	//	accept: */*
	//
	// Note: If setting this field to a hostname rather than IP:PORT, you may want to also set `host_rewrite` on the route
	HttpProxyHostname *wrapperspb.StringValue `protobuf:"bytes,21,opt,name=http_proxy_hostname,json=httpProxyHostname,proto3" json:"http_proxy_hostname,omitempty"`
	// HttpConnectSslConfig contains the options necessary to configure envoy to originate TLS to an HTTP Connect proxy.
	// If you also want to ensure the bytes proxied by the HTTP Connect proxy are encrypted, you should also
	// specify `ssl_config`.
	HttpConnectSslConfig *ssl.UpstreamSslConfig `protobuf:"bytes,27,opt,name=http_connect_ssl_config,json=httpConnectSslConfig,proto3" json:"http_connect_ssl_config,omitempty"`
	// HttpConnectHeaders specifies the headers sent with the initial HTTP Connect request.
	HttpConnectHeaders []*HeaderValue `protobuf:"bytes,28,rep,name=http_connect_headers,json=httpConnectHeaders,proto3" json:"http_connect_headers,omitempty"`
	// (bool) If set to true, Envoy will ignore the health value of a host when processing its removal from service discovery.
	// This means that if active health checking is used, Envoy will not wait for the endpoint to go unhealthy before removing it.
	IgnoreHealthOnHostRemoval *wrapperspb.BoolValue `protobuf:"bytes,22,opt,name=ignore_health_on_host_removal,json=ignoreHealthOnHostRemoval,proto3" json:"ignore_health_on_host_removal,omitempty"`
	// If set to true, Service Discovery update period will be triggered once the TTL is expired.
	// If minimum TTL of all records is 0 then dns_refresh_rate will be used.
	RespectDnsTtl *wrapperspb.BoolValue `protobuf:"bytes,29,opt,name=respect_dns_ttl,json=respectDnsTtl,proto3" json:"respect_dns_ttl,omitempty"`
	// Service Discovery DNS Refresh Rate.
	// Minimum value is 1 ms. Values below the minimum are considered invalid.
	// Only valid for STRICT_DNS and LOGICAL_DNS cluster types. All other cluster types are considered invalid.
	DnsRefreshRate *durationpb.Duration `protobuf:"bytes,30,opt,name=dns_refresh_rate,json=dnsRefreshRate,proto3" json:"dns_refresh_rate,omitempty"`
	// Proxy Protocol Version to add when communicating with the upstream.
	// If unset will not wrap the transport socket.
	// These are of the format "V1" or "V2"
	ProxyProtocolVersion *wrapperspb.StringValue `protobuf:"bytes,31,opt,name=proxy_protocol_version,json=proxyProtocolVersion,proto3" json:"proxy_protocol_version,omitempty"`
	// Preconnect policy for the cluster
	// Aligns as closely as possible with https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#envoy-v3-api-msg-config-cluster-v3-cluster-preconnectpolicy
	// This is not recommended for use unless you are sure you need it.
	// In most cases preconnect hurts more than it helps.
	PreconnectPolicy *PreconnectPolicy `protobuf:"bytes,32,opt,name=preconnect_policy,json=preconnectPolicy,proto3" json:"preconnect_policy,omitempty"`
	// If set to true, the proxy will not allow automatic mTLS detection for Istio upstreams.
	// Defaults to false.
	DisableIstioAutoMtls *wrapperspb.BoolValue `protobuf:"bytes,33,opt,name=disable_istio_auto_mtls,json=disableIstioAutoMtls,proto3" json:"disable_istio_auto_mtls,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *Upstream) Reset() {
	*x = Upstream{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Upstream) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Upstream) ProtoMessage() {}

func (x *Upstream) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Upstream.ProtoReflect.Descriptor instead.
func (*Upstream) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_rawDescGZIP(), []int{0}
}

func (x *Upstream) GetNamespacedStatuses() *core.NamespacedStatuses {
	if x != nil {
		return x.NamespacedStatuses
	}
	return nil
}

func (x *Upstream) GetMetadata() *core.Metadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *Upstream) GetDiscoveryMetadata() *DiscoveryMetadata {
	if x != nil {
		return x.DiscoveryMetadata
	}
	return nil
}

func (x *Upstream) GetSslConfig() *ssl.UpstreamSslConfig {
	if x != nil {
		return x.SslConfig
	}
	return nil
}

func (x *Upstream) GetCircuitBreakers() *circuit_breaker.CircuitBreakerConfig {
	if x != nil {
		return x.CircuitBreakers
	}
	return nil
}

func (x *Upstream) GetLoadBalancerConfig() *LoadBalancerConfig {
	if x != nil {
		return x.LoadBalancerConfig
	}
	return nil
}

func (x *Upstream) GetHealthChecks() []*core1.HealthCheck {
	if x != nil {
		return x.HealthChecks
	}
	return nil
}

func (x *Upstream) GetOutlierDetection() *cluster.OutlierDetection {
	if x != nil {
		return x.OutlierDetection
	}
	return nil
}

func (x *Upstream) GetUpstreamType() isUpstream_UpstreamType {
	if x != nil {
		return x.UpstreamType
	}
	return nil
}

func (x *Upstream) GetKube() *kubernetes.UpstreamSpec {
	if x != nil {
		if x, ok := x.UpstreamType.(*Upstream_Kube); ok {
			return x.Kube
		}
	}
	return nil
}

func (x *Upstream) GetStatic() *static.UpstreamSpec {
	if x != nil {
		if x, ok := x.UpstreamType.(*Upstream_Static); ok {
			return x.Static
		}
	}
	return nil
}

func (x *Upstream) GetPipe() *pipe.UpstreamSpec {
	if x != nil {
		if x, ok := x.UpstreamType.(*Upstream_Pipe); ok {
			return x.Pipe
		}
	}
	return nil
}

func (x *Upstream) GetAws() *aws.UpstreamSpec {
	if x != nil {
		if x, ok := x.UpstreamType.(*Upstream_Aws); ok {
			return x.Aws
		}
	}
	return nil
}

func (x *Upstream) GetAzure() *azure.UpstreamSpec {
	if x != nil {
		if x, ok := x.UpstreamType.(*Upstream_Azure); ok {
			return x.Azure
		}
	}
	return nil
}

func (x *Upstream) GetConsul() *consul.UpstreamSpec {
	if x != nil {
		if x, ok := x.UpstreamType.(*Upstream_Consul); ok {
			return x.Consul
		}
	}
	return nil
}

func (x *Upstream) GetAwsEc2() *ec2.UpstreamSpec {
	if x != nil {
		if x, ok := x.UpstreamType.(*Upstream_AwsEc2); ok {
			return x.AwsEc2
		}
	}
	return nil
}

func (x *Upstream) GetGcp() *gcp.UpstreamSpec {
	if x != nil {
		if x, ok := x.UpstreamType.(*Upstream_Gcp); ok {
			return x.Gcp
		}
	}
	return nil
}

func (x *Upstream) GetAi() *ai.UpstreamSpec {
	if x != nil {
		if x, ok := x.UpstreamType.(*Upstream_Ai); ok {
			return x.Ai
		}
	}
	return nil
}

func (x *Upstream) GetFailover() *Failover {
	if x != nil {
		return x.Failover
	}
	return nil
}

func (x *Upstream) GetConnectionConfig() *ConnectionConfig {
	if x != nil {
		return x.ConnectionConfig
	}
	return nil
}

func (x *Upstream) GetProtocolSelection() Upstream_ClusterProtocolSelection {
	if x != nil {
		return x.ProtocolSelection
	}
	return Upstream_USE_CONFIGURED_PROTOCOL
}

func (x *Upstream) GetUseHttp2() *wrapperspb.BoolValue {
	if x != nil {
		return x.UseHttp2
	}
	return nil
}

func (x *Upstream) GetInitialStreamWindowSize() *wrapperspb.UInt32Value {
	if x != nil {
		return x.InitialStreamWindowSize
	}
	return nil
}

func (x *Upstream) GetInitialConnectionWindowSize() *wrapperspb.UInt32Value {
	if x != nil {
		return x.InitialConnectionWindowSize
	}
	return nil
}

func (x *Upstream) GetMaxConcurrentStreams() *wrapperspb.UInt32Value {
	if x != nil {
		return x.MaxConcurrentStreams
	}
	return nil
}

func (x *Upstream) GetOverrideStreamErrorOnInvalidHttpMessage() *wrapperspb.BoolValue {
	if x != nil {
		return x.OverrideStreamErrorOnInvalidHttpMessage
	}
	return nil
}

func (x *Upstream) GetHttpProxyHostname() *wrapperspb.StringValue {
	if x != nil {
		return x.HttpProxyHostname
	}
	return nil
}

func (x *Upstream) GetHttpConnectSslConfig() *ssl.UpstreamSslConfig {
	if x != nil {
		return x.HttpConnectSslConfig
	}
	return nil
}

func (x *Upstream) GetHttpConnectHeaders() []*HeaderValue {
	if x != nil {
		return x.HttpConnectHeaders
	}
	return nil
}

func (x *Upstream) GetIgnoreHealthOnHostRemoval() *wrapperspb.BoolValue {
	if x != nil {
		return x.IgnoreHealthOnHostRemoval
	}
	return nil
}

func (x *Upstream) GetRespectDnsTtl() *wrapperspb.BoolValue {
	if x != nil {
		return x.RespectDnsTtl
	}
	return nil
}

func (x *Upstream) GetDnsRefreshRate() *durationpb.Duration {
	if x != nil {
		return x.DnsRefreshRate
	}
	return nil
}

func (x *Upstream) GetProxyProtocolVersion() *wrapperspb.StringValue {
	if x != nil {
		return x.ProxyProtocolVersion
	}
	return nil
}

func (x *Upstream) GetPreconnectPolicy() *PreconnectPolicy {
	if x != nil {
		return x.PreconnectPolicy
	}
	return nil
}

func (x *Upstream) GetDisableIstioAutoMtls() *wrapperspb.BoolValue {
	if x != nil {
		return x.DisableIstioAutoMtls
	}
	return nil
}

type isUpstream_UpstreamType interface {
	isUpstream_UpstreamType()
}

type Upstream_Kube struct {
	Kube *kubernetes.UpstreamSpec `protobuf:"bytes,11,opt,name=kube,proto3,oneof"`
}

type Upstream_Static struct {
	Static *static.UpstreamSpec `protobuf:"bytes,12,opt,name=static,proto3,oneof"`
}

type Upstream_Pipe struct {
	Pipe *pipe.UpstreamSpec `protobuf:"bytes,13,opt,name=pipe,proto3,oneof"`
}

type Upstream_Aws struct {
	Aws *aws.UpstreamSpec `protobuf:"bytes,14,opt,name=aws,proto3,oneof"`
}

type Upstream_Azure struct {
	Azure *azure.UpstreamSpec `protobuf:"bytes,15,opt,name=azure,proto3,oneof"`
}

type Upstream_Consul struct {
	Consul *consul.UpstreamSpec `protobuf:"bytes,16,opt,name=consul,proto3,oneof"`
}

type Upstream_AwsEc2 struct {
	AwsEc2 *ec2.UpstreamSpec `protobuf:"bytes,17,opt,name=aws_ec2,json=awsEc2,proto3,oneof"`
}

type Upstream_Gcp struct {
	Gcp *gcp.UpstreamSpec `protobuf:"bytes,34,opt,name=gcp,proto3,oneof"`
}

type Upstream_Ai struct {
	Ai *ai.UpstreamSpec `protobuf:"bytes,35,opt,name=ai,proto3,oneof"`
}

func (*Upstream_Kube) isUpstream_UpstreamType() {}

func (*Upstream_Static) isUpstream_UpstreamType() {}

func (*Upstream_Pipe) isUpstream_UpstreamType() {}

func (*Upstream_Aws) isUpstream_UpstreamType() {}

func (*Upstream_Azure) isUpstream_UpstreamType() {}

func (*Upstream_Consul) isUpstream_UpstreamType() {}

func (*Upstream_AwsEc2) isUpstream_UpstreamType() {}

func (*Upstream_Gcp) isUpstream_UpstreamType() {}

func (*Upstream_Ai) isUpstream_UpstreamType() {}

// created by discovery services
type DiscoveryMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Labels inherited from the original upstream (e.g. Kubernetes labels)
	Labels        map[string]string `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DiscoveryMetadata) Reset() {
	*x = DiscoveryMetadata{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DiscoveryMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DiscoveryMetadata) ProtoMessage() {}

func (x *DiscoveryMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DiscoveryMetadata.ProtoReflect.Descriptor instead.
func (*DiscoveryMetadata) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_rawDescGZIP(), []int{1}
}

func (x *DiscoveryMetadata) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

// Header name/value pair.
type HeaderValue struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Header name.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Header value.
	Value         string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HeaderValue) Reset() {
	*x = HeaderValue{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeaderValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeaderValue) ProtoMessage() {}

func (x *HeaderValue) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeaderValue.ProtoReflect.Descriptor instead.
func (*HeaderValue) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_rawDescGZIP(), []int{2}
}

func (x *HeaderValue) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *HeaderValue) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

type PreconnectPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Indicates how many streams (rounded up) can be anticipated per-upstream for each
	// incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
	// will only be done if the upstream is healthy and the cluster has traffic.
	//
	// For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
	// established, one for the new incoming stream, and one for a presumed follow-up stream. For
	// HTTP/2, only one connection would be established by default as one connection can
	// serve both the original and presumed follow-up stream.
	//
	// In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
	// active streams, there would be 100 connections in use, and 50 connections preconnected.
	// This might be a useful value for something like short lived single-use connections,
	// for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
	// termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
	// or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
	// reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
	// in case of unexpected disconnects where the connection could not be reused.
	//
	// If this value is not set, or set explicitly to one, Envoy will fetch as many connections
	// as needed to serve streams in flight. This means in steady state if a connection is torn down,
	// a subsequent streams will pay an upstream-rtt latency penalty waiting for a new connection.
	//
	// This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
	// harm latency more than the preconnecting helps.
	PerUpstreamPreconnectRatio *wrapperspb.DoubleValue `protobuf:"bytes,1,opt,name=per_upstream_preconnect_ratio,json=perUpstreamPreconnectRatio,proto3" json:"per_upstream_preconnect_ratio,omitempty"`
	// Indicates how many streams (rounded up) can be anticipated across a cluster for each
	// stream, useful for low QPS services. This is currently supported for a subset of
	// deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
	// Unlike `per_upstream_preconnect_ratio` this preconnects across the upstream instances in a
	// cluster, doing best effort predictions of what upstream would be picked next and
	// pre-establishing a connection.
	//
	// Preconnecting will be limited to one preconnect per configured upstream in the cluster and will
	// only be done if there are healthy upstreams and the cluster has traffic.
	//
	// For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
	// incoming stream, 2 connections will be preconnected - one to the first upstream for this
	// cluster, one to the second on the assumption there will be a follow-up stream.
	//
	// If this value is not set, or set explicitly to one, Envoy will fetch as many connections
	// as needed to serve streams in flight, so during warm up and in steady state if a connection
	// is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
	// connection establishment.
	//
	// If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
	// basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each
	// upstream.
	PredictivePreconnectRatio *wrapperspb.DoubleValue `protobuf:"bytes,2,opt,name=predictive_preconnect_ratio,json=predictivePreconnectRatio,proto3" json:"predictive_preconnect_ratio,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *PreconnectPolicy) Reset() {
	*x = PreconnectPolicy{}
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PreconnectPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PreconnectPolicy) ProtoMessage() {}

func (x *PreconnectPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PreconnectPolicy.ProtoReflect.Descriptor instead.
func (*PreconnectPolicy) Descriptor() ([]byte, []int) {
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_rawDescGZIP(), []int{3}
}

func (x *PreconnectPolicy) GetPerUpstreamPreconnectRatio() *wrapperspb.DoubleValue {
	if x != nil {
		return x.PerUpstreamPreconnectRatio
	}
	return nil
}

func (x *PreconnectPolicy) GetPredictivePreconnectRatio() *wrapperspb.DoubleValue {
	if x != nil {
		return x.PredictivePreconnectRatio
	}
	return nil
}

var File_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto protoreflect.FileDescriptor

const file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_rawDesc = "" +
	"\n" +
	";github.com/solo-io/gloo/projects/gloo/api/v1/upstream.proto\x12\fgloo.solo.io\x1a\x12extproto/ext.proto\x1a1github.com/solo-io/solo-kit/api/v1/metadata.proto\x1a:github.com/solo-io/gloo/projects/gloo/api/v1/ssl/ssl.proto\x1aRgithub.com/solo-io/gloo/projects/gloo/api/v1/circuit_breaker/circuit_breaker.proto\x1a@github.com/solo-io/gloo/projects/gloo/api/v1/load_balancer.proto\x1a=github.com/solo-io/gloo/projects/gloo/api/v1/connection.proto\x1aWgithub.com/solo-io/gloo/projects/gloo/api/external/envoy/api/v2/core/health_check.proto\x1a/github.com/solo-io/solo-kit/api/v1/status.proto\x1a_github.com/solo-io/gloo/projects/gloo/api/external/envoy/api/v2/cluster/outlier_detection.proto\x1a1github.com/solo-io/solo-kit/api/v1/solo-kit.proto\x1aHgithub.com/solo-io/gloo/projects/gloo/api/v1/options/static/static.proto\x1aDgithub.com/solo-io/gloo/projects/gloo/api/v1/options/pipe/pipe.proto\x1aPgithub.com/solo-io/gloo/projects/gloo/api/v1/options/kubernetes/kubernetes.proto\x1aBgithub.com/solo-io/gloo/projects/gloo/api/v1/options/aws/aws.proto\x1aFgithub.com/solo-io/gloo/projects/gloo/api/v1/options/azure/azure.proto\x1aHgithub.com/solo-io/gloo/projects/gloo/api/v1/options/consul/consul.proto\x1aJgithub.com/solo-io/gloo/projects/gloo/api/v1/options/aws/ec2/aws_ec2.proto\x1a;github.com/solo-io/gloo/projects/gloo/api/v1/failover.proto\x1aMgithub.com/solo-io/gloo/projects/gloo/api/v1/enterprise/options/gcp/gcp.proto\x1aKgithub.com/solo-io/gloo/projects/gloo/api/v1/enterprise/options/ai/ai.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1egoogle/protobuf/wrappers.proto\x1a\x17validate/validate.proto\"\xb4\x15\n" +
	"\bUpstream\x12W\n" +
	"\x13namespaced_statuses\x18\x17 \x01(\v2 .core.solo.io.NamespacedStatusesB\x04\xb8\xf5\x04\x01R\x12namespacedStatuses\x122\n" +
	"\bmetadata\x18\x02 \x01(\v2\x16.core.solo.io.MetadataR\bmetadata\x12N\n" +
	"\x12discovery_metadata\x18\x03 \x01(\v2\x1f.gloo.solo.io.DiscoveryMetadataR\x11discoveryMetadata\x12>\n" +
	"\n" +
	"ssl_config\x18\x04 \x01(\v2\x1f.gloo.solo.io.UpstreamSslConfigR\tsslConfig\x12M\n" +
	"\x10circuit_breakers\x18\x05 \x01(\v2\".gloo.solo.io.CircuitBreakerConfigR\x0fcircuitBreakers\x12R\n" +
	"\x14load_balancer_config\x18\x06 \x01(\v2 .gloo.solo.io.LoadBalancerConfigR\x12loadBalancerConfig\x12K\n" +
	"\rhealth_checks\x18\b \x03(\v2&.solo.io.envoy.api.v2.core.HealthCheckR\fhealthChecks\x12[\n" +
	"\x11outlier_detection\x18\t \x01(\v2..solo.io.envoy.api.v2.cluster.OutlierDetectionR\x10outlierDetection\x12C\n" +
	"\x04kube\x18\v \x01(\v2-.kubernetes.options.gloo.solo.io.UpstreamSpecH\x00R\x04kube\x12C\n" +
	"\x06static\x18\f \x01(\v2).static.options.gloo.solo.io.UpstreamSpecH\x00R\x06static\x12=\n" +
	"\x04pipe\x18\r \x01(\v2'.pipe.options.gloo.solo.io.UpstreamSpecH\x00R\x04pipe\x12:\n" +
	"\x03aws\x18\x0e \x01(\v2&.aws.options.gloo.solo.io.UpstreamSpecH\x00R\x03aws\x12@\n" +
	"\x05azure\x18\x0f \x01(\v2(.azure.options.gloo.solo.io.UpstreamSpecH\x00R\x05azure\x12C\n" +
	"\x06consul\x18\x10 \x01(\v2).consul.options.gloo.solo.io.UpstreamSpecH\x00R\x06consul\x12E\n" +
	"\aaws_ec2\x18\x11 \x01(\v2*.aws_ec2.options.gloo.solo.io.UpstreamSpecH\x00R\x06awsEc2\x12:\n" +
	"\x03gcp\x18\" \x01(\v2&.gcp.options.gloo.solo.io.UpstreamSpecH\x00R\x03gcp\x127\n" +
	"\x02ai\x18# \x01(\v2%.ai.options.gloo.solo.io.UpstreamSpecH\x00R\x02ai\x122\n" +
	"\bfailover\x18\x12 \x01(\v2\x16.gloo.solo.io.FailoverR\bfailover\x12K\n" +
	"\x11connection_config\x18\a \x01(\v2\x1e.gloo.solo.io.ConnectionConfigR\x10connectionConfig\x12^\n" +
	"\x12protocol_selection\x18\x19 \x01(\x0e2/.gloo.solo.io.Upstream.ClusterProtocolSelectionR\x11protocolSelection\x127\n" +
	"\tuse_http2\x18\n" +
	" \x01(\v2\x1a.google.protobuf.BoolValueR\buseHttp2\x12Y\n" +
	"\x1ainitial_stream_window_size\x18\x13 \x01(\v2\x1c.google.protobuf.UInt32ValueR\x17initialStreamWindowSize\x12a\n" +
	"\x1einitial_connection_window_size\x18\x14 \x01(\v2\x1c.google.protobuf.UInt32ValueR\x1binitialConnectionWindowSize\x12R\n" +
	"\x16max_concurrent_streams\x18\x18 \x01(\v2\x1c.google.protobuf.UInt32ValueR\x14maxConcurrentStreams\x12z\n" +
	"-override_stream_error_on_invalid_http_message\x18\x1a \x01(\v2\x1a.google.protobuf.BoolValueR'overrideStreamErrorOnInvalidHttpMessage\x12L\n" +
	"\x13http_proxy_hostname\x18\x15 \x01(\v2\x1c.google.protobuf.StringValueR\x11httpProxyHostname\x12V\n" +
	"\x17http_connect_ssl_config\x18\x1b \x01(\v2\x1f.gloo.solo.io.UpstreamSslConfigR\x14httpConnectSslConfig\x12K\n" +
	"\x14http_connect_headers\x18\x1c \x03(\v2\x19.gloo.solo.io.HeaderValueR\x12httpConnectHeaders\x12\\\n" +
	"\x1dignore_health_on_host_removal\x18\x16 \x01(\v2\x1a.google.protobuf.BoolValueR\x19ignoreHealthOnHostRemoval\x12B\n" +
	"\x0frespect_dns_ttl\x18\x1d \x01(\v2\x1a.google.protobuf.BoolValueR\rrespectDnsTtl\x12C\n" +
	"\x10dns_refresh_rate\x18\x1e \x01(\v2\x19.google.protobuf.DurationR\x0ednsRefreshRate\x12R\n" +
	"\x16proxy_protocol_version\x18\x1f \x01(\v2\x1c.google.protobuf.StringValueR\x14proxyProtocolVersion\x12K\n" +
	"\x11preconnect_policy\x18  \x01(\v2\x1e.gloo.solo.io.PreconnectPolicyR\x10preconnectPolicy\x12Q\n" +
	"\x17disable_istio_auto_mtls\x18! \x01(\v2\x1a.google.protobuf.BoolValueR\x14disableIstioAutoMtls\"T\n" +
	"\x18ClusterProtocolSelection\x12\x1b\n" +
	"\x17USE_CONFIGURED_PROTOCOL\x10\x00\x12\x1b\n" +
	"\x17USE_DOWNSTREAM_PROTOCOL\x10\x01:\x13\x82\xf1\x04\x0f\n" +
	"\x02us\x12\tupstreamsB\x0f\n" +
	"\rupstream_typeJ\x04\b\x01\x10\x02\"\x93\x01\n" +
	"\x11DiscoveryMetadata\x12C\n" +
	"\x06labels\x18\x01 \x03(\v2+.gloo.solo.io.DiscoveryMetadata.LabelsEntryR\x06labels\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"5\n" +
	"\vHeaderValue\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\"\x83\x02\n" +
	"\x10PreconnectPolicy\x12x\n" +
	"\x1dper_upstream_preconnect_ratio\x18\x01 \x01(\v2\x1c.google.protobuf.DoubleValueB\x17\xfaB\x14\x12\x12\x19\x00\x00\x00\x00\x00\x00\b@)\x00\x00\x00\x00\x00\x00\xf0?R\x1aperUpstreamPreconnectRatio\x12u\n" +
	"\x1bpredictive_preconnect_ratio\x18\x02 \x01(\v2\x1c.google.protobuf.DoubleValueB\x17\xfaB\x14\x12\x12\x19\x00\x00\x00\x00\x00\x00\b@)\x00\x00\x00\x00\x00\x00\xf0?R\x19predictivePreconnectRatioB>\xb8\xf5\x04\x01\xc0\xf5\x04\x01\xd0\xf5\x04\x01Z0github.com/solo-io/gloo/projects/gloo/pkg/api/v1b\x06proto3"

var (
	file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_rawDescOnce sync.Once
	file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_rawDescData []byte
)

func file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_rawDescGZIP() []byte {
	file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_rawDescOnce.Do(func() {
		file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_rawDesc), len(file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_rawDesc)))
	})
	return file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_rawDescData
}

var file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_goTypes = []any{
	(Upstream_ClusterProtocolSelection)(0),       // 0: gloo.solo.io.Upstream.ClusterProtocolSelection
	(*Upstream)(nil),                             // 1: gloo.solo.io.Upstream
	(*DiscoveryMetadata)(nil),                    // 2: gloo.solo.io.DiscoveryMetadata
	(*HeaderValue)(nil),                          // 3: gloo.solo.io.HeaderValue
	(*PreconnectPolicy)(nil),                     // 4: gloo.solo.io.PreconnectPolicy
	nil,                                          // 5: gloo.solo.io.DiscoveryMetadata.LabelsEntry
	(*core.NamespacedStatuses)(nil),              // 6: core.solo.io.NamespacedStatuses
	(*core.Metadata)(nil),                        // 7: core.solo.io.Metadata
	(*ssl.UpstreamSslConfig)(nil),                // 8: gloo.solo.io.UpstreamSslConfig
	(*circuit_breaker.CircuitBreakerConfig)(nil), // 9: gloo.solo.io.CircuitBreakerConfig
	(*LoadBalancerConfig)(nil),                   // 10: gloo.solo.io.LoadBalancerConfig
	(*core1.HealthCheck)(nil),                    // 11: solo.io.envoy.api.v2.core.HealthCheck
	(*cluster.OutlierDetection)(nil),             // 12: solo.io.envoy.api.v2.cluster.OutlierDetection
	(*kubernetes.UpstreamSpec)(nil),              // 13: kubernetes.options.gloo.solo.io.UpstreamSpec
	(*static.UpstreamSpec)(nil),                  // 14: static.options.gloo.solo.io.UpstreamSpec
	(*pipe.UpstreamSpec)(nil),                    // 15: pipe.options.gloo.solo.io.UpstreamSpec
	(*aws.UpstreamSpec)(nil),                     // 16: aws.options.gloo.solo.io.UpstreamSpec
	(*azure.UpstreamSpec)(nil),                   // 17: azure.options.gloo.solo.io.UpstreamSpec
	(*consul.UpstreamSpec)(nil),                  // 18: consul.options.gloo.solo.io.UpstreamSpec
	(*ec2.UpstreamSpec)(nil),                     // 19: aws_ec2.options.gloo.solo.io.UpstreamSpec
	(*gcp.UpstreamSpec)(nil),                     // 20: gcp.options.gloo.solo.io.UpstreamSpec
	(*ai.UpstreamSpec)(nil),                      // 21: ai.options.gloo.solo.io.UpstreamSpec
	(*Failover)(nil),                             // 22: gloo.solo.io.Failover
	(*ConnectionConfig)(nil),                     // 23: gloo.solo.io.ConnectionConfig
	(*wrapperspb.BoolValue)(nil),                 // 24: google.protobuf.BoolValue
	(*wrapperspb.UInt32Value)(nil),               // 25: google.protobuf.UInt32Value
	(*wrapperspb.StringValue)(nil),               // 26: google.protobuf.StringValue
	(*durationpb.Duration)(nil),                  // 27: google.protobuf.Duration
	(*wrapperspb.DoubleValue)(nil),               // 28: google.protobuf.DoubleValue
}
var file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_depIdxs = []int32{
	6,  // 0: gloo.solo.io.Upstream.namespaced_statuses:type_name -> core.solo.io.NamespacedStatuses
	7,  // 1: gloo.solo.io.Upstream.metadata:type_name -> core.solo.io.Metadata
	2,  // 2: gloo.solo.io.Upstream.discovery_metadata:type_name -> gloo.solo.io.DiscoveryMetadata
	8,  // 3: gloo.solo.io.Upstream.ssl_config:type_name -> gloo.solo.io.UpstreamSslConfig
	9,  // 4: gloo.solo.io.Upstream.circuit_breakers:type_name -> gloo.solo.io.CircuitBreakerConfig
	10, // 5: gloo.solo.io.Upstream.load_balancer_config:type_name -> gloo.solo.io.LoadBalancerConfig
	11, // 6: gloo.solo.io.Upstream.health_checks:type_name -> solo.io.envoy.api.v2.core.HealthCheck
	12, // 7: gloo.solo.io.Upstream.outlier_detection:type_name -> solo.io.envoy.api.v2.cluster.OutlierDetection
	13, // 8: gloo.solo.io.Upstream.kube:type_name -> kubernetes.options.gloo.solo.io.UpstreamSpec
	14, // 9: gloo.solo.io.Upstream.static:type_name -> static.options.gloo.solo.io.UpstreamSpec
	15, // 10: gloo.solo.io.Upstream.pipe:type_name -> pipe.options.gloo.solo.io.UpstreamSpec
	16, // 11: gloo.solo.io.Upstream.aws:type_name -> aws.options.gloo.solo.io.UpstreamSpec
	17, // 12: gloo.solo.io.Upstream.azure:type_name -> azure.options.gloo.solo.io.UpstreamSpec
	18, // 13: gloo.solo.io.Upstream.consul:type_name -> consul.options.gloo.solo.io.UpstreamSpec
	19, // 14: gloo.solo.io.Upstream.aws_ec2:type_name -> aws_ec2.options.gloo.solo.io.UpstreamSpec
	20, // 15: gloo.solo.io.Upstream.gcp:type_name -> gcp.options.gloo.solo.io.UpstreamSpec
	21, // 16: gloo.solo.io.Upstream.ai:type_name -> ai.options.gloo.solo.io.UpstreamSpec
	22, // 17: gloo.solo.io.Upstream.failover:type_name -> gloo.solo.io.Failover
	23, // 18: gloo.solo.io.Upstream.connection_config:type_name -> gloo.solo.io.ConnectionConfig
	0,  // 19: gloo.solo.io.Upstream.protocol_selection:type_name -> gloo.solo.io.Upstream.ClusterProtocolSelection
	24, // 20: gloo.solo.io.Upstream.use_http2:type_name -> google.protobuf.BoolValue
	25, // 21: gloo.solo.io.Upstream.initial_stream_window_size:type_name -> google.protobuf.UInt32Value
	25, // 22: gloo.solo.io.Upstream.initial_connection_window_size:type_name -> google.protobuf.UInt32Value
	25, // 23: gloo.solo.io.Upstream.max_concurrent_streams:type_name -> google.protobuf.UInt32Value
	24, // 24: gloo.solo.io.Upstream.override_stream_error_on_invalid_http_message:type_name -> google.protobuf.BoolValue
	26, // 25: gloo.solo.io.Upstream.http_proxy_hostname:type_name -> google.protobuf.StringValue
	8,  // 26: gloo.solo.io.Upstream.http_connect_ssl_config:type_name -> gloo.solo.io.UpstreamSslConfig
	3,  // 27: gloo.solo.io.Upstream.http_connect_headers:type_name -> gloo.solo.io.HeaderValue
	24, // 28: gloo.solo.io.Upstream.ignore_health_on_host_removal:type_name -> google.protobuf.BoolValue
	24, // 29: gloo.solo.io.Upstream.respect_dns_ttl:type_name -> google.protobuf.BoolValue
	27, // 30: gloo.solo.io.Upstream.dns_refresh_rate:type_name -> google.protobuf.Duration
	26, // 31: gloo.solo.io.Upstream.proxy_protocol_version:type_name -> google.protobuf.StringValue
	4,  // 32: gloo.solo.io.Upstream.preconnect_policy:type_name -> gloo.solo.io.PreconnectPolicy
	24, // 33: gloo.solo.io.Upstream.disable_istio_auto_mtls:type_name -> google.protobuf.BoolValue
	5,  // 34: gloo.solo.io.DiscoveryMetadata.labels:type_name -> gloo.solo.io.DiscoveryMetadata.LabelsEntry
	28, // 35: gloo.solo.io.PreconnectPolicy.per_upstream_preconnect_ratio:type_name -> google.protobuf.DoubleValue
	28, // 36: gloo.solo.io.PreconnectPolicy.predictive_preconnect_ratio:type_name -> google.protobuf.DoubleValue
	37, // [37:37] is the sub-list for method output_type
	37, // [37:37] is the sub-list for method input_type
	37, // [37:37] is the sub-list for extension type_name
	37, // [37:37] is the sub-list for extension extendee
	0,  // [0:37] is the sub-list for field type_name
}

func init() { file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_init() }
func file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_init() {
	if File_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto != nil {
		return
	}
	file_github_com_solo_io_gloo_projects_gloo_api_v1_load_balancer_proto_init()
	file_github_com_solo_io_gloo_projects_gloo_api_v1_connection_proto_init()
	file_github_com_solo_io_gloo_projects_gloo_api_v1_failover_proto_init()
	file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_msgTypes[0].OneofWrappers = []any{
		(*Upstream_Kube)(nil),
		(*Upstream_Static)(nil),
		(*Upstream_Pipe)(nil),
		(*Upstream_Aws)(nil),
		(*Upstream_Azure)(nil),
		(*Upstream_Consul)(nil),
		(*Upstream_AwsEc2)(nil),
		(*Upstream_Gcp)(nil),
		(*Upstream_Ai)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_rawDesc), len(file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   5,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_goTypes,
		DependencyIndexes: file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_depIdxs,
		EnumInfos:         file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_enumTypes,
		MessageInfos:      file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_msgTypes,
	}.Build()
	File_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto = out.File
	file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_goTypes = nil
	file_github_com_solo_io_gloo_projects_gloo_api_v1_upstream_proto_depIdxs = nil
}
