// Code generated by solo-kit. DO NOT EDIT.

package gloosnapshot

import (
	"context"
	"fmt"
	"time"

	gateway_solo_io "github.com/solo-io/gloo/projects/gateway/pkg/api/v1"
	github_com_solo_io_gloo_projects_gloo_pkg_api_external_solo_ratelimit "github.com/solo-io/gloo/projects/gloo/pkg/api/external/solo/ratelimit"
	gloo_solo_io "github.com/solo-io/gloo/projects/gloo/pkg/api/v1"
	enterprise_gloo_solo_io "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1"
	graphql_gloo_solo_io "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/graphql/v1beta1"

	"go.opencensus.io/stats"
	"go.uber.org/zap"

	"github.com/solo-io/go-utils/contextutils"
	"github.com/solo-io/go-utils/errutils"
	"github.com/solo-io/solo-kit/pkg/api/v1/clients"
)

type ApiSimpleEmitter interface {
	Snapshots(ctx context.Context) (<-chan *ApiSnapshot, <-chan error, error)
}

func NewApiSimpleEmitter(aggregatedWatch clients.ResourceWatch) ApiSimpleEmitter {
	return NewApiSimpleEmitterWithEmit(aggregatedWatch, make(chan struct{}))
}

func NewApiSimpleEmitterWithEmit(aggregatedWatch clients.ResourceWatch, emit <-chan struct{}) ApiSimpleEmitter {
	return &apiSimpleEmitter{
		aggregatedWatch: aggregatedWatch,
		forceEmit:       emit,
	}
}

type apiSimpleEmitter struct {
	forceEmit       <-chan struct{}
	aggregatedWatch clients.ResourceWatch
}

func (c *apiSimpleEmitter) Snapshots(ctx context.Context) (<-chan *ApiSnapshot, <-chan error, error) {
	snapshots := make(chan *ApiSnapshot)
	errs := make(chan error)

	untyped, watchErrs, err := c.aggregatedWatch(ctx)
	if err != nil {
		return nil, nil, err
	}

	go errutils.AggregateErrs(ctx, errs, watchErrs, "api-emitter")

	go func() {
		currentSnapshot := ApiSnapshot{}
		timer := time.NewTicker(time.Second * 1)
		var previousHash uint64
		sync := func() {
			currentHash, err := currentSnapshot.Hash(nil)
			if err != nil {
				contextutils.LoggerFrom(ctx).Panicw("error while hashing, this should never happen", zap.Error(err))
			}
			if previousHash == currentHash {
				return
			}

			previousHash = currentHash

			stats.Record(ctx, mApiSnapshotOut.M(1))
			sentSnapshot := currentSnapshot.Clone()
			snapshots <- &sentSnapshot
		}

		defer func() {
			close(snapshots)
			close(errs)
		}()

		for {
			record := func() { stats.Record(ctx, mApiSnapshotIn.M(1)) }

			select {
			case <-timer.C:
				sync()
			case <-ctx.Done():
				return
			case <-c.forceEmit:
				sentSnapshot := currentSnapshot.Clone()
				snapshots <- &sentSnapshot
			case untypedList := <-untyped:
				record()

				currentSnapshot = ApiSnapshot{}
				for _, res := range untypedList {
					switch typed := res.(type) {
					case *gloo_solo_io.Artifact:
						currentSnapshot.Artifacts = append(currentSnapshot.Artifacts, typed)
					case *gloo_solo_io.Endpoint:
						currentSnapshot.Endpoints = append(currentSnapshot.Endpoints, typed)
					case *gloo_solo_io.Proxy:
						currentSnapshot.Proxies = append(currentSnapshot.Proxies, typed)
					case *gloo_solo_io.UpstreamGroup:
						currentSnapshot.UpstreamGroups = append(currentSnapshot.UpstreamGroups, typed)
					case *gloo_solo_io.Secret:
						currentSnapshot.Secrets = append(currentSnapshot.Secrets, typed)
					case *gloo_solo_io.Upstream:
						currentSnapshot.Upstreams = append(currentSnapshot.Upstreams, typed)
					case *enterprise_gloo_solo_io.AuthConfig:
						currentSnapshot.AuthConfigs = append(currentSnapshot.AuthConfigs, typed)
					case *github_com_solo_io_gloo_projects_gloo_pkg_api_external_solo_ratelimit.RateLimitConfig:
						currentSnapshot.Ratelimitconfigs = append(currentSnapshot.Ratelimitconfigs, typed)
					case *gateway_solo_io.VirtualService:
						currentSnapshot.VirtualServices = append(currentSnapshot.VirtualServices, typed)
					case *gateway_solo_io.RouteTable:
						currentSnapshot.RouteTables = append(currentSnapshot.RouteTables, typed)
					case *gateway_solo_io.Gateway:
						currentSnapshot.Gateways = append(currentSnapshot.Gateways, typed)
					case *gateway_solo_io.VirtualHostOption:
						currentSnapshot.VirtualHostOptions = append(currentSnapshot.VirtualHostOptions, typed)
					case *gateway_solo_io.RouteOption:
						currentSnapshot.RouteOptions = append(currentSnapshot.RouteOptions, typed)
					case *gateway_solo_io.MatchableHttpGateway:
						currentSnapshot.HttpGateways = append(currentSnapshot.HttpGateways, typed)
					case *gateway_solo_io.MatchableTcpGateway:
						currentSnapshot.TcpGateways = append(currentSnapshot.TcpGateways, typed)
					case *graphql_gloo_solo_io.GraphQLApi:
						currentSnapshot.GraphqlApis = append(currentSnapshot.GraphqlApis, typed)
					default:
						select {
						case errs <- fmt.Errorf("ApiSnapshotEmitter "+
							"cannot process resource %v of type %T", res.GetMetadata().Ref(), res):
						case <-ctx.Done():
							return
						}
					}
				}

			}
		}
	}()
	return snapshots, errs, nil
}
