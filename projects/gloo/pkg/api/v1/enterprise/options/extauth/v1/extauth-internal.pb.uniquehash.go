// Code generated by protoc-gen-ext. DO NOT EDIT.
// source: github.com/solo-io/gloo/projects/gloo/api/v1/enterprise/options/extauth/v1/extauth-internal.proto

package v1

import (
	"encoding/binary"
	"errors"
	"fmt"
	"hash"
	"hash/fnv"
	"strconv"

	safe_hasher "github.com/solo-io/protoc-gen-ext/pkg/hasher"
	"github.com/solo-io/protoc-gen-ext/pkg/hasher/hashstructure"
)

// ensure the imports are used
var (
	_ = errors.New("")
	_ = fmt.Print
	_ = binary.LittleEndian
	_ = new(hash.Hash64)
	_ = fnv.New64
	_ = strconv.Itoa
	_ = hashstructure.Hash
	_ = new(safe_hasher.SafeHasher)
)

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("AuthConfigRefName")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetAuthConfigRefName())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Configs")); err != nil {
		return 0, err
	}
	for i, v := range m.GetConfigs() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if h, ok := interface{}(m.GetBooleanExpr()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("BooleanExpr")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetBooleanExpr(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("BooleanExpr")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if _, err = hasher.Write([]byte("FailOnRedirect")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetFailOnRedirect())
	if err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ApiKeyCreateRequest) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ApiKeyCreateRequest")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ApiKeys")); err != nil {
		return 0, err
	}
	for i, v := range m.GetApiKeys() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if _, err = hasher.Write([]byte("RawApiKeys")); err != nil {
		return 0, err
	}
	for i, v := range m.GetRawApiKeys() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if _, err = hasher.Write([]byte("v")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(v)); err != nil {
			return 0, err
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ApiKeyCreateResponse) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ApiKeyCreateResponse")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ApiKeys")); err != nil {
		return 0, err
	}
	for i, v := range m.GetApiKeys() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ApiKeyReadRequest) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ApiKeyReadRequest")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("RawApiKeys")); err != nil {
		return 0, err
	}
	for i, v := range m.GetRawApiKeys() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if _, err = hasher.Write([]byte("v")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(v)); err != nil {
			return 0, err
		}

	}

	if _, err = hasher.Write([]byte("Labels")); err != nil {
		return 0, err
	}
	for i, v := range m.GetLabels() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if _, err = hasher.Write([]byte("v")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(v)); err != nil {
			return 0, err
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ApiKeyReadResponse) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ApiKeyReadResponse")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ApiKeys")); err != nil {
		return 0, err
	}
	for i, v := range m.GetApiKeys() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ApiKeyUpdateRequest) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ApiKeyUpdateRequest")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Upsert")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetUpsert())
	if err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ApiKeys")); err != nil {
		return 0, err
	}
	for i, v := range m.GetApiKeys() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if _, err = hasher.Write([]byte("RawApiKeys")); err != nil {
		return 0, err
	}
	for i, v := range m.GetRawApiKeys() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if _, err = hasher.Write([]byte("v")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(v)); err != nil {
			return 0, err
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ApiKeyUpdateResponse) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ApiKeyUpdateResponse")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ApiKeys")); err != nil {
		return 0, err
	}
	for i, v := range m.GetApiKeys() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ApiKeyDeleteRequest) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ApiKeyDeleteRequest")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("RawApiKeys")); err != nil {
		return 0, err
	}
	for i, v := range m.GetRawApiKeys() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if _, err = hasher.Write([]byte("v")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(v)); err != nil {
			return 0, err
		}

	}

	if _, err = hasher.Write([]byte("Labels")); err != nil {
		return 0, err
	}
	for i, v := range m.GetLabels() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if _, err = hasher.Write([]byte("v")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(v)); err != nil {
			return 0, err
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ApiKeyDeleteResponse) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ApiKeyDeleteResponse")); err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_Azure) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_Azure")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ClientId")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetClientId())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("TenantId")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetTenantId())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ClientSecret")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetClientSecret())); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetClaimsCachingOptions()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("ClaimsCachingOptions")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetClaimsCachingOptions(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("ClaimsCachingOptions")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_ClaimToHeader) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_ClaimToHeader")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Claim")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetClaim())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Header")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetHeader())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Append")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetAppend())
	if err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_BasicAuthInternal) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_BasicAuthInternal")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Realm")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetRealm())); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetEncryption()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Encryption")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetEncryption(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Encryption")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	switch m.UserSource.(type) {

	case *ExtAuthConfig_BasicAuthInternal_UserList_:

		if h, ok := interface{}(m.GetUserList()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("UserList")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetUserList(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("UserList")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_OAuthConfig) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_OAuthConfig")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ClientId")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetClientId())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ClientSecret")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetClientSecret())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("IssuerUrl")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetIssuerUrl())); err != nil {
		return 0, err
	}

	{
		var result uint64
		innerHash := fnv.New64()
		for k, v := range m.GetAuthEndpointQueryParams() {
			innerHash.Reset()

			if _, err = innerHash.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(v)); err != nil {
				return 0, err
			}

			if _, err = innerHash.Write([]byte("k")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(k)); err != nil {
				return 0, err
			}

			result = result ^ innerHash.Sum64()
		}
		err = binary.Write(hasher, binary.LittleEndian, result)
		if err != nil {
			return 0, err
		}

	}

	if _, err = hasher.Write([]byte("AppUrl")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetAppUrl())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("CallbackPath")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetCallbackPath())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Scopes")); err != nil {
		return 0, err
	}
	for i, v := range m.GetScopes() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if _, err = hasher.Write([]byte("v")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(v)); err != nil {
			return 0, err
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_UserSessionConfig) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_UserSessionConfig")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("FailOnFetchFailure")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetFailOnFetchFailure())
	if err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetCookieOptions()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("CookieOptions")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetCookieOptions(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("CookieOptions")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetCipherConfig()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("CipherConfig")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetCipherConfig(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("CipherConfig")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	switch m.Session.(type) {

	case *ExtAuthConfig_UserSessionConfig_Cookie:

		if h, ok := interface{}(m.GetCookie()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("Cookie")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetCookie(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("Cookie")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_UserSessionConfig_Redis:

		if h, ok := interface{}(m.GetRedis()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("Redis")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetRedis(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("Redis")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_OidcAuthorizationCodeConfig) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_OidcAuthorizationCodeConfig")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ClientId")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetClientId())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ClientSecret")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetClientSecret())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("IssuerUrl")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetIssuerUrl())); err != nil {
		return 0, err
	}

	{
		var result uint64
		innerHash := fnv.New64()
		for k, v := range m.GetAuthEndpointQueryParams() {
			innerHash.Reset()

			if _, err = innerHash.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(v)); err != nil {
				return 0, err
			}

			if _, err = innerHash.Write([]byte("k")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(k)); err != nil {
				return 0, err
			}

			result = result ^ innerHash.Sum64()
		}
		err = binary.Write(hasher, binary.LittleEndian, result)
		if err != nil {
			return 0, err
		}

	}

	{
		var result uint64
		innerHash := fnv.New64()
		for k, v := range m.GetTokenEndpointQueryParams() {
			innerHash.Reset()

			if _, err = innerHash.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(v)); err != nil {
				return 0, err
			}

			if _, err = innerHash.Write([]byte("k")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(k)); err != nil {
				return 0, err
			}

			result = result ^ innerHash.Sum64()
		}
		err = binary.Write(hasher, binary.LittleEndian, result)
		if err != nil {
			return 0, err
		}

	}

	if _, err = hasher.Write([]byte("AppUrl")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetAppUrl())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("CallbackPath")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetCallbackPath())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("LogoutPath")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetLogoutPath())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("AfterLogoutUrl")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetAfterLogoutUrl())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Scopes")); err != nil {
		return 0, err
	}
	for i, v := range m.GetScopes() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if _, err = hasher.Write([]byte("v")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(v)); err != nil {
			return 0, err
		}

	}

	if h, ok := interface{}(m.GetSession()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Session")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetSession(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Session")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetHeaders()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Headers")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetHeaders(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Headers")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetDiscoveryOverride()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("DiscoveryOverride")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetDiscoveryOverride(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("DiscoveryOverride")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetDiscoveryPollInterval()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("DiscoveryPollInterval")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetDiscoveryPollInterval(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("DiscoveryPollInterval")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetJwksCacheRefreshPolicy()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("JwksCacheRefreshPolicy")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetJwksCacheRefreshPolicy(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("JwksCacheRefreshPolicy")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if _, err = hasher.Write([]byte("SessionIdHeaderName")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetSessionIdHeaderName())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ParseCallbackPathAsRegex")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetParseCallbackPathAsRegex())
	if err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetAutoMapFromMetadata()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("AutoMapFromMetadata")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetAutoMapFromMetadata(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("AutoMapFromMetadata")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetEndSessionProperties()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("EndSessionProperties")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetEndSessionProperties(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("EndSessionProperties")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetUserSession()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("UserSession")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetUserSession(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("UserSession")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetPkJwtClientAuthenticationConfig()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("PkJwtClientAuthenticationConfig")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetPkJwtClientAuthenticationConfig(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("PkJwtClientAuthenticationConfig")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetAccessToken()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("AccessToken")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetAccessToken(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("AccessToken")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetIdentityToken()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("IdentityToken")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetIdentityToken(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("IdentityToken")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetFrontChannelLogout()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("FrontChannelLogout")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetFrontChannelLogout(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("FrontChannelLogout")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	{
		var result uint64
		innerHash := fnv.New64()
		for k, v := range m.GetDynamicMetadataFromClaims() {
			innerHash.Reset()

			if _, err = innerHash.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(v)); err != nil {
				return 0, err
			}

			if _, err = innerHash.Write([]byte("k")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(k)); err != nil {
				return 0, err
			}

			result = result ^ innerHash.Sum64()
		}
		err = binary.Write(hasher, binary.LittleEndian, result)
		if err != nil {
			return 0, err
		}

	}

	switch m.Provider.(type) {

	case *ExtAuthConfig_OidcAuthorizationCodeConfig_Default_:

		if h, ok := interface{}(m.GetDefault()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("Default")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetDefault(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("Default")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_OidcAuthorizationCodeConfig_Azure:

		if h, ok := interface{}(m.GetAzure()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("Azure")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetAzure(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("Azure")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_AccessTokenValidationConfig) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_AccessTokenValidationConfig")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("UserinfoUrl")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetUserinfoUrl())); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetCacheTimeout()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("CacheTimeout")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetCacheTimeout(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("CacheTimeout")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	{
		var result uint64
		innerHash := fnv.New64()
		for k, v := range m.GetDynamicMetadataFromClaims() {
			innerHash.Reset()

			if _, err = innerHash.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(v)); err != nil {
				return 0, err
			}

			if _, err = innerHash.Write([]byte("k")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(k)); err != nil {
				return 0, err
			}

			result = result ^ innerHash.Sum64()
		}
		err = binary.Write(hasher, binary.LittleEndian, result)
		if err != nil {
			return 0, err
		}

	}

	if _, err = hasher.Write([]byte("ClaimsToHeaders")); err != nil {
		return 0, err
	}
	for i, v := range m.GetClaimsToHeaders() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	switch m.ValidationType.(type) {

	case *ExtAuthConfig_AccessTokenValidationConfig_IntrospectionUrl:

		if _, err = hasher.Write([]byte("IntrospectionUrl")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(m.GetIntrospectionUrl())); err != nil {
			return 0, err
		}

	case *ExtAuthConfig_AccessTokenValidationConfig_Jwt:

		if h, ok := interface{}(m.GetJwt()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("Jwt")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetJwt(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("Jwt")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_AccessTokenValidationConfig_Introspection:

		if h, ok := interface{}(m.GetIntrospection()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("Introspection")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetIntrospection(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("Introspection")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	switch m.ScopeValidation.(type) {

	case *ExtAuthConfig_AccessTokenValidationConfig_RequiredScopes:

		if h, ok := interface{}(m.GetRequiredScopes()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("RequiredScopes")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetRequiredScopes(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("RequiredScopes")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	switch m.Provider.(type) {

	case *ExtAuthConfig_AccessTokenValidationConfig_Default_:

		if h, ok := interface{}(m.GetDefault()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("Default")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetDefault(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("Default")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_AccessTokenValidationConfig_Azure:

		if h, ok := interface{}(m.GetAzure()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("Azure")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetAzure(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("Azure")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_PlainOAuth2Config) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_PlainOAuth2Config")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ClientId")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetClientId())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ClientSecret")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetClientSecret())); err != nil {
		return 0, err
	}

	{
		var result uint64
		innerHash := fnv.New64()
		for k, v := range m.GetAuthEndpointQueryParams() {
			innerHash.Reset()

			if _, err = innerHash.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(v)); err != nil {
				return 0, err
			}

			if _, err = innerHash.Write([]byte("k")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(k)); err != nil {
				return 0, err
			}

			result = result ^ innerHash.Sum64()
		}
		err = binary.Write(hasher, binary.LittleEndian, result)
		if err != nil {
			return 0, err
		}

	}

	if _, err = hasher.Write([]byte("AppUrl")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetAppUrl())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("CallbackPath")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetCallbackPath())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Scopes")); err != nil {
		return 0, err
	}
	for i, v := range m.GetScopes() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if _, err = hasher.Write([]byte("v")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(v)); err != nil {
			return 0, err
		}

	}

	if h, ok := interface{}(m.GetSession()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Session")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetSession(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Session")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if _, err = hasher.Write([]byte("LogoutPath")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetLogoutPath())); err != nil {
		return 0, err
	}

	{
		var result uint64
		innerHash := fnv.New64()
		for k, v := range m.GetTokenEndpointQueryParams() {
			innerHash.Reset()

			if _, err = innerHash.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(v)); err != nil {
				return 0, err
			}

			if _, err = innerHash.Write([]byte("k")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(k)); err != nil {
				return 0, err
			}

			result = result ^ innerHash.Sum64()
		}
		err = binary.Write(hasher, binary.LittleEndian, result)
		if err != nil {
			return 0, err
		}

	}

	if _, err = hasher.Write([]byte("AfterLogoutUrl")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetAfterLogoutUrl())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("AuthEndpoint")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetAuthEndpoint())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("TokenEndpoint")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetTokenEndpoint())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("RevocationEndpoint")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetRevocationEndpoint())); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetUserSession()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("UserSession")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetUserSession(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("UserSession")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_OAuth2Config) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_OAuth2Config")); err != nil {
		return 0, err
	}

	switch m.OauthType.(type) {

	case *ExtAuthConfig_OAuth2Config_OidcAuthorizationCode:

		if h, ok := interface{}(m.GetOidcAuthorizationCode()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("OidcAuthorizationCode")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetOidcAuthorizationCode(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("OidcAuthorizationCode")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_OAuth2Config_AccessTokenValidationConfig:

		if h, ok := interface{}(m.GetAccessTokenValidationConfig()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("AccessTokenValidationConfig")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetAccessTokenValidationConfig(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("AccessTokenValidationConfig")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_OAuth2Config_Oauth2Config:

		if h, ok := interface{}(m.GetOauth2Config()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("Oauth2Config")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetOauth2Config(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("Oauth2Config")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_ApiKeyAuthConfig) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_ApiKeyAuthConfig")); err != nil {
		return 0, err
	}

	{
		var result uint64
		innerHash := fnv.New64()
		for k, v := range m.GetValidApiKeys() {
			innerHash.Reset()

			if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
				if _, err = innerHash.Write([]byte("v")); err != nil {
					return 0, err
				}
				if _, err = h.Hash(innerHash); err != nil {
					return 0, err
				}
			} else {
				if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
					return 0, err
				} else {
					if _, err = innerHash.Write([]byte("v")); err != nil {
						return 0, err
					}
					if err := binary.Write(innerHash, binary.LittleEndian, fieldValue); err != nil {
						return 0, err
					}
				}
			}

			if _, err = innerHash.Write([]byte("k")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(k)); err != nil {
				return 0, err
			}

			result = result ^ innerHash.Sum64()
		}
		err = binary.Write(hasher, binary.LittleEndian, result)
		if err != nil {
			return 0, err
		}

	}

	if _, err = hasher.Write([]byte("HeaderName")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetHeaderName())); err != nil {
		return 0, err
	}

	{
		var result uint64
		innerHash := fnv.New64()
		for k, v := range m.GetHeadersFromKeyMetadata() {
			innerHash.Reset()

			if _, err = innerHash.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(v)); err != nil {
				return 0, err
			}

			if _, err = innerHash.Write([]byte("k")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(k)); err != nil {
				return 0, err
			}

			result = result ^ innerHash.Sum64()
		}
		err = binary.Write(hasher, binary.LittleEndian, result)
		if err != nil {
			return 0, err
		}

	}

	if _, err = hasher.Write([]byte("SkipMetadataValidation")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetSkipMetadataValidation())
	if err != nil {
		return 0, err
	}

	switch m.StorageBackend.(type) {

	case *ExtAuthConfig_ApiKeyAuthConfig_K8SSecretApikeyStorage:

		if h, ok := interface{}(m.GetK8SSecretApikeyStorage()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("K8SSecretApikeyStorage")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetK8SSecretApikeyStorage(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("K8SSecretApikeyStorage")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_ApiKeyAuthConfig_AerospikeApikeyStorage:

		if h, ok := interface{}(m.GetAerospikeApikeyStorage()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("AerospikeApikeyStorage")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetAerospikeApikeyStorage(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("AerospikeApikeyStorage")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_ApiKeyAuthConfig_ServerDefaultApikeyStorage:

		if h, ok := interface{}(m.GetServerDefaultApikeyStorage()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("ServerDefaultApikeyStorage")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetServerDefaultApikeyStorage(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("ServerDefaultApikeyStorage")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_OpaAuthConfig) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_OpaAuthConfig")); err != nil {
		return 0, err
	}

	{
		var result uint64
		innerHash := fnv.New64()
		for k, v := range m.GetModules() {
			innerHash.Reset()

			if _, err = innerHash.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(v)); err != nil {
				return 0, err
			}

			if _, err = innerHash.Write([]byte("k")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(k)); err != nil {
				return 0, err
			}

			result = result ^ innerHash.Sum64()
		}
		err = binary.Write(hasher, binary.LittleEndian, result)
		if err != nil {
			return 0, err
		}

	}

	if _, err = hasher.Write([]byte("Query")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetQuery())); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetOptions()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Options")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetOptions(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Options")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_OpaServerAuthConfig) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_OpaServerAuthConfig")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Package")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetPackage())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("RuleName")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetRuleName())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ServerAddr")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetServerAddr())); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetOptions()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Options")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetOptions(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Options")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_LdapConfig) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_LdapConfig")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Address")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetAddress())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("UserDnTemplate")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetUserDnTemplate())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("MembershipAttributeName")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetMembershipAttributeName())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("AllowedGroups")); err != nil {
		return 0, err
	}
	for i, v := range m.GetAllowedGroups() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if _, err = hasher.Write([]byte("v")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(v)); err != nil {
			return 0, err
		}

	}

	if h, ok := interface{}(m.GetPool()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Pool")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetPool(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Pool")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if _, err = hasher.Write([]byte("SearchFilter")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetSearchFilter())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("DisableGroupChecking")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetDisableGroupChecking())
	if err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetGroupLookupSettings()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("GroupLookupSettings")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetGroupLookupSettings(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("GroupLookupSettings")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_LdapServiceAccountConfig) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_LdapServiceAccountConfig")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Username")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetUsername())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Password")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetPassword())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("CheckGroupsWithServiceAccount")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetCheckGroupsWithServiceAccount())
	if err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_HmacAuthConfig) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_HmacAuthConfig")); err != nil {
		return 0, err
	}

	switch m.SecretStorage.(type) {

	case *ExtAuthConfig_HmacAuthConfig_SecretList:

		if h, ok := interface{}(m.GetSecretList()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("SecretList")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetSecretList(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("SecretList")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	switch m.ImplementationType.(type) {

	case *ExtAuthConfig_HmacAuthConfig_ParametersInHeaders:

		if h, ok := interface{}(m.GetParametersInHeaders()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("ParametersInHeaders")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetParametersInHeaders(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("ParametersInHeaders")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_PortalAuthConfig) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_PortalAuthConfig")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Url")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetUrl())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ApiKeyHeader")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetApiKeyHeader())); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetRedisOptions()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("RedisOptions")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetRedisOptions(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("RedisOptions")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetCacheDuration()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("CacheDuration")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetCacheDuration(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("CacheDuration")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetRequestTimeout()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("RequestTimeout")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetRequestTimeout(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("RequestTimeout")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_InMemorySecretList) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_InMemorySecretList")); err != nil {
		return 0, err
	}

	{
		var result uint64
		innerHash := fnv.New64()
		for k, v := range m.GetSecretList() {
			innerHash.Reset()

			if _, err = innerHash.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(v)); err != nil {
				return 0, err
			}

			if _, err = innerHash.Write([]byte("k")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(k)); err != nil {
				return 0, err
			}

			result = result ^ innerHash.Sum64()
		}
		err = binary.Write(hasher, binary.LittleEndian, result)
		if err != nil {
			return 0, err
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_Config) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_Config")); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetName()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Name")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetName(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Name")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	switch m.AuthConfig.(type) {

	case *ExtAuthConfig_Config_Oauth:

		if h, ok := interface{}(m.GetOauth()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("Oauth")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetOauth(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("Oauth")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_Config_Oauth2:

		if h, ok := interface{}(m.GetOauth2()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("Oauth2")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetOauth2(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("Oauth2")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_Config_BasicAuth:

		if h, ok := interface{}(m.GetBasicAuth()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("BasicAuth")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetBasicAuth(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("BasicAuth")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_Config_BasicAuthInternal:

		if h, ok := interface{}(m.GetBasicAuthInternal()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("BasicAuthInternal")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetBasicAuthInternal(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("BasicAuthInternal")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_Config_ApiKeyAuth:

		if h, ok := interface{}(m.GetApiKeyAuth()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("ApiKeyAuth")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetApiKeyAuth(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("ApiKeyAuth")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_Config_PluginAuth:

		if h, ok := interface{}(m.GetPluginAuth()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("PluginAuth")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetPluginAuth(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("PluginAuth")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_Config_OpaAuth:

		if h, ok := interface{}(m.GetOpaAuth()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("OpaAuth")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetOpaAuth(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("OpaAuth")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_Config_Ldap:

		if h, ok := interface{}(m.GetLdap()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("Ldap")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetLdap(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("Ldap")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_Config_LdapInternal:

		if h, ok := interface{}(m.GetLdapInternal()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("LdapInternal")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetLdapInternal(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("LdapInternal")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_Config_Jwt:

		if h, ok := interface{}(m.GetJwt()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("Jwt")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetJwt(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("Jwt")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_Config_PassThroughAuth:

		if h, ok := interface{}(m.GetPassThroughAuth()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("PassThroughAuth")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetPassThroughAuth(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("PassThroughAuth")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_Config_HmacAuth:

		if h, ok := interface{}(m.GetHmacAuth()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("HmacAuth")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetHmacAuth(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("HmacAuth")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_Config_OpaServerAuth:

		if h, ok := interface{}(m.GetOpaServerAuth()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("OpaServerAuth")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetOpaServerAuth(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("OpaServerAuth")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_Config_PortalAuth:

		if h, ok := interface{}(m.GetPortalAuth()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("PortalAuth")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetPortalAuth(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("PortalAuth")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_BasicAuthInternal_EncryptionType) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_BasicAuthInternal_EncryptionType")); err != nil {
		return 0, err
	}

	switch m.Algorithm.(type) {

	case *ExtAuthConfig_BasicAuthInternal_EncryptionType_Apr_:

		if h, ok := interface{}(m.GetApr()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("Apr")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetApr(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("Apr")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_BasicAuthInternal_EncryptionType_Sha1_:

		if h, ok := interface{}(m.GetSha1()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("Sha1")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetSha1(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("Sha1")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_BasicAuthInternal_User) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_BasicAuthInternal_User")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Salt")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetSalt())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("HashedPassword")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetHashedPassword())); err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_BasicAuthInternal_UserList) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_BasicAuthInternal_UserList")); err != nil {
		return 0, err
	}

	{
		var result uint64
		innerHash := fnv.New64()
		for k, v := range m.GetUsers() {
			innerHash.Reset()

			if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
				if _, err = innerHash.Write([]byte("v")); err != nil {
					return 0, err
				}
				if _, err = h.Hash(innerHash); err != nil {
					return 0, err
				}
			} else {
				if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
					return 0, err
				} else {
					if _, err = innerHash.Write([]byte("v")); err != nil {
						return 0, err
					}
					if err := binary.Write(innerHash, binary.LittleEndian, fieldValue); err != nil {
						return 0, err
					}
				}
			}

			if _, err = innerHash.Write([]byte("k")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(k)); err != nil {
				return 0, err
			}

			result = result ^ innerHash.Sum64()
		}
		err = binary.Write(hasher, binary.LittleEndian, result)
		if err != nil {
			return 0, err
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_BasicAuthInternal_EncryptionType_Sha1) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_BasicAuthInternal_EncryptionType_Sha1")); err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_BasicAuthInternal_EncryptionType_Apr) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_BasicAuthInternal_EncryptionType_Apr")); err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_UserSessionConfig_CipherConfig) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_UserSessionConfig_CipherConfig")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Key")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetKey())); err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_OidcAuthorizationCodeConfig_PkJwtClientAuthenticationConfig) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_OidcAuthorizationCodeConfig_PkJwtClientAuthenticationConfig")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("SigningKey")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetSigningKey())); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetValidFor()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("ValidFor")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetValidFor(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("ValidFor")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_OidcAuthorizationCodeConfig_AccessToken) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_OidcAuthorizationCodeConfig_AccessToken")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ClaimsToHeaders")); err != nil {
		return 0, err
	}
	for i, v := range m.GetClaimsToHeaders() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_OidcAuthorizationCodeConfig_IdentityToken) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_OidcAuthorizationCodeConfig_IdentityToken")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ClaimsToHeaders")); err != nil {
		return 0, err
	}
	for i, v := range m.GetClaimsToHeaders() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_OidcAuthorizationCodeConfig_Default) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_OidcAuthorizationCodeConfig_Default")); err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_OidcAuthorizationCodeConfig_FrontChannelLogout) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_OidcAuthorizationCodeConfig_FrontChannelLogout")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Path")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetPath())); err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_AccessTokenValidationConfig_JwtValidation) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_AccessTokenValidationConfig_JwtValidation")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Issuer")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetIssuer())); err != nil {
		return 0, err
	}

	switch m.JwksSourceSpecifier.(type) {

	case *ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_RemoteJwks_:

		if h, ok := interface{}(m.GetRemoteJwks()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("RemoteJwks")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetRemoteJwks(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("RemoteJwks")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_LocalJwks_:

		if h, ok := interface{}(m.GetLocalJwks()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("LocalJwks")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetLocalJwks(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("LocalJwks")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_AccessTokenValidationConfig_IntrospectionValidation) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_AccessTokenValidationConfig_IntrospectionValidation")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("IntrospectionUrl")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetIntrospectionUrl())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ClientId")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetClientId())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ClientSecret")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetClientSecret())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("UserIdAttributeName")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetUserIdAttributeName())); err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_AccessTokenValidationConfig_ScopeList) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_AccessTokenValidationConfig_ScopeList")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Scope")); err != nil {
		return 0, err
	}
	for i, v := range m.GetScope() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if _, err = hasher.Write([]byte("v")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(v)); err != nil {
			return 0, err
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_AccessTokenValidationConfig_Default) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_AccessTokenValidationConfig_Default")); err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_RemoteJwks) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_RemoteJwks")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Url")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetUrl())); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetRefreshInterval()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("RefreshInterval")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetRefreshInterval(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("RefreshInterval")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_LocalJwks) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_LocalJwks")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("InlineString")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetInlineString())); err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *ExtAuthConfig_ApiKeyAuthConfig_KeyMetadata) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("enterprise.gloo.solo.io.github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1.ExtAuthConfig_ApiKeyAuthConfig_KeyMetadata")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Username")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetUsername())); err != nil {
		return 0, err
	}

	{
		var result uint64
		innerHash := fnv.New64()
		for k, v := range m.GetMetadata() {
			innerHash.Reset()

			if _, err = innerHash.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(v)); err != nil {
				return 0, err
			}

			if _, err = innerHash.Write([]byte("k")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(k)); err != nil {
				return 0, err
			}

			result = result ^ innerHash.Sum64()
		}
		err = binary.Write(hasher, binary.LittleEndian, result)
		if err != nil {
			return 0, err
		}

	}

	return hasher.Sum64(), nil
}
