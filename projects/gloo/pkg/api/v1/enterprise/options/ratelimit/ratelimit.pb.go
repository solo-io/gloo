// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/solo-io/gloo/projects/gloo/api/v1/enterprise/options/ratelimit/ratelimit.proto

package ratelimit

import (
	bytes "bytes"
	fmt "fmt"
	math "math"
	time "time"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	_ "github.com/solo-io/protoc-gen-ext/extproto"
	core "github.com/solo-io/solo-kit/pkg/api/v1/resources/core"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type RateLimit_Unit int32

const (
	RateLimit_UNKNOWN RateLimit_Unit = 0
	RateLimit_SECOND  RateLimit_Unit = 1
	RateLimit_MINUTE  RateLimit_Unit = 2
	RateLimit_HOUR    RateLimit_Unit = 3
	RateLimit_DAY     RateLimit_Unit = 4
)

var RateLimit_Unit_name = map[int32]string{
	0: "UNKNOWN",
	1: "SECOND",
	2: "MINUTE",
	3: "HOUR",
	4: "DAY",
}

var RateLimit_Unit_value = map[string]int32{
	"UNKNOWN": 0,
	"SECOND":  1,
	"MINUTE":  2,
	"HOUR":    3,
	"DAY":     4,
}

func (x RateLimit_Unit) String() string {
	return proto.EnumName(RateLimit_Unit_name, int32(x))
}

func (RateLimit_Unit) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e05a2dad65f2418a, []int{1, 0}
}

// Descriptors can be nested for your convenience and flexibility
type Descriptor struct {
	Key         string        `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value       string        `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	RateLimit   *RateLimit    `protobuf:"bytes,3,opt,name=rate_limit,json=rateLimit,proto3" json:"rate_limit,omitempty"`
	Descriptors []*Descriptor `protobuf:"bytes,4,rep,name=descriptors,proto3" json:"descriptors,omitempty"`
	// Each top-level Descriptor defines a new Rate Limit "rule". When a request comes in, rate limit
	// actions are applied to the request to generate descriptor tuples that are sent to the rate limit
	// server. If any rule is triggered then the entire request returns HTTP 429 Too Many Requests.
	//
	// Typically, rule priority is signalled by nesting descriptors, as the most specific rule match for
	// the descriptor tuple generated by the rate limit actions is used. In rare cases this is too restrictive;
	// instead you can set rule priority by setting weights on your descriptors.
	//
	// All rules with the highest weight are processed, if any of these rules trigger rate limiting then the
	// entire request will return a 429. Rules that are not considered for rate limiting are ignored in the
	// rate limit server, and their request count is not incremented in the rate limit server cache.
	//
	// Defaults to 0; thus all rules are evaluated by default.
	Weight uint32 `protobuf:"varint,5,opt,name=weight,proto3" json:"weight,omitempty"`
	// A boolean override for rule priority via weighted rules. Any rule with `alwaysApply` set to `true` will
	// always be considered for rate limiting, regardless of the rule's weight. The rule with the highest weight
	// will still be considered. (this can be a rule that also has `alwaysApply` set to `true`)
	//
	// Defaults to false.
	AlwaysApply          bool     `protobuf:"varint,6,opt,name=always_apply,json=alwaysApply,proto3" json:"always_apply,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Descriptor) Reset()         { *m = Descriptor{} }
func (m *Descriptor) String() string { return proto.CompactTextString(m) }
func (*Descriptor) ProtoMessage()    {}
func (*Descriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_e05a2dad65f2418a, []int{0}
}
func (m *Descriptor) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Descriptor.Unmarshal(m, b)
}
func (m *Descriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Descriptor.Marshal(b, m, deterministic)
}
func (m *Descriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Descriptor.Merge(m, src)
}
func (m *Descriptor) XXX_Size() int {
	return xxx_messageInfo_Descriptor.Size(m)
}
func (m *Descriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_Descriptor.DiscardUnknown(m)
}

var xxx_messageInfo_Descriptor proto.InternalMessageInfo

func (m *Descriptor) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Descriptor) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Descriptor) GetRateLimit() *RateLimit {
	if m != nil {
		return m.RateLimit
	}
	return nil
}

func (m *Descriptor) GetDescriptors() []*Descriptor {
	if m != nil {
		return m.Descriptors
	}
	return nil
}

func (m *Descriptor) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *Descriptor) GetAlwaysApply() bool {
	if m != nil {
		return m.AlwaysApply
	}
	return false
}

type RateLimit struct {
	Unit                 RateLimit_Unit `protobuf:"varint,1,opt,name=unit,proto3,enum=ratelimit.options.gloo.solo.io.RateLimit_Unit" json:"unit,omitempty"`
	RequestsPerUnit      uint32         `protobuf:"varint,2,opt,name=requests_per_unit,json=requestsPerUnit,proto3" json:"requests_per_unit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *RateLimit) Reset()         { *m = RateLimit{} }
func (m *RateLimit) String() string { return proto.CompactTextString(m) }
func (*RateLimit) ProtoMessage()    {}
func (*RateLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_e05a2dad65f2418a, []int{1}
}
func (m *RateLimit) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RateLimit.Unmarshal(m, b)
}
func (m *RateLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RateLimit.Marshal(b, m, deterministic)
}
func (m *RateLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimit.Merge(m, src)
}
func (m *RateLimit) XXX_Size() int {
	return xxx_messageInfo_RateLimit.Size(m)
}
func (m *RateLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimit.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimit proto.InternalMessageInfo

func (m *RateLimit) GetUnit() RateLimit_Unit {
	if m != nil {
		return m.Unit
	}
	return RateLimit_UNKNOWN
}

func (m *RateLimit) GetRequestsPerUnit() uint32 {
	if m != nil {
		return m.RequestsPerUnit
	}
	return 0
}

// Basic rate-limiting API
type IngressRateLimit struct {
	AuthorizedLimits     *RateLimit `protobuf:"bytes,1,opt,name=authorized_limits,json=authorizedLimits,proto3" json:"authorized_limits,omitempty"`
	AnonymousLimits      *RateLimit `protobuf:"bytes,2,opt,name=anonymous_limits,json=anonymousLimits,proto3" json:"anonymous_limits,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *IngressRateLimit) Reset()         { *m = IngressRateLimit{} }
func (m *IngressRateLimit) String() string { return proto.CompactTextString(m) }
func (*IngressRateLimit) ProtoMessage()    {}
func (*IngressRateLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_e05a2dad65f2418a, []int{2}
}
func (m *IngressRateLimit) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IngressRateLimit.Unmarshal(m, b)
}
func (m *IngressRateLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IngressRateLimit.Marshal(b, m, deterministic)
}
func (m *IngressRateLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngressRateLimit.Merge(m, src)
}
func (m *IngressRateLimit) XXX_Size() int {
	return xxx_messageInfo_IngressRateLimit.Size(m)
}
func (m *IngressRateLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_IngressRateLimit.DiscardUnknown(m)
}

var xxx_messageInfo_IngressRateLimit proto.InternalMessageInfo

func (m *IngressRateLimit) GetAuthorizedLimits() *RateLimit {
	if m != nil {
		return m.AuthorizedLimits
	}
	return nil
}

func (m *IngressRateLimit) GetAnonymousLimits() *RateLimit {
	if m != nil {
		return m.AnonymousLimits
	}
	return nil
}

type Settings struct {
	RatelimitServerRef *core.ResourceRef `protobuf:"bytes,1,opt,name=ratelimit_server_ref,json=ratelimitServerRef,proto3" json:"ratelimit_server_ref,omitempty"`
	RequestTimeout     *time.Duration    `protobuf:"bytes,2,opt,name=request_timeout,json=requestTimeout,proto3,stdduration" json:"request_timeout,omitempty"`
	DenyOnFail         bool              `protobuf:"varint,3,opt,name=deny_on_fail,json=denyOnFail,proto3" json:"deny_on_fail,omitempty"`
	// Set this is set to true if you would like to rate limit traffic before applying external auth to it.
	// *Note*: When this is true, you will lose some features like being able to rate limit a request based on its auth state
	RateLimitBeforeAuth  bool     `protobuf:"varint,9,opt,name=rate_limit_before_auth,json=rateLimitBeforeAuth,proto3" json:"rate_limit_before_auth,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Settings) Reset()         { *m = Settings{} }
func (m *Settings) String() string { return proto.CompactTextString(m) }
func (*Settings) ProtoMessage()    {}
func (*Settings) Descriptor() ([]byte, []int) {
	return fileDescriptor_e05a2dad65f2418a, []int{3}
}
func (m *Settings) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Settings.Unmarshal(m, b)
}
func (m *Settings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Settings.Marshal(b, m, deterministic)
}
func (m *Settings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Settings.Merge(m, src)
}
func (m *Settings) XXX_Size() int {
	return xxx_messageInfo_Settings.Size(m)
}
func (m *Settings) XXX_DiscardUnknown() {
	xxx_messageInfo_Settings.DiscardUnknown(m)
}

var xxx_messageInfo_Settings proto.InternalMessageInfo

func (m *Settings) GetRatelimitServerRef() *core.ResourceRef {
	if m != nil {
		return m.RatelimitServerRef
	}
	return nil
}

func (m *Settings) GetRequestTimeout() *time.Duration {
	if m != nil {
		return m.RequestTimeout
	}
	return nil
}

func (m *Settings) GetDenyOnFail() bool {
	if m != nil {
		return m.DenyOnFail
	}
	return false
}

func (m *Settings) GetRateLimitBeforeAuth() bool {
	if m != nil {
		return m.RateLimitBeforeAuth
	}
	return false
}

// API based on Envoy's rate-limit service API. (reference here: https://github.com/lyft/ratelimit#configuration)
// Sample configuration below
//
// descriptors:
//- key: account_id
//  descriptors:
//  - key: plan
//    value: BASIC
//    rateLimit:
//      requestsPerUnit: 1
//      unit: MINUTE
//  - key: plan
//    value: PLUS
//    rateLimit:
//      requestsPerUnit: 20
//      unit: MINUTE
type ServiceSettings struct {
	Descriptors          []*Descriptor `protobuf:"bytes,1,rep,name=descriptors,proto3" json:"descriptors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ServiceSettings) Reset()         { *m = ServiceSettings{} }
func (m *ServiceSettings) String() string { return proto.CompactTextString(m) }
func (*ServiceSettings) ProtoMessage()    {}
func (*ServiceSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_e05a2dad65f2418a, []int{4}
}
func (m *ServiceSettings) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServiceSettings.Unmarshal(m, b)
}
func (m *ServiceSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServiceSettings.Marshal(b, m, deterministic)
}
func (m *ServiceSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceSettings.Merge(m, src)
}
func (m *ServiceSettings) XXX_Size() int {
	return xxx_messageInfo_ServiceSettings.Size(m)
}
func (m *ServiceSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceSettings.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceSettings proto.InternalMessageInfo

func (m *ServiceSettings) GetDescriptors() []*Descriptor {
	if m != nil {
		return m.Descriptors
	}
	return nil
}

type RateLimitActions struct {
	// descriptors:
	//- key: account_id
	//  descriptors:
	//  - key: plan
	//    value: BASIC
	//    rateLimit:
	//      requestsPerUnit: 1
	//      unit: MINUTE
	//  - key: plan
	//    value: PLUS
	//    rateLimit:
	//      requestsPerUnit: 20
	//      unit: MINUTE
	Actions              []*Action `protobuf:"bytes,2,rep,name=actions,proto3" json:"actions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *RateLimitActions) Reset()         { *m = RateLimitActions{} }
func (m *RateLimitActions) String() string { return proto.CompactTextString(m) }
func (*RateLimitActions) ProtoMessage()    {}
func (*RateLimitActions) Descriptor() ([]byte, []int) {
	return fileDescriptor_e05a2dad65f2418a, []int{5}
}
func (m *RateLimitActions) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RateLimitActions.Unmarshal(m, b)
}
func (m *RateLimitActions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RateLimitActions.Marshal(b, m, deterministic)
}
func (m *RateLimitActions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitActions.Merge(m, src)
}
func (m *RateLimitActions) XXX_Size() int {
	return xxx_messageInfo_RateLimitActions.Size(m)
}
func (m *RateLimitActions) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitActions.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitActions proto.InternalMessageInfo

func (m *RateLimitActions) GetActions() []*Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

type RateLimitVhostExtension struct {
	// Define individual rate limits here. Each rate limit will be evaluated, if any rate limit
	// would be throttled, the entire request returns a 429 (gets throttled)
	RateLimits           []*RateLimitActions `protobuf:"bytes,1,rep,name=rate_limits,json=rateLimits,proto3" json:"rate_limits,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *RateLimitVhostExtension) Reset()         { *m = RateLimitVhostExtension{} }
func (m *RateLimitVhostExtension) String() string { return proto.CompactTextString(m) }
func (*RateLimitVhostExtension) ProtoMessage()    {}
func (*RateLimitVhostExtension) Descriptor() ([]byte, []int) {
	return fileDescriptor_e05a2dad65f2418a, []int{6}
}
func (m *RateLimitVhostExtension) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RateLimitVhostExtension.Unmarshal(m, b)
}
func (m *RateLimitVhostExtension) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RateLimitVhostExtension.Marshal(b, m, deterministic)
}
func (m *RateLimitVhostExtension) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitVhostExtension.Merge(m, src)
}
func (m *RateLimitVhostExtension) XXX_Size() int {
	return xxx_messageInfo_RateLimitVhostExtension.Size(m)
}
func (m *RateLimitVhostExtension) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitVhostExtension.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitVhostExtension proto.InternalMessageInfo

func (m *RateLimitVhostExtension) GetRateLimits() []*RateLimitActions {
	if m != nil {
		return m.RateLimits
	}
	return nil
}

type RateLimitRouteExtension struct {
	// Whether or not to include rate limits as defined on the VirtualHost in addition to rate limits on the Route
	IncludeVhRateLimits bool `protobuf:"varint,1,opt,name=include_vh_rate_limits,json=includeVhRateLimits,proto3" json:"include_vh_rate_limits,omitempty"`
	// Define individual rate limits here. Each rate limit will be evaluated, if any rate limit
	// would be throttled, the entire request returns a 429 (gets throttled)
	RateLimits           []*RateLimitActions `protobuf:"bytes,2,rep,name=rate_limits,json=rateLimits,proto3" json:"rate_limits,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *RateLimitRouteExtension) Reset()         { *m = RateLimitRouteExtension{} }
func (m *RateLimitRouteExtension) String() string { return proto.CompactTextString(m) }
func (*RateLimitRouteExtension) ProtoMessage()    {}
func (*RateLimitRouteExtension) Descriptor() ([]byte, []int) {
	return fileDescriptor_e05a2dad65f2418a, []int{7}
}
func (m *RateLimitRouteExtension) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RateLimitRouteExtension.Unmarshal(m, b)
}
func (m *RateLimitRouteExtension) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RateLimitRouteExtension.Marshal(b, m, deterministic)
}
func (m *RateLimitRouteExtension) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitRouteExtension.Merge(m, src)
}
func (m *RateLimitRouteExtension) XXX_Size() int {
	return xxx_messageInfo_RateLimitRouteExtension.Size(m)
}
func (m *RateLimitRouteExtension) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitRouteExtension.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitRouteExtension proto.InternalMessageInfo

func (m *RateLimitRouteExtension) GetIncludeVhRateLimits() bool {
	if m != nil {
		return m.IncludeVhRateLimits
	}
	return false
}

func (m *RateLimitRouteExtension) GetRateLimits() []*RateLimitActions {
	if m != nil {
		return m.RateLimits
	}
	return nil
}

// TODO(yuval-k): copied from envoy; will be removed and imported properly in a future when we vendor protos
type Action struct {
	// Types that are valid to be assigned to ActionSpecifier:
	//	*Action_SourceCluster_
	//	*Action_DestinationCluster_
	//	*Action_RequestHeaders_
	//	*Action_RemoteAddress_
	//	*Action_GenericKey_
	//	*Action_HeaderValueMatch_
	ActionSpecifier      isAction_ActionSpecifier `protobuf_oneof:"action_specifier"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Action) Reset()         { *m = Action{} }
func (m *Action) String() string { return proto.CompactTextString(m) }
func (*Action) ProtoMessage()    {}
func (*Action) Descriptor() ([]byte, []int) {
	return fileDescriptor_e05a2dad65f2418a, []int{8}
}
func (m *Action) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Action.Unmarshal(m, b)
}
func (m *Action) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Action.Marshal(b, m, deterministic)
}
func (m *Action) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action.Merge(m, src)
}
func (m *Action) XXX_Size() int {
	return xxx_messageInfo_Action.Size(m)
}
func (m *Action) XXX_DiscardUnknown() {
	xxx_messageInfo_Action.DiscardUnknown(m)
}

var xxx_messageInfo_Action proto.InternalMessageInfo

type isAction_ActionSpecifier interface {
	isAction_ActionSpecifier()
	Equal(interface{}) bool
}

type Action_SourceCluster_ struct {
	SourceCluster *Action_SourceCluster `protobuf:"bytes,1,opt,name=source_cluster,json=sourceCluster,proto3,oneof" json:"source_cluster,omitempty"`
}
type Action_DestinationCluster_ struct {
	DestinationCluster *Action_DestinationCluster `protobuf:"bytes,2,opt,name=destination_cluster,json=destinationCluster,proto3,oneof" json:"destination_cluster,omitempty"`
}
type Action_RequestHeaders_ struct {
	RequestHeaders *Action_RequestHeaders `protobuf:"bytes,3,opt,name=request_headers,json=requestHeaders,proto3,oneof" json:"request_headers,omitempty"`
}
type Action_RemoteAddress_ struct {
	RemoteAddress *Action_RemoteAddress `protobuf:"bytes,4,opt,name=remote_address,json=remoteAddress,proto3,oneof" json:"remote_address,omitempty"`
}
type Action_GenericKey_ struct {
	GenericKey *Action_GenericKey `protobuf:"bytes,5,opt,name=generic_key,json=genericKey,proto3,oneof" json:"generic_key,omitempty"`
}
type Action_HeaderValueMatch_ struct {
	HeaderValueMatch *Action_HeaderValueMatch `protobuf:"bytes,6,opt,name=header_value_match,json=headerValueMatch,proto3,oneof" json:"header_value_match,omitempty"`
}

func (*Action_SourceCluster_) isAction_ActionSpecifier()      {}
func (*Action_DestinationCluster_) isAction_ActionSpecifier() {}
func (*Action_RequestHeaders_) isAction_ActionSpecifier()     {}
func (*Action_RemoteAddress_) isAction_ActionSpecifier()      {}
func (*Action_GenericKey_) isAction_ActionSpecifier()         {}
func (*Action_HeaderValueMatch_) isAction_ActionSpecifier()   {}

func (m *Action) GetActionSpecifier() isAction_ActionSpecifier {
	if m != nil {
		return m.ActionSpecifier
	}
	return nil
}

func (m *Action) GetSourceCluster() *Action_SourceCluster {
	if x, ok := m.GetActionSpecifier().(*Action_SourceCluster_); ok {
		return x.SourceCluster
	}
	return nil
}

func (m *Action) GetDestinationCluster() *Action_DestinationCluster {
	if x, ok := m.GetActionSpecifier().(*Action_DestinationCluster_); ok {
		return x.DestinationCluster
	}
	return nil
}

func (m *Action) GetRequestHeaders() *Action_RequestHeaders {
	if x, ok := m.GetActionSpecifier().(*Action_RequestHeaders_); ok {
		return x.RequestHeaders
	}
	return nil
}

func (m *Action) GetRemoteAddress() *Action_RemoteAddress {
	if x, ok := m.GetActionSpecifier().(*Action_RemoteAddress_); ok {
		return x.RemoteAddress
	}
	return nil
}

func (m *Action) GetGenericKey() *Action_GenericKey {
	if x, ok := m.GetActionSpecifier().(*Action_GenericKey_); ok {
		return x.GenericKey
	}
	return nil
}

func (m *Action) GetHeaderValueMatch() *Action_HeaderValueMatch {
	if x, ok := m.GetActionSpecifier().(*Action_HeaderValueMatch_); ok {
		return x.HeaderValueMatch
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Action) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Action_SourceCluster_)(nil),
		(*Action_DestinationCluster_)(nil),
		(*Action_RequestHeaders_)(nil),
		(*Action_RemoteAddress_)(nil),
		(*Action_GenericKey_)(nil),
		(*Action_HeaderValueMatch_)(nil),
	}
}

// The following descriptor entry is appended to the descriptor:
//
// .. code-block:: cpp
//
//   ("source_cluster", "<local service cluster>")
//
// <local service cluster> is derived from the :option:`--service-cluster` option.
type Action_SourceCluster struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Action_SourceCluster) Reset()         { *m = Action_SourceCluster{} }
func (m *Action_SourceCluster) String() string { return proto.CompactTextString(m) }
func (*Action_SourceCluster) ProtoMessage()    {}
func (*Action_SourceCluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_e05a2dad65f2418a, []int{8, 0}
}
func (m *Action_SourceCluster) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Action_SourceCluster.Unmarshal(m, b)
}
func (m *Action_SourceCluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Action_SourceCluster.Marshal(b, m, deterministic)
}
func (m *Action_SourceCluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action_SourceCluster.Merge(m, src)
}
func (m *Action_SourceCluster) XXX_Size() int {
	return xxx_messageInfo_Action_SourceCluster.Size(m)
}
func (m *Action_SourceCluster) XXX_DiscardUnknown() {
	xxx_messageInfo_Action_SourceCluster.DiscardUnknown(m)
}

var xxx_messageInfo_Action_SourceCluster proto.InternalMessageInfo

// The following descriptor entry is appended to the descriptor:
//
// .. code-block:: cpp
//
//   ("destination_cluster", "<routed target cluster>")
//
// Once a request matches against a route table rule, a routed cluster is determined by one of
// the following :ref:`route table configuration <envoy_api_msg_RouteConfiguration>`
// settings:
//
// * :ref:`cluster <envoy_api_field_route.RouteAction.cluster>` indicates the upstream cluster
//   to route to.
// * :ref:`weighted_clusters <envoy_api_field_route.RouteAction.weighted_clusters>`
//   chooses a cluster randomly from a set of clusters with attributed weight.
// * :ref:`cluster_header <envoy_api_field_route.RouteAction.cluster_header>` indicates which
//   header in the request contains the target cluster.
type Action_DestinationCluster struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Action_DestinationCluster) Reset()         { *m = Action_DestinationCluster{} }
func (m *Action_DestinationCluster) String() string { return proto.CompactTextString(m) }
func (*Action_DestinationCluster) ProtoMessage()    {}
func (*Action_DestinationCluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_e05a2dad65f2418a, []int{8, 1}
}
func (m *Action_DestinationCluster) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Action_DestinationCluster.Unmarshal(m, b)
}
func (m *Action_DestinationCluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Action_DestinationCluster.Marshal(b, m, deterministic)
}
func (m *Action_DestinationCluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action_DestinationCluster.Merge(m, src)
}
func (m *Action_DestinationCluster) XXX_Size() int {
	return xxx_messageInfo_Action_DestinationCluster.Size(m)
}
func (m *Action_DestinationCluster) XXX_DiscardUnknown() {
	xxx_messageInfo_Action_DestinationCluster.DiscardUnknown(m)
}

var xxx_messageInfo_Action_DestinationCluster proto.InternalMessageInfo

// The following descriptor entry is appended when a header contains a key that matches the
// *header_name*:
//
// .. code-block:: cpp
//
//   ("<descriptor_key>", "<header_value_queried_from_header>")
type Action_RequestHeaders struct {
	// The header name to be queried from the request headers. The header’s
	// value is used to populate the value of the descriptor entry for the
	// descriptor_key.
	HeaderName string `protobuf:"bytes,1,opt,name=header_name,json=headerName,proto3" json:"header_name,omitempty"`
	// The key to use in the descriptor entry.
	DescriptorKey        string   `protobuf:"bytes,2,opt,name=descriptor_key,json=descriptorKey,proto3" json:"descriptor_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Action_RequestHeaders) Reset()         { *m = Action_RequestHeaders{} }
func (m *Action_RequestHeaders) String() string { return proto.CompactTextString(m) }
func (*Action_RequestHeaders) ProtoMessage()    {}
func (*Action_RequestHeaders) Descriptor() ([]byte, []int) {
	return fileDescriptor_e05a2dad65f2418a, []int{8, 2}
}
func (m *Action_RequestHeaders) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Action_RequestHeaders.Unmarshal(m, b)
}
func (m *Action_RequestHeaders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Action_RequestHeaders.Marshal(b, m, deterministic)
}
func (m *Action_RequestHeaders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action_RequestHeaders.Merge(m, src)
}
func (m *Action_RequestHeaders) XXX_Size() int {
	return xxx_messageInfo_Action_RequestHeaders.Size(m)
}
func (m *Action_RequestHeaders) XXX_DiscardUnknown() {
	xxx_messageInfo_Action_RequestHeaders.DiscardUnknown(m)
}

var xxx_messageInfo_Action_RequestHeaders proto.InternalMessageInfo

func (m *Action_RequestHeaders) GetHeaderName() string {
	if m != nil {
		return m.HeaderName
	}
	return ""
}

func (m *Action_RequestHeaders) GetDescriptorKey() string {
	if m != nil {
		return m.DescriptorKey
	}
	return ""
}

// The following descriptor entry is appended to the descriptor and is populated using the
// trusted address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
//
// .. code-block:: cpp
//
//   ("remote_address", "<trusted address from x-forwarded-for>")
type Action_RemoteAddress struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Action_RemoteAddress) Reset()         { *m = Action_RemoteAddress{} }
func (m *Action_RemoteAddress) String() string { return proto.CompactTextString(m) }
func (*Action_RemoteAddress) ProtoMessage()    {}
func (*Action_RemoteAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_e05a2dad65f2418a, []int{8, 3}
}
func (m *Action_RemoteAddress) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Action_RemoteAddress.Unmarshal(m, b)
}
func (m *Action_RemoteAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Action_RemoteAddress.Marshal(b, m, deterministic)
}
func (m *Action_RemoteAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action_RemoteAddress.Merge(m, src)
}
func (m *Action_RemoteAddress) XXX_Size() int {
	return xxx_messageInfo_Action_RemoteAddress.Size(m)
}
func (m *Action_RemoteAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_Action_RemoteAddress.DiscardUnknown(m)
}

var xxx_messageInfo_Action_RemoteAddress proto.InternalMessageInfo

// The following descriptor entry is appended to the descriptor:
//
// .. code-block:: cpp
//
//   ("generic_key", "<descriptor_value>")
type Action_GenericKey struct {
	// The value to use in the descriptor entry.
	DescriptorValue      string   `protobuf:"bytes,1,opt,name=descriptor_value,json=descriptorValue,proto3" json:"descriptor_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Action_GenericKey) Reset()         { *m = Action_GenericKey{} }
func (m *Action_GenericKey) String() string { return proto.CompactTextString(m) }
func (*Action_GenericKey) ProtoMessage()    {}
func (*Action_GenericKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_e05a2dad65f2418a, []int{8, 4}
}
func (m *Action_GenericKey) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Action_GenericKey.Unmarshal(m, b)
}
func (m *Action_GenericKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Action_GenericKey.Marshal(b, m, deterministic)
}
func (m *Action_GenericKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action_GenericKey.Merge(m, src)
}
func (m *Action_GenericKey) XXX_Size() int {
	return xxx_messageInfo_Action_GenericKey.Size(m)
}
func (m *Action_GenericKey) XXX_DiscardUnknown() {
	xxx_messageInfo_Action_GenericKey.DiscardUnknown(m)
}

var xxx_messageInfo_Action_GenericKey proto.InternalMessageInfo

func (m *Action_GenericKey) GetDescriptorValue() string {
	if m != nil {
		return m.DescriptorValue
	}
	return ""
}

// The following descriptor entry is appended to the descriptor:
//
// .. code-block:: cpp
//
//   ("header_match", "<descriptor_value>")
type Action_HeaderValueMatch struct {
	// The value to use in the descriptor entry.
	DescriptorValue string `protobuf:"bytes,1,opt,name=descriptor_value,json=descriptorValue,proto3" json:"descriptor_value,omitempty"`
	// If set to true, the action will append a descriptor entry when the
	// request matches the headers. If set to false, the action will append a
	// descriptor entry when the request does not match the headers. The
	// default value is true.
	ExpectMatch *types.BoolValue `protobuf:"bytes,2,opt,name=expect_match,json=expectMatch,proto3" json:"expect_match,omitempty"`
	// Specifies a set of headers that the rate limit action should match
	// on. The action will check the request’s headers against all the
	// specified headers in the config. A match will happen if all the
	// headers in the config are present in the request with the same values
	// (or based on presence if the value field is not in the config).
	Headers              []*HeaderMatcher `protobuf:"bytes,3,rep,name=headers,proto3" json:"headers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Action_HeaderValueMatch) Reset()         { *m = Action_HeaderValueMatch{} }
func (m *Action_HeaderValueMatch) String() string { return proto.CompactTextString(m) }
func (*Action_HeaderValueMatch) ProtoMessage()    {}
func (*Action_HeaderValueMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_e05a2dad65f2418a, []int{8, 5}
}
func (m *Action_HeaderValueMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Action_HeaderValueMatch.Unmarshal(m, b)
}
func (m *Action_HeaderValueMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Action_HeaderValueMatch.Marshal(b, m, deterministic)
}
func (m *Action_HeaderValueMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action_HeaderValueMatch.Merge(m, src)
}
func (m *Action_HeaderValueMatch) XXX_Size() int {
	return xxx_messageInfo_Action_HeaderValueMatch.Size(m)
}
func (m *Action_HeaderValueMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_Action_HeaderValueMatch.DiscardUnknown(m)
}

var xxx_messageInfo_Action_HeaderValueMatch proto.InternalMessageInfo

func (m *Action_HeaderValueMatch) GetDescriptorValue() string {
	if m != nil {
		return m.DescriptorValue
	}
	return ""
}

func (m *Action_HeaderValueMatch) GetExpectMatch() *types.BoolValue {
	if m != nil {
		return m.ExpectMatch
	}
	return nil
}

func (m *Action_HeaderValueMatch) GetHeaders() []*HeaderMatcher {
	if m != nil {
		return m.Headers
	}
	return nil
}

// Specifies the int64 start and end of the range using half-open interval semantics [start,
// end).
type Int64Range struct {
	// start of the range (inclusive)
	Start int64 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	// end of the range (exclusive)
	End                  int64    `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Int64Range) Reset()         { *m = Int64Range{} }
func (m *Int64Range) String() string { return proto.CompactTextString(m) }
func (*Int64Range) ProtoMessage()    {}
func (*Int64Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_e05a2dad65f2418a, []int{9}
}
func (m *Int64Range) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Int64Range.Unmarshal(m, b)
}
func (m *Int64Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Int64Range.Marshal(b, m, deterministic)
}
func (m *Int64Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Int64Range.Merge(m, src)
}
func (m *Int64Range) XXX_Size() int {
	return xxx_messageInfo_Int64Range.Size(m)
}
func (m *Int64Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Int64Range.DiscardUnknown(m)
}

var xxx_messageInfo_Int64Range proto.InternalMessageInfo

func (m *Int64Range) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Int64Range) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

type HeaderMatcher struct {
	// Specifies the name of the header in the request.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Specifies how the header match will be performed to route the request.
	//
	// Types that are valid to be assigned to HeaderMatchSpecifier:
	//	*HeaderMatcher_ExactMatch
	//	*HeaderMatcher_RegexMatch
	//	*HeaderMatcher_RangeMatch
	//	*HeaderMatcher_PresentMatch
	//	*HeaderMatcher_PrefixMatch
	//	*HeaderMatcher_SuffixMatch
	HeaderMatchSpecifier isHeaderMatcher_HeaderMatchSpecifier `protobuf_oneof:"header_match_specifier"`
	// If specified, the match result will be inverted before checking. Defaults to false.
	//
	// Examples:
	//
	// * The regex *\d{3}* does not match the value *1234*, so it will match when inverted.
	// * The range [-10,0) will match the value -1, so it will not match when inverted.
	InvertMatch          bool     `protobuf:"varint,8,opt,name=invert_match,json=invertMatch,proto3" json:"invert_match,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HeaderMatcher) Reset()         { *m = HeaderMatcher{} }
func (m *HeaderMatcher) String() string { return proto.CompactTextString(m) }
func (*HeaderMatcher) ProtoMessage()    {}
func (*HeaderMatcher) Descriptor() ([]byte, []int) {
	return fileDescriptor_e05a2dad65f2418a, []int{10}
}
func (m *HeaderMatcher) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HeaderMatcher.Unmarshal(m, b)
}
func (m *HeaderMatcher) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HeaderMatcher.Marshal(b, m, deterministic)
}
func (m *HeaderMatcher) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeaderMatcher.Merge(m, src)
}
func (m *HeaderMatcher) XXX_Size() int {
	return xxx_messageInfo_HeaderMatcher.Size(m)
}
func (m *HeaderMatcher) XXX_DiscardUnknown() {
	xxx_messageInfo_HeaderMatcher.DiscardUnknown(m)
}

var xxx_messageInfo_HeaderMatcher proto.InternalMessageInfo

type isHeaderMatcher_HeaderMatchSpecifier interface {
	isHeaderMatcher_HeaderMatchSpecifier()
	Equal(interface{}) bool
}

type HeaderMatcher_ExactMatch struct {
	ExactMatch string `protobuf:"bytes,4,opt,name=exact_match,json=exactMatch,proto3,oneof" json:"exact_match,omitempty"`
}
type HeaderMatcher_RegexMatch struct {
	RegexMatch string `protobuf:"bytes,5,opt,name=regex_match,json=regexMatch,proto3,oneof" json:"regex_match,omitempty"`
}
type HeaderMatcher_RangeMatch struct {
	RangeMatch *Int64Range `protobuf:"bytes,6,opt,name=range_match,json=rangeMatch,proto3,oneof" json:"range_match,omitempty"`
}
type HeaderMatcher_PresentMatch struct {
	PresentMatch bool `protobuf:"varint,7,opt,name=present_match,json=presentMatch,proto3,oneof" json:"present_match,omitempty"`
}
type HeaderMatcher_PrefixMatch struct {
	PrefixMatch string `protobuf:"bytes,9,opt,name=prefix_match,json=prefixMatch,proto3,oneof" json:"prefix_match,omitempty"`
}
type HeaderMatcher_SuffixMatch struct {
	SuffixMatch string `protobuf:"bytes,10,opt,name=suffix_match,json=suffixMatch,proto3,oneof" json:"suffix_match,omitempty"`
}

func (*HeaderMatcher_ExactMatch) isHeaderMatcher_HeaderMatchSpecifier()   {}
func (*HeaderMatcher_RegexMatch) isHeaderMatcher_HeaderMatchSpecifier()   {}
func (*HeaderMatcher_RangeMatch) isHeaderMatcher_HeaderMatchSpecifier()   {}
func (*HeaderMatcher_PresentMatch) isHeaderMatcher_HeaderMatchSpecifier() {}
func (*HeaderMatcher_PrefixMatch) isHeaderMatcher_HeaderMatchSpecifier()  {}
func (*HeaderMatcher_SuffixMatch) isHeaderMatcher_HeaderMatchSpecifier()  {}

func (m *HeaderMatcher) GetHeaderMatchSpecifier() isHeaderMatcher_HeaderMatchSpecifier {
	if m != nil {
		return m.HeaderMatchSpecifier
	}
	return nil
}

func (m *HeaderMatcher) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeaderMatcher) GetExactMatch() string {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcher_ExactMatch); ok {
		return x.ExactMatch
	}
	return ""
}

func (m *HeaderMatcher) GetRegexMatch() string {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcher_RegexMatch); ok {
		return x.RegexMatch
	}
	return ""
}

func (m *HeaderMatcher) GetRangeMatch() *Int64Range {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcher_RangeMatch); ok {
		return x.RangeMatch
	}
	return nil
}

func (m *HeaderMatcher) GetPresentMatch() bool {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcher_PresentMatch); ok {
		return x.PresentMatch
	}
	return false
}

func (m *HeaderMatcher) GetPrefixMatch() string {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcher_PrefixMatch); ok {
		return x.PrefixMatch
	}
	return ""
}

func (m *HeaderMatcher) GetSuffixMatch() string {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcher_SuffixMatch); ok {
		return x.SuffixMatch
	}
	return ""
}

func (m *HeaderMatcher) GetInvertMatch() bool {
	if m != nil {
		return m.InvertMatch
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HeaderMatcher) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HeaderMatcher_ExactMatch)(nil),
		(*HeaderMatcher_RegexMatch)(nil),
		(*HeaderMatcher_RangeMatch)(nil),
		(*HeaderMatcher_PresentMatch)(nil),
		(*HeaderMatcher_PrefixMatch)(nil),
		(*HeaderMatcher_SuffixMatch)(nil),
	}
}

// Query parameter matching treats the query string of a request's :path header
// as an ampersand-separated list of keys and/or key=value elements.
type QueryParameterMatcher struct {
	// Specifies the name of a key that must be present in the requested
	// *path*'s query string.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Specifies the value of the key. If the value is absent, a request
	// that contains the key in its query string will match, whether the
	// key appears with a value (e.g., "?debug=true") or not (e.g., "?debug")
	Value string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	// Specifies whether the query parameter value is a regular expression.
	// Defaults to false. The entire query parameter value (i.e., the part to
	// the right of the equals sign in "key=value") must match the regex.
	// E.g., the regex "\d+$" will match "123" but not "a123" or "123a".
	Regex                *types.BoolValue `protobuf:"bytes,4,opt,name=regex,proto3" json:"regex,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *QueryParameterMatcher) Reset()         { *m = QueryParameterMatcher{} }
func (m *QueryParameterMatcher) String() string { return proto.CompactTextString(m) }
func (*QueryParameterMatcher) ProtoMessage()    {}
func (*QueryParameterMatcher) Descriptor() ([]byte, []int) {
	return fileDescriptor_e05a2dad65f2418a, []int{11}
}
func (m *QueryParameterMatcher) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueryParameterMatcher.Unmarshal(m, b)
}
func (m *QueryParameterMatcher) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueryParameterMatcher.Marshal(b, m, deterministic)
}
func (m *QueryParameterMatcher) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryParameterMatcher.Merge(m, src)
}
func (m *QueryParameterMatcher) XXX_Size() int {
	return xxx_messageInfo_QueryParameterMatcher.Size(m)
}
func (m *QueryParameterMatcher) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryParameterMatcher.DiscardUnknown(m)
}

var xxx_messageInfo_QueryParameterMatcher proto.InternalMessageInfo

func (m *QueryParameterMatcher) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QueryParameterMatcher) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *QueryParameterMatcher) GetRegex() *types.BoolValue {
	if m != nil {
		return m.Regex
	}
	return nil
}

func init() {
	proto.RegisterEnum("ratelimit.options.gloo.solo.io.RateLimit_Unit", RateLimit_Unit_name, RateLimit_Unit_value)
	proto.RegisterType((*Descriptor)(nil), "ratelimit.options.gloo.solo.io.Descriptor")
	proto.RegisterType((*RateLimit)(nil), "ratelimit.options.gloo.solo.io.RateLimit")
	proto.RegisterType((*IngressRateLimit)(nil), "ratelimit.options.gloo.solo.io.IngressRateLimit")
	proto.RegisterType((*Settings)(nil), "ratelimit.options.gloo.solo.io.Settings")
	proto.RegisterType((*ServiceSettings)(nil), "ratelimit.options.gloo.solo.io.ServiceSettings")
	proto.RegisterType((*RateLimitActions)(nil), "ratelimit.options.gloo.solo.io.RateLimitActions")
	proto.RegisterType((*RateLimitVhostExtension)(nil), "ratelimit.options.gloo.solo.io.RateLimitVhostExtension")
	proto.RegisterType((*RateLimitRouteExtension)(nil), "ratelimit.options.gloo.solo.io.RateLimitRouteExtension")
	proto.RegisterType((*Action)(nil), "ratelimit.options.gloo.solo.io.Action")
	proto.RegisterType((*Action_SourceCluster)(nil), "ratelimit.options.gloo.solo.io.Action.SourceCluster")
	proto.RegisterType((*Action_DestinationCluster)(nil), "ratelimit.options.gloo.solo.io.Action.DestinationCluster")
	proto.RegisterType((*Action_RequestHeaders)(nil), "ratelimit.options.gloo.solo.io.Action.RequestHeaders")
	proto.RegisterType((*Action_RemoteAddress)(nil), "ratelimit.options.gloo.solo.io.Action.RemoteAddress")
	proto.RegisterType((*Action_GenericKey)(nil), "ratelimit.options.gloo.solo.io.Action.GenericKey")
	proto.RegisterType((*Action_HeaderValueMatch)(nil), "ratelimit.options.gloo.solo.io.Action.HeaderValueMatch")
	proto.RegisterType((*Int64Range)(nil), "ratelimit.options.gloo.solo.io.Int64Range")
	proto.RegisterType((*HeaderMatcher)(nil), "ratelimit.options.gloo.solo.io.HeaderMatcher")
	proto.RegisterType((*QueryParameterMatcher)(nil), "ratelimit.options.gloo.solo.io.QueryParameterMatcher")
}

func init() {
	proto.RegisterFile("github.com/solo-io/gloo/projects/gloo/api/v1/enterprise/options/ratelimit/ratelimit.proto", fileDescriptor_e05a2dad65f2418a)
}

var fileDescriptor_e05a2dad65f2418a = []byte{
	// 1291 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xdb, 0x6e, 0x1b, 0x45,
	0x18, 0xce, 0xda, 0xce, 0xe9, 0x77, 0x0e, 0xdb, 0x69, 0x08, 0xae, 0x2f, 0xda, 0xd4, 0xa8, 0x28,
	0xad, 0xe8, 0xba, 0x4d, 0x0b, 0x15, 0x17, 0x20, 0xe2, 0xa6, 0xd4, 0x6d, 0x9a, 0xa4, 0xdd, 0x1c,
	0x4a, 0x91, 0xd0, 0xb2, 0xb1, 0x7f, 0xaf, 0x87, 0xae, 0x77, 0x96, 0x99, 0xd9, 0x34, 0xe6, 0x05,
	0x78, 0x05, 0x6e, 0xb9, 0xe3, 0x11, 0x90, 0xb8, 0xe1, 0x86, 0xe7, 0x40, 0xe2, 0x11, 0x90, 0x90,
	0xb8, 0xe0, 0x02, 0xcd, 0xcc, 0x1e, 0x9c, 0x14, 0x1a, 0x47, 0x70, 0xe5, 0x99, 0x6f, 0xff, 0xef,
	0x3f, 0x7c, 0xf3, 0xcf, 0xc1, 0xf0, 0x22, 0xa0, 0xb2, 0x9f, 0x1c, 0x3a, 0x1d, 0x36, 0x68, 0x0a,
	0x16, 0xb2, 0x9b, 0x94, 0x35, 0x83, 0x90, 0xb1, 0x66, 0xcc, 0xd9, 0x57, 0xd8, 0x91, 0xc2, 0xcc,
	0xfc, 0x98, 0x36, 0x8f, 0x6e, 0x37, 0x31, 0x92, 0xc8, 0x63, 0x4e, 0x05, 0x36, 0x59, 0x2c, 0x29,
	0x8b, 0x44, 0x93, 0xfb, 0x12, 0x43, 0x3a, 0xa0, 0xb2, 0x18, 0x39, 0x31, 0x67, 0x92, 0x91, 0xcb,
	0x05, 0x90, 0x1a, 0x3b, 0xca, 0x97, 0xa3, 0xc2, 0x38, 0x94, 0xd5, 0xdf, 0xfb, 0x87, 0xd0, 0xfa,
	0xf7, 0x25, 0x95, 0x59, 0x40, 0x8e, 0x3d, 0xe3, 0xad, 0x7e, 0x39, 0x60, 0x2c, 0x08, 0xb1, 0xa9,
	0x67, 0x87, 0x49, 0xaf, 0xf9, 0x8a, 0xfb, 0x71, 0x8c, 0x5c, 0xfc, 0xdb, 0xf7, 0x6e, 0xc2, 0x7d,
	0x15, 0x35, 0xfd, 0xbe, 0x14, 0xb0, 0x80, 0xe9, 0x61, 0x53, 0x8d, 0x52, 0x94, 0xe0, 0xb1, 0x34,
	0x20, 0x1e, 0xa7, 0x79, 0x37, 0xbe, 0x2d, 0x01, 0x6c, 0xa0, 0xe8, 0x70, 0x1a, 0x4b, 0xc6, 0x89,
	0x0d, 0xe5, 0x97, 0x38, 0xac, 0x59, 0x2b, 0xd6, 0xea, 0xac, 0xab, 0x86, 0x64, 0x09, 0x26, 0x8f,
	0xfc, 0x30, 0xc1, 0x5a, 0x49, 0x63, 0x66, 0x42, 0xda, 0x00, 0xaa, 0x60, 0x4f, 0x57, 0x5c, 0x2b,
	0xaf, 0x58, 0xab, 0xd5, 0xb5, 0xeb, 0xce, 0x9b, 0x35, 0x70, 0x5c, 0x5f, 0xe2, 0x13, 0xf5, 0xd9,
	0x9d, 0xe5, 0xd9, 0x90, 0x3c, 0x81, 0x6a, 0x37, 0x8f, 0x2f, 0x6a, 0x95, 0x95, 0xf2, 0x6a, 0x75,
	0xed, 0xc6, 0x59, 0xae, 0x8a, 0x94, 0xdd, 0x51, 0x3a, 0x59, 0x86, 0xa9, 0x57, 0x48, 0x83, 0xbe,
	0xac, 0x4d, 0xae, 0x58, 0xab, 0xf3, 0x6e, 0x3a, 0x23, 0x57, 0x61, 0xce, 0x0f, 0x5f, 0xf9, 0x43,
	0xe1, 0xf9, 0x71, 0x1c, 0x0e, 0x6b, 0x53, 0x2b, 0xd6, 0xea, 0x8c, 0x5b, 0x35, 0xd8, 0xba, 0x82,
	0x1a, 0x3f, 0x59, 0x30, 0x9b, 0x67, 0x48, 0x5a, 0x50, 0x49, 0x22, 0x2a, 0xb5, 0x12, 0x0b, 0x6b,
	0xce, 0xd8, 0xa5, 0x39, 0xfb, 0x11, 0x95, 0xae, 0xe6, 0x92, 0x1b, 0x70, 0x81, 0xe3, 0xd7, 0x09,
	0x0a, 0x29, 0xbc, 0x18, 0xb9, 0xa7, 0x1d, 0x96, 0x74, 0x5e, 0x8b, 0xd9, 0x87, 0xa7, 0xc8, 0x15,
	0xa3, 0xf1, 0x31, 0x54, 0xd4, 0x2f, 0xa9, 0xc2, 0xf4, 0xfe, 0xf6, 0xe6, 0xf6, 0xce, 0xf3, 0x6d,
	0x7b, 0x82, 0x00, 0x4c, 0xed, 0x3e, 0xb8, 0xbf, 0xb3, 0xbd, 0x61, 0x5b, 0x6a, 0xbc, 0xf5, 0x68,
	0x7b, 0x7f, 0xef, 0x81, 0x5d, 0x22, 0x33, 0x50, 0x69, 0xef, 0xec, 0xbb, 0x76, 0x99, 0x4c, 0x43,
	0x79, 0x63, 0xfd, 0x85, 0x5d, 0x69, 0xfc, 0x6c, 0x81, 0xfd, 0x28, 0x0a, 0x38, 0x0a, 0x51, 0x14,
	0x71, 0x00, 0x17, 0xfc, 0x44, 0xf6, 0x19, 0xa7, 0xdf, 0x60, 0xd7, 0xac, 0x95, 0xd0, 0x15, 0x9d,
	0x6b, 0xb1, 0xec, 0xc2, 0x87, 0x06, 0x04, 0xd9, 0x03, 0xdb, 0x8f, 0x58, 0x34, 0x1c, 0xb0, 0x44,
	0x64, 0x6e, 0x4b, 0xe7, 0x75, 0xbb, 0x98, 0xbb, 0x30, 0x5e, 0x1b, 0x7f, 0x5a, 0x30, 0xb3, 0x8b,
	0x52, 0xd2, 0x28, 0x10, 0x64, 0x13, 0x96, 0x72, 0x4f, 0x9e, 0x40, 0x7e, 0x84, 0xdc, 0xe3, 0xd8,
	0x4b, 0xb3, 0xbf, 0xe4, 0x74, 0x18, 0xc7, 0xc2, 0x29, 0x0a, 0x96, 0xf0, 0x0e, 0xba, 0xd8, 0x73,
	0x49, 0x4e, 0xdb, 0xd5, 0x2c, 0x17, 0x7b, 0xa4, 0x0d, 0x99, 0xde, 0x9e, 0xa4, 0x03, 0x64, 0x89,
	0x4c, 0xd3, 0xbd, 0xe4, 0x98, 0x8d, 0xe4, 0x64, 0x1b, 0xc9, 0xd9, 0x48, 0x37, 0x52, 0xab, 0xf2,
	0xdd, 0xaf, 0x57, 0x2c, 0x77, 0x21, 0xe5, 0xed, 0x19, 0x1a, 0x59, 0x81, 0xb9, 0x2e, 0x46, 0x43,
	0x8f, 0x45, 0x5e, 0xcf, 0xa7, 0xa1, 0xee, 0xfc, 0x19, 0x17, 0x14, 0xb6, 0x13, 0x7d, 0xea, 0xd3,
	0x90, 0xdc, 0x81, 0xe5, 0x62, 0x67, 0x78, 0x87, 0xd8, 0x63, 0x1c, 0x3d, 0xa5, 0x60, 0x6d, 0x56,
	0xdb, 0x5e, 0xcc, 0x5b, 0xbf, 0xa5, 0xbf, 0xad, 0x27, 0xb2, 0xdf, 0xf0, 0x60, 0x51, 0x65, 0x4b,
	0x3b, 0x98, 0x0b, 0x70, 0x6a, 0x5f, 0x58, 0xff, 0x69, 0x5f, 0x34, 0xf6, 0xc0, 0xce, 0x95, 0x5f,
	0xef, 0x68, 0x22, 0xf9, 0x04, 0xa6, 0x7d, 0x33, 0xac, 0x95, 0xb4, 0xf7, 0x77, 0xcf, 0xf2, 0x6e,
	0x98, 0x6e, 0x46, 0x6b, 0x84, 0xf0, 0x76, 0xee, 0xf5, 0xa0, 0xcf, 0x84, 0x7c, 0x70, 0x2c, 0x31,
	0x12, 0x94, 0x45, 0xe4, 0x19, 0x54, 0x0b, 0x19, 0xb2, 0xf4, 0x6f, 0x8d, 0xdd, 0x1d, 0x69, 0x8e,
	0x2e, 0xe4, 0x6a, 0x89, 0xc6, 0xf7, 0xd6, 0x48, 0x38, 0x97, 0x25, 0x12, 0x8b, 0x70, 0x77, 0x60,
	0x99, 0x46, 0x9d, 0x30, 0xe9, 0xa2, 0x77, 0xd4, 0xf7, 0x4e, 0x46, 0xd6, 0xaa, 0xa7, 0x5f, 0x0f,
	0xfa, 0xb9, 0x07, 0x71, 0x3a, 0xc7, 0xd2, 0xff, 0x90, 0xe3, 0x5f, 0xd3, 0x30, 0x65, 0x70, 0xf2,
	0x05, 0x2c, 0x98, 0xae, 0xf4, 0x3a, 0x61, 0x22, 0x24, 0xf2, 0xb4, 0x77, 0xef, 0x8e, 0xa7, 0xb2,
	0xb3, 0xab, 0xc9, 0xf7, 0x0d, 0xb7, 0x3d, 0xe1, 0xce, 0x8b, 0x51, 0x80, 0x84, 0x70, 0xb1, 0x8b,
	0x42, 0xd2, 0x48, 0xb7, 0x6b, 0x1e, 0xc3, 0xf4, 0xf5, 0x87, 0x63, 0xc6, 0xd8, 0x28, 0x3c, 0x14,
	0x81, 0x48, 0xf7, 0x35, 0x94, 0x7c, 0x59, 0xec, 0xa0, 0x3e, 0xfa, 0x5d, 0xe4, 0x22, 0x3d, 0xf4,
	0xdf, 0x1f, 0x33, 0x92, 0x6b, 0xd8, 0x6d, 0x43, 0x6e, 0x4f, 0xe4, 0x3b, 0x2b, 0x45, 0x94, 0x5c,
	0x1c, 0x07, 0x4c, 0xa2, 0xe7, 0x77, 0xbb, 0xea, 0x18, 0xab, 0x55, 0xce, 0x25, 0x97, 0xab, 0xc9,
	0xeb, 0x86, 0xab, 0xe4, 0xe2, 0xa3, 0x00, 0xd9, 0x83, 0x6a, 0x80, 0x11, 0x72, 0xda, 0xf1, 0xd4,
	0x05, 0x37, 0xa9, 0x7d, 0xdf, 0x1e, 0xd3, 0xf7, 0x43, 0xc3, 0xdc, 0xc4, 0x61, 0x7b, 0xc2, 0x85,
	0x20, 0x9f, 0x91, 0x00, 0x88, 0x91, 0xc3, 0xd3, 0xd7, 0xa2, 0x37, 0xf0, 0x65, 0xa7, 0xaf, 0x2f,
	0x97, 0xea, 0xda, 0xbd, 0x31, 0x9d, 0x1b, 0x01, 0x0e, 0x14, 0x7f, 0x4b, 0xd1, 0xdb, 0x13, 0xae,
	0xdd, 0x3f, 0x85, 0xd5, 0x17, 0x61, 0xfe, 0x44, 0x3f, 0xd4, 0x97, 0x80, 0xbc, 0xbe, 0x78, 0xf5,
	0xcf, 0x60, 0xe1, 0xa4, 0xd0, 0xe4, 0x0a, 0x54, 0xd3, 0x0c, 0x23, 0x7f, 0x80, 0xe9, 0xc5, 0x0e,
	0x06, 0xda, 0xf6, 0x07, 0x48, 0xae, 0xc1, 0x42, 0x71, 0x50, 0x68, 0x6d, 0xcc, 0x45, 0x3f, 0x5f,
	0xa0, 0x9b, 0x38, 0x54, 0x09, 0x9c, 0x50, 0xb8, 0x7e, 0x0f, 0xa0, 0x90, 0x85, 0x5c, 0x07, 0x7b,
	0xc4, 0x8b, 0x79, 0x30, 0x98, 0x58, 0x8b, 0x05, 0xae, 0xeb, 0xa9, 0xff, 0x62, 0x81, 0x7d, 0xba,
	0xe6, 0x73, 0xf0, 0xc9, 0x47, 0x30, 0x87, 0xc7, 0x31, 0x76, 0x64, 0xaa, 0xb6, 0xe9, 0xf8, 0xfa,
	0x6b, 0x27, 0x79, 0x8b, 0xb1, 0x50, 0x33, 0xdc, 0xaa, 0xb1, 0x37, 0x91, 0x1e, 0xc2, 0x74, 0xd1,
	0xc1, 0x6a, 0xc3, 0xdf, 0x3c, 0x6b, 0x9d, 0x4c, 0xb2, 0x9a, 0x8d, 0xdc, 0xcd, 0xd8, 0x2d, 0x02,
	0xb6, 0x39, 0x07, 0x3d, 0x11, 0x63, 0x87, 0xf6, 0x28, 0xf2, 0xc6, 0x5d, 0x80, 0x47, 0x91, 0xfc,
	0xe0, 0xae, 0xeb, 0x47, 0x01, 0xaa, 0xa7, 0x93, 0x90, 0x3e, 0x37, 0x8f, 0x88, 0xb2, 0x6b, 0x26,
	0xea, 0x89, 0x85, 0x51, 0x57, 0xa7, 0x5d, 0x76, 0xd5, 0xb0, 0xf1, 0x7b, 0x09, 0xe6, 0x4f, 0x04,
	0x21, 0x04, 0x2a, 0x23, 0xcb, 0xa5, 0xc7, 0xe4, 0x2a, 0x54, 0xf1, 0xd8, 0xcf, 0xcb, 0x56, 0xbb,
	0x63, 0x56, 0xb5, 0xa3, 0x06, 0x4d, 0x6d, 0x57, 0xa1, 0xca, 0x31, 0xc0, 0xe3, 0xd4, 0x64, 0x32,
	0x33, 0xd1, 0xa0, 0x31, 0xd9, 0x52, 0x67, 0x5e, 0x14, 0x9c, 0x6c, 0xd5, 0x33, 0xaf, 0x95, 0xa2,
	0x28, 0xed, 0x4e, 0x0d, 0x8c, 0xbb, 0x6b, 0x30, 0x1f, 0x73, 0x14, 0x18, 0x65, 0x69, 0x4d, 0xab,
	0xe3, 0xb6, 0x3d, 0xe1, 0xce, 0xa5, 0xb0, 0x31, 0x7b, 0x07, 0xd4, 0xbc, 0x47, 0xb3, 0xcc, 0x66,
	0xd3, 0xcc, 0xaa, 0x06, 0xcd, 0x8d, 0x44, 0xd2, 0x2b, 0x8c, 0x20, 0x33, 0x32, 0x68, 0x56, 0xe2,
	0x1c, 0x8d, 0x8e, 0x90, 0x67, 0xf1, 0x66, 0xcc, 0x43, 0xce, 0x60, 0xda, 0xa4, 0x55, 0x83, 0xe5,
	0xb4, 0xe5, 0xb5, 0x49, 0xb1, 0x3c, 0x8f, 0x2b, 0x33, 0x25, 0xbb, 0xfc, 0xb8, 0x32, 0x53, 0xb6,
	0x2b, 0x0d, 0x01, 0x6f, 0x3d, 0x4b, 0x90, 0x0f, 0x9f, 0xfa, 0xdc, 0x1f, 0xa0, 0x7c, 0xb3, 0xf6,
	0xf9, 0x23, 0xb8, 0x3c, 0xfa, 0x08, 0xbe, 0x05, 0x93, 0x5a, 0xd9, 0xf4, 0xa4, 0x7a, 0x53, 0x0b,
	0x1a, 0xc3, 0xd6, 0xf3, 0x1f, 0xff, 0xa8, 0x58, 0x3f, 0xfc, 0x76, 0xd9, 0xfa, 0x7c, 0x6b, 0xbc,
	0xbf, 0x22, 0xf1, 0xcb, 0x60, 0x9c, 0xbf, 0x23, 0x87, 0x53, 0x3a, 0xe6, 0x9d, 0xbf, 0x03, 0x00,
	0x00, 0xff, 0xff, 0xa1, 0x73, 0xa3, 0x9e, 0xe2, 0x0c, 0x00, 0x00,
}

func (this *Descriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Descriptor)
	if !ok {
		that2, ok := that.(Descriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if !this.RateLimit.Equal(that1.RateLimit) {
		return false
	}
	if len(this.Descriptors) != len(that1.Descriptors) {
		return false
	}
	for i := range this.Descriptors {
		if !this.Descriptors[i].Equal(that1.Descriptors[i]) {
			return false
		}
	}
	if this.Weight != that1.Weight {
		return false
	}
	if this.AlwaysApply != that1.AlwaysApply {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RateLimit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RateLimit)
	if !ok {
		that2, ok := that.(RateLimit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Unit != that1.Unit {
		return false
	}
	if this.RequestsPerUnit != that1.RequestsPerUnit {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *IngressRateLimit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IngressRateLimit)
	if !ok {
		that2, ok := that.(IngressRateLimit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AuthorizedLimits.Equal(that1.AuthorizedLimits) {
		return false
	}
	if !this.AnonymousLimits.Equal(that1.AnonymousLimits) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Settings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Settings)
	if !ok {
		that2, ok := that.(Settings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RatelimitServerRef.Equal(that1.RatelimitServerRef) {
		return false
	}
	if this.RequestTimeout != nil && that1.RequestTimeout != nil {
		if *this.RequestTimeout != *that1.RequestTimeout {
			return false
		}
	} else if this.RequestTimeout != nil {
		return false
	} else if that1.RequestTimeout != nil {
		return false
	}
	if this.DenyOnFail != that1.DenyOnFail {
		return false
	}
	if this.RateLimitBeforeAuth != that1.RateLimitBeforeAuth {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ServiceSettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceSettings)
	if !ok {
		that2, ok := that.(ServiceSettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Descriptors) != len(that1.Descriptors) {
		return false
	}
	for i := range this.Descriptors {
		if !this.Descriptors[i].Equal(that1.Descriptors[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RateLimitActions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RateLimitActions)
	if !ok {
		that2, ok := that.(RateLimitActions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Actions) != len(that1.Actions) {
		return false
	}
	for i := range this.Actions {
		if !this.Actions[i].Equal(that1.Actions[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RateLimitVhostExtension) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RateLimitVhostExtension)
	if !ok {
		that2, ok := that.(RateLimitVhostExtension)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RateLimits) != len(that1.RateLimits) {
		return false
	}
	for i := range this.RateLimits {
		if !this.RateLimits[i].Equal(that1.RateLimits[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RateLimitRouteExtension) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RateLimitRouteExtension)
	if !ok {
		that2, ok := that.(RateLimitRouteExtension)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IncludeVhRateLimits != that1.IncludeVhRateLimits {
		return false
	}
	if len(this.RateLimits) != len(that1.RateLimits) {
		return false
	}
	for i := range this.RateLimits {
		if !this.RateLimits[i].Equal(that1.RateLimits[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Action) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action)
	if !ok {
		that2, ok := that.(Action)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ActionSpecifier == nil {
		if this.ActionSpecifier != nil {
			return false
		}
	} else if this.ActionSpecifier == nil {
		return false
	} else if !this.ActionSpecifier.Equal(that1.ActionSpecifier) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Action_SourceCluster_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_SourceCluster_)
	if !ok {
		that2, ok := that.(Action_SourceCluster_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SourceCluster.Equal(that1.SourceCluster) {
		return false
	}
	return true
}
func (this *Action_DestinationCluster_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_DestinationCluster_)
	if !ok {
		that2, ok := that.(Action_DestinationCluster_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DestinationCluster.Equal(that1.DestinationCluster) {
		return false
	}
	return true
}
func (this *Action_RequestHeaders_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_RequestHeaders_)
	if !ok {
		that2, ok := that.(Action_RequestHeaders_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RequestHeaders.Equal(that1.RequestHeaders) {
		return false
	}
	return true
}
func (this *Action_RemoteAddress_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_RemoteAddress_)
	if !ok {
		that2, ok := that.(Action_RemoteAddress_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RemoteAddress.Equal(that1.RemoteAddress) {
		return false
	}
	return true
}
func (this *Action_GenericKey_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_GenericKey_)
	if !ok {
		that2, ok := that.(Action_GenericKey_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GenericKey.Equal(that1.GenericKey) {
		return false
	}
	return true
}
func (this *Action_HeaderValueMatch_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_HeaderValueMatch_)
	if !ok {
		that2, ok := that.(Action_HeaderValueMatch_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HeaderValueMatch.Equal(that1.HeaderValueMatch) {
		return false
	}
	return true
}
func (this *Action_SourceCluster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_SourceCluster)
	if !ok {
		that2, ok := that.(Action_SourceCluster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Action_DestinationCluster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_DestinationCluster)
	if !ok {
		that2, ok := that.(Action_DestinationCluster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Action_RequestHeaders) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_RequestHeaders)
	if !ok {
		that2, ok := that.(Action_RequestHeaders)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HeaderName != that1.HeaderName {
		return false
	}
	if this.DescriptorKey != that1.DescriptorKey {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Action_RemoteAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_RemoteAddress)
	if !ok {
		that2, ok := that.(Action_RemoteAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Action_GenericKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_GenericKey)
	if !ok {
		that2, ok := that.(Action_GenericKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DescriptorValue != that1.DescriptorValue {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Action_HeaderValueMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_HeaderValueMatch)
	if !ok {
		that2, ok := that.(Action_HeaderValueMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DescriptorValue != that1.DescriptorValue {
		return false
	}
	if !this.ExpectMatch.Equal(that1.ExpectMatch) {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Int64Range) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Int64Range)
	if !ok {
		that2, ok := that.(Int64Range)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Start != that1.Start {
		return false
	}
	if this.End != that1.End {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *HeaderMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcher)
	if !ok {
		that2, ok := that.(HeaderMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.HeaderMatchSpecifier == nil {
		if this.HeaderMatchSpecifier != nil {
			return false
		}
	} else if this.HeaderMatchSpecifier == nil {
		return false
	} else if !this.HeaderMatchSpecifier.Equal(that1.HeaderMatchSpecifier) {
		return false
	}
	if this.InvertMatch != that1.InvertMatch {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *HeaderMatcher_ExactMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcher_ExactMatch)
	if !ok {
		that2, ok := that.(HeaderMatcher_ExactMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExactMatch != that1.ExactMatch {
		return false
	}
	return true
}
func (this *HeaderMatcher_RegexMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcher_RegexMatch)
	if !ok {
		that2, ok := that.(HeaderMatcher_RegexMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RegexMatch != that1.RegexMatch {
		return false
	}
	return true
}
func (this *HeaderMatcher_RangeMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcher_RangeMatch)
	if !ok {
		that2, ok := that.(HeaderMatcher_RangeMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RangeMatch.Equal(that1.RangeMatch) {
		return false
	}
	return true
}
func (this *HeaderMatcher_PresentMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcher_PresentMatch)
	if !ok {
		that2, ok := that.(HeaderMatcher_PresentMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PresentMatch != that1.PresentMatch {
		return false
	}
	return true
}
func (this *HeaderMatcher_PrefixMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcher_PrefixMatch)
	if !ok {
		that2, ok := that.(HeaderMatcher_PrefixMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PrefixMatch != that1.PrefixMatch {
		return false
	}
	return true
}
func (this *HeaderMatcher_SuffixMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcher_SuffixMatch)
	if !ok {
		that2, ok := that.(HeaderMatcher_SuffixMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SuffixMatch != that1.SuffixMatch {
		return false
	}
	return true
}
func (this *QueryParameterMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcher)
	if !ok {
		that2, ok := that.(QueryParameterMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if !this.Regex.Equal(that1.Regex) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
