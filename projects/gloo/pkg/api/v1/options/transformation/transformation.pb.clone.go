// Code generated by protoc-gen-ext. DO NOT EDIT.
// source: github.com/solo-io/gloo/projects/gloo/api/v1/options/transformation/transformation.proto

package transformation

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"strings"

	"github.com/solo-io/protoc-gen-ext/pkg/clone"
	"google.golang.org/protobuf/proto"

	github_com_golang_protobuf_ptypes_wrappers "github.com/golang/protobuf/ptypes/wrappers"

	github_com_solo_io_gloo_projects_gloo_pkg_api_external_envoy_extensions_transformation "github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/extensions/transformation"

	github_com_solo_io_gloo_projects_gloo_pkg_api_external_envoy_extensions_transformers_xslt "github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/extensions/transformers/xslt"

	github_com_solo_io_gloo_projects_gloo_pkg_api_v1_core_matchers "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/core/matchers"
)

// ensure the imports are used
var (
	_ = errors.New("")
	_ = fmt.Print
	_ = binary.LittleEndian
	_ = bytes.Compare
	_ = strings.Compare
	_ = clone.Cloner(nil)
	_ = proto.Message(nil)
)

// Clone function
func (m *ResponseMatch) Clone() proto.Message {
	var target *ResponseMatch
	if m == nil {
		return target
	}
	target = &ResponseMatch{}

	if m.GetMatchers() != nil {
		target.Matchers = make([]*github_com_solo_io_gloo_projects_gloo_pkg_api_v1_core_matchers.HeaderMatcher, len(m.GetMatchers()))
		for idx, v := range m.GetMatchers() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.Matchers[idx] = h.Clone().(*github_com_solo_io_gloo_projects_gloo_pkg_api_v1_core_matchers.HeaderMatcher)
			} else {
				target.Matchers[idx] = proto.Clone(v).(*github_com_solo_io_gloo_projects_gloo_pkg_api_v1_core_matchers.HeaderMatcher)
			}

		}
	}

	target.ResponseCodeDetails = m.GetResponseCodeDetails()

	if h, ok := interface{}(m.GetResponseTransformation()).(clone.Cloner); ok {
		target.ResponseTransformation = h.Clone().(*Transformation)
	} else {
		target.ResponseTransformation = proto.Clone(m.GetResponseTransformation()).(*Transformation)
	}

	return target
}

// Clone function
func (m *RequestMatch) Clone() proto.Message {
	var target *RequestMatch
	if m == nil {
		return target
	}
	target = &RequestMatch{}

	if h, ok := interface{}(m.GetMatcher()).(clone.Cloner); ok {
		target.Matcher = h.Clone().(*github_com_solo_io_gloo_projects_gloo_pkg_api_v1_core_matchers.Matcher)
	} else {
		target.Matcher = proto.Clone(m.GetMatcher()).(*github_com_solo_io_gloo_projects_gloo_pkg_api_v1_core_matchers.Matcher)
	}

	target.ClearRouteCache = m.GetClearRouteCache()

	if h, ok := interface{}(m.GetRequestTransformation()).(clone.Cloner); ok {
		target.RequestTransformation = h.Clone().(*Transformation)
	} else {
		target.RequestTransformation = proto.Clone(m.GetRequestTransformation()).(*Transformation)
	}

	if h, ok := interface{}(m.GetResponseTransformation()).(clone.Cloner); ok {
		target.ResponseTransformation = h.Clone().(*Transformation)
	} else {
		target.ResponseTransformation = proto.Clone(m.GetResponseTransformation()).(*Transformation)
	}

	return target
}

// Clone function
func (m *Transformations) Clone() proto.Message {
	var target *Transformations
	if m == nil {
		return target
	}
	target = &Transformations{}

	if h, ok := interface{}(m.GetRequestTransformation()).(clone.Cloner); ok {
		target.RequestTransformation = h.Clone().(*Transformation)
	} else {
		target.RequestTransformation = proto.Clone(m.GetRequestTransformation()).(*Transformation)
	}

	target.ClearRouteCache = m.GetClearRouteCache()

	if h, ok := interface{}(m.GetResponseTransformation()).(clone.Cloner); ok {
		target.ResponseTransformation = h.Clone().(*Transformation)
	} else {
		target.ResponseTransformation = proto.Clone(m.GetResponseTransformation()).(*Transformation)
	}

	return target
}

// Clone function
func (m *RequestResponseTransformations) Clone() proto.Message {
	var target *RequestResponseTransformations
	if m == nil {
		return target
	}
	target = &RequestResponseTransformations{}

	if m.GetRequestTransforms() != nil {
		target.RequestTransforms = make([]*RequestMatch, len(m.GetRequestTransforms()))
		for idx, v := range m.GetRequestTransforms() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.RequestTransforms[idx] = h.Clone().(*RequestMatch)
			} else {
				target.RequestTransforms[idx] = proto.Clone(v).(*RequestMatch)
			}

		}
	}

	if m.GetResponseTransforms() != nil {
		target.ResponseTransforms = make([]*ResponseMatch, len(m.GetResponseTransforms()))
		for idx, v := range m.GetResponseTransforms() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.ResponseTransforms[idx] = h.Clone().(*ResponseMatch)
			} else {
				target.ResponseTransforms[idx] = proto.Clone(v).(*ResponseMatch)
			}

		}
	}

	return target
}

// Clone function
func (m *TransformationStages) Clone() proto.Message {
	var target *TransformationStages
	if m == nil {
		return target
	}
	target = &TransformationStages{}

	if h, ok := interface{}(m.GetEarly()).(clone.Cloner); ok {
		target.Early = h.Clone().(*RequestResponseTransformations)
	} else {
		target.Early = proto.Clone(m.GetEarly()).(*RequestResponseTransformations)
	}

	if h, ok := interface{}(m.GetRegular()).(clone.Cloner); ok {
		target.Regular = h.Clone().(*RequestResponseTransformations)
	} else {
		target.Regular = proto.Clone(m.GetRegular()).(*RequestResponseTransformations)
	}

	target.InheritTransformation = m.GetInheritTransformation()

	if h, ok := interface{}(m.GetLogRequestResponseInfo()).(clone.Cloner); ok {
		target.LogRequestResponseInfo = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	} else {
		target.LogRequestResponseInfo = proto.Clone(m.GetLogRequestResponseInfo()).(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	}

	return target
}

// Clone function
func (m *Transformation) Clone() proto.Message {
	var target *Transformation
	if m == nil {
		return target
	}
	target = &Transformation{}

	target.LogRequestResponseInfo = m.GetLogRequestResponseInfo()

	switch m.TransformationType.(type) {

	case *Transformation_TransformationTemplate:

		if h, ok := interface{}(m.GetTransformationTemplate()).(clone.Cloner); ok {
			target.TransformationType = &Transformation_TransformationTemplate{
				TransformationTemplate: h.Clone().(*github_com_solo_io_gloo_projects_gloo_pkg_api_external_envoy_extensions_transformation.TransformationTemplate),
			}
		} else {
			target.TransformationType = &Transformation_TransformationTemplate{
				TransformationTemplate: proto.Clone(m.GetTransformationTemplate()).(*github_com_solo_io_gloo_projects_gloo_pkg_api_external_envoy_extensions_transformation.TransformationTemplate),
			}
		}

	case *Transformation_HeaderBodyTransform:

		if h, ok := interface{}(m.GetHeaderBodyTransform()).(clone.Cloner); ok {
			target.TransformationType = &Transformation_HeaderBodyTransform{
				HeaderBodyTransform: h.Clone().(*github_com_solo_io_gloo_projects_gloo_pkg_api_external_envoy_extensions_transformation.HeaderBodyTransform),
			}
		} else {
			target.TransformationType = &Transformation_HeaderBodyTransform{
				HeaderBodyTransform: proto.Clone(m.GetHeaderBodyTransform()).(*github_com_solo_io_gloo_projects_gloo_pkg_api_external_envoy_extensions_transformation.HeaderBodyTransform),
			}
		}

	case *Transformation_XsltTransformation:

		if h, ok := interface{}(m.GetXsltTransformation()).(clone.Cloner); ok {
			target.TransformationType = &Transformation_XsltTransformation{
				XsltTransformation: h.Clone().(*github_com_solo_io_gloo_projects_gloo_pkg_api_external_envoy_extensions_transformers_xslt.XsltTransformation),
			}
		} else {
			target.TransformationType = &Transformation_XsltTransformation{
				XsltTransformation: proto.Clone(m.GetXsltTransformation()).(*github_com_solo_io_gloo_projects_gloo_pkg_api_external_envoy_extensions_transformers_xslt.XsltTransformation),
			}
		}

	}

	return target
}
