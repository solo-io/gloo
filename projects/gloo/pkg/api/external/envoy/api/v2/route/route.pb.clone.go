// Code generated by protoc-gen-ext. DO NOT EDIT.
// source: github.com/solo-io/gloo/projects/gloo/api/external/envoy/api/v2/route/route.proto

package route

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"strings"

	"github.com/solo-io/protoc-gen-ext/pkg/clone"
	"google.golang.org/protobuf/proto"

	github_com_golang_protobuf_ptypes_any "github.com/golang/protobuf/ptypes/any"

	github_com_golang_protobuf_ptypes_duration "github.com/golang/protobuf/ptypes/duration"

	github_com_golang_protobuf_ptypes_struct "github.com/golang/protobuf/ptypes/struct"

	github_com_golang_protobuf_ptypes_wrappers "github.com/golang/protobuf/ptypes/wrappers"

	github_com_solo_io_gloo_projects_gloo_pkg_api_external_envoy_type "github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/type"

	github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core "github.com/solo-io/solo-kit/pkg/api/external/envoy/api/v2/core"

	github_com_solo_io_solo_kit_pkg_api_external_envoy_type "github.com/solo-io/solo-kit/pkg/api/external/envoy/type"
)

// ensure the imports are used
var (
	_ = errors.New("")
	_ = fmt.Print
	_ = binary.LittleEndian
	_ = bytes.Compare
	_ = strings.Compare
	_ = clone.Cloner(nil)
	_ = proto.Message(nil)
)

// Clone function
func (m *VirtualHost) Clone() proto.Message {
	var target *VirtualHost
	if m == nil {
		return target
	}
	target = &VirtualHost{}

	target.Name = m.GetName()

	if m.GetDomains() != nil {
		target.Domains = make([]string, len(m.GetDomains()))
		for idx, v := range m.GetDomains() {

			target.Domains[idx] = v

		}
	}

	if m.GetRoutes() != nil {
		target.Routes = make([]*Route, len(m.GetRoutes()))
		for idx, v := range m.GetRoutes() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.Routes[idx] = h.Clone().(*Route)
			} else {
				target.Routes[idx] = proto.Clone(v).(*Route)
			}

		}
	}

	target.RequireTls = m.GetRequireTls()

	if m.GetVirtualClusters() != nil {
		target.VirtualClusters = make([]*VirtualCluster, len(m.GetVirtualClusters()))
		for idx, v := range m.GetVirtualClusters() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.VirtualClusters[idx] = h.Clone().(*VirtualCluster)
			} else {
				target.VirtualClusters[idx] = proto.Clone(v).(*VirtualCluster)
			}

		}
	}

	if m.GetRateLimits() != nil {
		target.RateLimits = make([]*RateLimit, len(m.GetRateLimits()))
		for idx, v := range m.GetRateLimits() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.RateLimits[idx] = h.Clone().(*RateLimit)
			} else {
				target.RateLimits[idx] = proto.Clone(v).(*RateLimit)
			}

		}
	}

	if m.GetRequestHeadersToAdd() != nil {
		target.RequestHeadersToAdd = make([]*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.HeaderValueOption, len(m.GetRequestHeadersToAdd()))
		for idx, v := range m.GetRequestHeadersToAdd() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.RequestHeadersToAdd[idx] = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.HeaderValueOption)
			} else {
				target.RequestHeadersToAdd[idx] = proto.Clone(v).(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.HeaderValueOption)
			}

		}
	}

	if m.GetRequestHeadersToRemove() != nil {
		target.RequestHeadersToRemove = make([]string, len(m.GetRequestHeadersToRemove()))
		for idx, v := range m.GetRequestHeadersToRemove() {

			target.RequestHeadersToRemove[idx] = v

		}
	}

	if m.GetResponseHeadersToAdd() != nil {
		target.ResponseHeadersToAdd = make([]*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.HeaderValueOption, len(m.GetResponseHeadersToAdd()))
		for idx, v := range m.GetResponseHeadersToAdd() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.ResponseHeadersToAdd[idx] = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.HeaderValueOption)
			} else {
				target.ResponseHeadersToAdd[idx] = proto.Clone(v).(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.HeaderValueOption)
			}

		}
	}

	if m.GetResponseHeadersToRemove() != nil {
		target.ResponseHeadersToRemove = make([]string, len(m.GetResponseHeadersToRemove()))
		for idx, v := range m.GetResponseHeadersToRemove() {

			target.ResponseHeadersToRemove[idx] = v

		}
	}

	if h, ok := interface{}(m.GetCors()).(clone.Cloner); ok {
		target.Cors = h.Clone().(*CorsPolicy)
	} else {
		target.Cors = proto.Clone(m.GetCors()).(*CorsPolicy)
	}

	if m.GetPerFilterConfig() != nil {
		target.PerFilterConfig = make(map[string]*github_com_golang_protobuf_ptypes_struct.Struct, len(m.GetPerFilterConfig()))
		for k, v := range m.GetPerFilterConfig() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.PerFilterConfig[k] = h.Clone().(*github_com_golang_protobuf_ptypes_struct.Struct)
			} else {
				target.PerFilterConfig[k] = proto.Clone(v).(*github_com_golang_protobuf_ptypes_struct.Struct)
			}

		}
	}

	if m.GetTypedPerFilterConfig() != nil {
		target.TypedPerFilterConfig = make(map[string]*github_com_golang_protobuf_ptypes_any.Any, len(m.GetTypedPerFilterConfig()))
		for k, v := range m.GetTypedPerFilterConfig() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.TypedPerFilterConfig[k] = h.Clone().(*github_com_golang_protobuf_ptypes_any.Any)
			} else {
				target.TypedPerFilterConfig[k] = proto.Clone(v).(*github_com_golang_protobuf_ptypes_any.Any)
			}

		}
	}

	target.IncludeRequestAttemptCount = m.GetIncludeRequestAttemptCount()

	if h, ok := interface{}(m.GetRetryPolicy()).(clone.Cloner); ok {
		target.RetryPolicy = h.Clone().(*RetryPolicy)
	} else {
		target.RetryPolicy = proto.Clone(m.GetRetryPolicy()).(*RetryPolicy)
	}

	if h, ok := interface{}(m.GetHedgePolicy()).(clone.Cloner); ok {
		target.HedgePolicy = h.Clone().(*HedgePolicy)
	} else {
		target.HedgePolicy = proto.Clone(m.GetHedgePolicy()).(*HedgePolicy)
	}

	return target
}

// Clone function
func (m *Route) Clone() proto.Message {
	var target *Route
	if m == nil {
		return target
	}
	target = &Route{}

	target.Name = m.GetName()

	if h, ok := interface{}(m.GetMatch()).(clone.Cloner); ok {
		target.Match = h.Clone().(*RouteMatch)
	} else {
		target.Match = proto.Clone(m.GetMatch()).(*RouteMatch)
	}

	if h, ok := interface{}(m.GetMetadata()).(clone.Cloner); ok {
		target.Metadata = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.Metadata)
	} else {
		target.Metadata = proto.Clone(m.GetMetadata()).(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.Metadata)
	}

	if h, ok := interface{}(m.GetDecorator()).(clone.Cloner); ok {
		target.Decorator = h.Clone().(*Decorator)
	} else {
		target.Decorator = proto.Clone(m.GetDecorator()).(*Decorator)
	}

	if m.GetPerFilterConfig() != nil {
		target.PerFilterConfig = make(map[string]*github_com_golang_protobuf_ptypes_struct.Struct, len(m.GetPerFilterConfig()))
		for k, v := range m.GetPerFilterConfig() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.PerFilterConfig[k] = h.Clone().(*github_com_golang_protobuf_ptypes_struct.Struct)
			} else {
				target.PerFilterConfig[k] = proto.Clone(v).(*github_com_golang_protobuf_ptypes_struct.Struct)
			}

		}
	}

	if m.GetTypedPerFilterConfig() != nil {
		target.TypedPerFilterConfig = make(map[string]*github_com_golang_protobuf_ptypes_any.Any, len(m.GetTypedPerFilterConfig()))
		for k, v := range m.GetTypedPerFilterConfig() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.TypedPerFilterConfig[k] = h.Clone().(*github_com_golang_protobuf_ptypes_any.Any)
			} else {
				target.TypedPerFilterConfig[k] = proto.Clone(v).(*github_com_golang_protobuf_ptypes_any.Any)
			}

		}
	}

	if m.GetRequestHeadersToAdd() != nil {
		target.RequestHeadersToAdd = make([]*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.HeaderValueOption, len(m.GetRequestHeadersToAdd()))
		for idx, v := range m.GetRequestHeadersToAdd() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.RequestHeadersToAdd[idx] = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.HeaderValueOption)
			} else {
				target.RequestHeadersToAdd[idx] = proto.Clone(v).(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.HeaderValueOption)
			}

		}
	}

	if m.GetRequestHeadersToRemove() != nil {
		target.RequestHeadersToRemove = make([]string, len(m.GetRequestHeadersToRemove()))
		for idx, v := range m.GetRequestHeadersToRemove() {

			target.RequestHeadersToRemove[idx] = v

		}
	}

	if m.GetResponseHeadersToAdd() != nil {
		target.ResponseHeadersToAdd = make([]*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.HeaderValueOption, len(m.GetResponseHeadersToAdd()))
		for idx, v := range m.GetResponseHeadersToAdd() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.ResponseHeadersToAdd[idx] = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.HeaderValueOption)
			} else {
				target.ResponseHeadersToAdd[idx] = proto.Clone(v).(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.HeaderValueOption)
			}

		}
	}

	if m.GetResponseHeadersToRemove() != nil {
		target.ResponseHeadersToRemove = make([]string, len(m.GetResponseHeadersToRemove()))
		for idx, v := range m.GetResponseHeadersToRemove() {

			target.ResponseHeadersToRemove[idx] = v

		}
	}

	if h, ok := interface{}(m.GetTracing()).(clone.Cloner); ok {
		target.Tracing = h.Clone().(*Tracing)
	} else {
		target.Tracing = proto.Clone(m.GetTracing()).(*Tracing)
	}

	switch m.Action.(type) {

	case *Route_Route:

		if h, ok := interface{}(m.GetRoute()).(clone.Cloner); ok {
			target.Action = &Route_Route{
				Route: h.Clone().(*RouteAction),
			}
		} else {
			target.Action = &Route_Route{
				Route: proto.Clone(m.GetRoute()).(*RouteAction),
			}
		}

	case *Route_Redirect:

		if h, ok := interface{}(m.GetRedirect()).(clone.Cloner); ok {
			target.Action = &Route_Redirect{
				Redirect: h.Clone().(*RedirectAction),
			}
		} else {
			target.Action = &Route_Redirect{
				Redirect: proto.Clone(m.GetRedirect()).(*RedirectAction),
			}
		}

	case *Route_DirectResponse:

		if h, ok := interface{}(m.GetDirectResponse()).(clone.Cloner); ok {
			target.Action = &Route_DirectResponse{
				DirectResponse: h.Clone().(*DirectResponseAction),
			}
		} else {
			target.Action = &Route_DirectResponse{
				DirectResponse: proto.Clone(m.GetDirectResponse()).(*DirectResponseAction),
			}
		}

	}

	return target
}

// Clone function
func (m *WeightedCluster) Clone() proto.Message {
	var target *WeightedCluster
	if m == nil {
		return target
	}
	target = &WeightedCluster{}

	if m.GetClusters() != nil {
		target.Clusters = make([]*WeightedCluster_ClusterWeight, len(m.GetClusters()))
		for idx, v := range m.GetClusters() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.Clusters[idx] = h.Clone().(*WeightedCluster_ClusterWeight)
			} else {
				target.Clusters[idx] = proto.Clone(v).(*WeightedCluster_ClusterWeight)
			}

		}
	}

	if h, ok := interface{}(m.GetTotalWeight()).(clone.Cloner); ok {
		target.TotalWeight = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	} else {
		target.TotalWeight = proto.Clone(m.GetTotalWeight()).(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	}

	target.RuntimeKeyPrefix = m.GetRuntimeKeyPrefix()

	return target
}

// Clone function
func (m *RouteMatch) Clone() proto.Message {
	var target *RouteMatch
	if m == nil {
		return target
	}
	target = &RouteMatch{}

	if h, ok := interface{}(m.GetCaseSensitive()).(clone.Cloner); ok {
		target.CaseSensitive = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	} else {
		target.CaseSensitive = proto.Clone(m.GetCaseSensitive()).(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	}

	if h, ok := interface{}(m.GetRuntimeFraction()).(clone.Cloner); ok {
		target.RuntimeFraction = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.RuntimeFractionalPercent)
	} else {
		target.RuntimeFraction = proto.Clone(m.GetRuntimeFraction()).(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.RuntimeFractionalPercent)
	}

	if m.GetHeaders() != nil {
		target.Headers = make([]*HeaderMatcher, len(m.GetHeaders()))
		for idx, v := range m.GetHeaders() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.Headers[idx] = h.Clone().(*HeaderMatcher)
			} else {
				target.Headers[idx] = proto.Clone(v).(*HeaderMatcher)
			}

		}
	}

	if m.GetQueryParameters() != nil {
		target.QueryParameters = make([]*QueryParameterMatcher, len(m.GetQueryParameters()))
		for idx, v := range m.GetQueryParameters() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.QueryParameters[idx] = h.Clone().(*QueryParameterMatcher)
			} else {
				target.QueryParameters[idx] = proto.Clone(v).(*QueryParameterMatcher)
			}

		}
	}

	if h, ok := interface{}(m.GetGrpc()).(clone.Cloner); ok {
		target.Grpc = h.Clone().(*RouteMatch_GrpcRouteMatchOptions)
	} else {
		target.Grpc = proto.Clone(m.GetGrpc()).(*RouteMatch_GrpcRouteMatchOptions)
	}

	switch m.PathSpecifier.(type) {

	case *RouteMatch_Prefix:

		target.PathSpecifier = &RouteMatch_Prefix{
			Prefix: m.GetPrefix(),
		}

	case *RouteMatch_Path:

		target.PathSpecifier = &RouteMatch_Path{
			Path: m.GetPath(),
		}

	case *RouteMatch_Regex:

		target.PathSpecifier = &RouteMatch_Regex{
			Regex: m.GetRegex(),
		}

	case *RouteMatch_ConnectMatcher_:

		if h, ok := interface{}(m.GetConnectMatcher()).(clone.Cloner); ok {
			target.PathSpecifier = &RouteMatch_ConnectMatcher_{
				ConnectMatcher: h.Clone().(*RouteMatch_ConnectMatcher),
			}
		} else {
			target.PathSpecifier = &RouteMatch_ConnectMatcher_{
				ConnectMatcher: proto.Clone(m.GetConnectMatcher()).(*RouteMatch_ConnectMatcher),
			}
		}

	}

	return target
}

// Clone function
func (m *CorsPolicy) Clone() proto.Message {
	var target *CorsPolicy
	if m == nil {
		return target
	}
	target = &CorsPolicy{}

	if m.GetAllowOrigin() != nil {
		target.AllowOrigin = make([]string, len(m.GetAllowOrigin()))
		for idx, v := range m.GetAllowOrigin() {

			target.AllowOrigin[idx] = v

		}
	}

	if m.GetAllowOriginRegex() != nil {
		target.AllowOriginRegex = make([]string, len(m.GetAllowOriginRegex()))
		for idx, v := range m.GetAllowOriginRegex() {

			target.AllowOriginRegex[idx] = v

		}
	}

	target.AllowMethods = m.GetAllowMethods()

	target.AllowHeaders = m.GetAllowHeaders()

	target.ExposeHeaders = m.GetExposeHeaders()

	target.MaxAge = m.GetMaxAge()

	if h, ok := interface{}(m.GetAllowCredentials()).(clone.Cloner); ok {
		target.AllowCredentials = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	} else {
		target.AllowCredentials = proto.Clone(m.GetAllowCredentials()).(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	}

	if h, ok := interface{}(m.GetShadowEnabled()).(clone.Cloner); ok {
		target.ShadowEnabled = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.RuntimeFractionalPercent)
	} else {
		target.ShadowEnabled = proto.Clone(m.GetShadowEnabled()).(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.RuntimeFractionalPercent)
	}

	switch m.EnabledSpecifier.(type) {

	case *CorsPolicy_Enabled:

		if h, ok := interface{}(m.GetEnabled()).(clone.Cloner); ok {
			target.EnabledSpecifier = &CorsPolicy_Enabled{
				Enabled: h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.BoolValue),
			}
		} else {
			target.EnabledSpecifier = &CorsPolicy_Enabled{
				Enabled: proto.Clone(m.GetEnabled()).(*github_com_golang_protobuf_ptypes_wrappers.BoolValue),
			}
		}

	case *CorsPolicy_FilterEnabled:

		if h, ok := interface{}(m.GetFilterEnabled()).(clone.Cloner); ok {
			target.EnabledSpecifier = &CorsPolicy_FilterEnabled{
				FilterEnabled: h.Clone().(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.RuntimeFractionalPercent),
			}
		} else {
			target.EnabledSpecifier = &CorsPolicy_FilterEnabled{
				FilterEnabled: proto.Clone(m.GetFilterEnabled()).(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.RuntimeFractionalPercent),
			}
		}

	}

	return target
}

// Clone function
func (m *RouteAction) Clone() proto.Message {
	var target *RouteAction
	if m == nil {
		return target
	}
	target = &RouteAction{}

	target.ClusterNotFoundResponseCode = m.GetClusterNotFoundResponseCode()

	if h, ok := interface{}(m.GetMetadataMatch()).(clone.Cloner); ok {
		target.MetadataMatch = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.Metadata)
	} else {
		target.MetadataMatch = proto.Clone(m.GetMetadataMatch()).(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.Metadata)
	}

	target.PrefixRewrite = m.GetPrefixRewrite()

	if h, ok := interface{}(m.GetTimeout()).(clone.Cloner); ok {
		target.Timeout = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.Timeout = proto.Clone(m.GetTimeout()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	if h, ok := interface{}(m.GetIdleTimeout()).(clone.Cloner); ok {
		target.IdleTimeout = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.IdleTimeout = proto.Clone(m.GetIdleTimeout()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	if h, ok := interface{}(m.GetRetryPolicy()).(clone.Cloner); ok {
		target.RetryPolicy = h.Clone().(*RetryPolicy)
	} else {
		target.RetryPolicy = proto.Clone(m.GetRetryPolicy()).(*RetryPolicy)
	}

	if h, ok := interface{}(m.GetRequestMirrorPolicy()).(clone.Cloner); ok {
		target.RequestMirrorPolicy = h.Clone().(*RouteAction_RequestMirrorPolicy)
	} else {
		target.RequestMirrorPolicy = proto.Clone(m.GetRequestMirrorPolicy()).(*RouteAction_RequestMirrorPolicy)
	}

	target.Priority = m.GetPriority()

	if m.GetRateLimits() != nil {
		target.RateLimits = make([]*RateLimit, len(m.GetRateLimits()))
		for idx, v := range m.GetRateLimits() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.RateLimits[idx] = h.Clone().(*RateLimit)
			} else {
				target.RateLimits[idx] = proto.Clone(v).(*RateLimit)
			}

		}
	}

	if h, ok := interface{}(m.GetIncludeVhRateLimits()).(clone.Cloner); ok {
		target.IncludeVhRateLimits = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	} else {
		target.IncludeVhRateLimits = proto.Clone(m.GetIncludeVhRateLimits()).(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	}

	if m.GetHashPolicy() != nil {
		target.HashPolicy = make([]*RouteAction_HashPolicy, len(m.GetHashPolicy()))
		for idx, v := range m.GetHashPolicy() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.HashPolicy[idx] = h.Clone().(*RouteAction_HashPolicy)
			} else {
				target.HashPolicy[idx] = proto.Clone(v).(*RouteAction_HashPolicy)
			}

		}
	}

	if h, ok := interface{}(m.GetCors()).(clone.Cloner); ok {
		target.Cors = h.Clone().(*CorsPolicy)
	} else {
		target.Cors = proto.Clone(m.GetCors()).(*CorsPolicy)
	}

	if h, ok := interface{}(m.GetMaxGrpcTimeout()).(clone.Cloner); ok {
		target.MaxGrpcTimeout = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.MaxGrpcTimeout = proto.Clone(m.GetMaxGrpcTimeout()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	if h, ok := interface{}(m.GetGrpcTimeoutOffset()).(clone.Cloner); ok {
		target.GrpcTimeoutOffset = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.GrpcTimeoutOffset = proto.Clone(m.GetGrpcTimeoutOffset()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	if m.GetUpgradeConfigs() != nil {
		target.UpgradeConfigs = make([]*RouteAction_UpgradeConfig, len(m.GetUpgradeConfigs()))
		for idx, v := range m.GetUpgradeConfigs() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.UpgradeConfigs[idx] = h.Clone().(*RouteAction_UpgradeConfig)
			} else {
				target.UpgradeConfigs[idx] = proto.Clone(v).(*RouteAction_UpgradeConfig)
			}

		}
	}

	target.InternalRedirectAction = m.GetInternalRedirectAction()

	if h, ok := interface{}(m.GetHedgePolicy()).(clone.Cloner); ok {
		target.HedgePolicy = h.Clone().(*HedgePolicy)
	} else {
		target.HedgePolicy = proto.Clone(m.GetHedgePolicy()).(*HedgePolicy)
	}

	switch m.ClusterSpecifier.(type) {

	case *RouteAction_Cluster:

		target.ClusterSpecifier = &RouteAction_Cluster{
			Cluster: m.GetCluster(),
		}

	case *RouteAction_ClusterHeader:

		target.ClusterSpecifier = &RouteAction_ClusterHeader{
			ClusterHeader: m.GetClusterHeader(),
		}

	case *RouteAction_WeightedClusters:

		if h, ok := interface{}(m.GetWeightedClusters()).(clone.Cloner); ok {
			target.ClusterSpecifier = &RouteAction_WeightedClusters{
				WeightedClusters: h.Clone().(*WeightedCluster),
			}
		} else {
			target.ClusterSpecifier = &RouteAction_WeightedClusters{
				WeightedClusters: proto.Clone(m.GetWeightedClusters()).(*WeightedCluster),
			}
		}

	}

	switch m.HostRewriteSpecifier.(type) {

	case *RouteAction_HostRewrite:

		target.HostRewriteSpecifier = &RouteAction_HostRewrite{
			HostRewrite: m.GetHostRewrite(),
		}

	case *RouteAction_AutoHostRewrite:

		if h, ok := interface{}(m.GetAutoHostRewrite()).(clone.Cloner); ok {
			target.HostRewriteSpecifier = &RouteAction_AutoHostRewrite{
				AutoHostRewrite: h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.BoolValue),
			}
		} else {
			target.HostRewriteSpecifier = &RouteAction_AutoHostRewrite{
				AutoHostRewrite: proto.Clone(m.GetAutoHostRewrite()).(*github_com_golang_protobuf_ptypes_wrappers.BoolValue),
			}
		}

	case *RouteAction_AutoHostRewriteHeader:

		target.HostRewriteSpecifier = &RouteAction_AutoHostRewriteHeader{
			AutoHostRewriteHeader: m.GetAutoHostRewriteHeader(),
		}

	}

	return target
}

// Clone function
func (m *RetryPolicy) Clone() proto.Message {
	var target *RetryPolicy
	if m == nil {
		return target
	}
	target = &RetryPolicy{}

	target.RetryOn = m.GetRetryOn()

	if h, ok := interface{}(m.GetNumRetries()).(clone.Cloner); ok {
		target.NumRetries = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	} else {
		target.NumRetries = proto.Clone(m.GetNumRetries()).(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	}

	if h, ok := interface{}(m.GetPerTryTimeout()).(clone.Cloner); ok {
		target.PerTryTimeout = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.PerTryTimeout = proto.Clone(m.GetPerTryTimeout()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	if h, ok := interface{}(m.GetRetryPriority()).(clone.Cloner); ok {
		target.RetryPriority = h.Clone().(*RetryPolicy_RetryPriority)
	} else {
		target.RetryPriority = proto.Clone(m.GetRetryPriority()).(*RetryPolicy_RetryPriority)
	}

	if m.GetRetryHostPredicate() != nil {
		target.RetryHostPredicate = make([]*RetryPolicy_RetryHostPredicate, len(m.GetRetryHostPredicate()))
		for idx, v := range m.GetRetryHostPredicate() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.RetryHostPredicate[idx] = h.Clone().(*RetryPolicy_RetryHostPredicate)
			} else {
				target.RetryHostPredicate[idx] = proto.Clone(v).(*RetryPolicy_RetryHostPredicate)
			}

		}
	}

	target.HostSelectionRetryMaxAttempts = m.GetHostSelectionRetryMaxAttempts()

	if m.GetRetriableStatusCodes() != nil {
		target.RetriableStatusCodes = make([]uint32, len(m.GetRetriableStatusCodes()))
		for idx, v := range m.GetRetriableStatusCodes() {

			target.RetriableStatusCodes[idx] = v

		}
	}

	if h, ok := interface{}(m.GetRetryBackOff()).(clone.Cloner); ok {
		target.RetryBackOff = h.Clone().(*RetryPolicy_RetryBackOff)
	} else {
		target.RetryBackOff = proto.Clone(m.GetRetryBackOff()).(*RetryPolicy_RetryBackOff)
	}

	return target
}

// Clone function
func (m *HedgePolicy) Clone() proto.Message {
	var target *HedgePolicy
	if m == nil {
		return target
	}
	target = &HedgePolicy{}

	if h, ok := interface{}(m.GetInitialRequests()).(clone.Cloner); ok {
		target.InitialRequests = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	} else {
		target.InitialRequests = proto.Clone(m.GetInitialRequests()).(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	}

	if h, ok := interface{}(m.GetAdditionalRequestChance()).(clone.Cloner); ok {
		target.AdditionalRequestChance = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_external_envoy_type.FractionalPercent)
	} else {
		target.AdditionalRequestChance = proto.Clone(m.GetAdditionalRequestChance()).(*github_com_solo_io_solo_kit_pkg_api_external_envoy_type.FractionalPercent)
	}

	target.HedgeOnPerTryTimeout = m.GetHedgeOnPerTryTimeout()

	return target
}

// Clone function
func (m *RedirectAction) Clone() proto.Message {
	var target *RedirectAction
	if m == nil {
		return target
	}
	target = &RedirectAction{}

	target.HostRedirect = m.GetHostRedirect()

	target.PortRedirect = m.GetPortRedirect()

	target.ResponseCode = m.GetResponseCode()

	target.StripQuery = m.GetStripQuery()

	switch m.SchemeRewriteSpecifier.(type) {

	case *RedirectAction_HttpsRedirect:

		target.SchemeRewriteSpecifier = &RedirectAction_HttpsRedirect{
			HttpsRedirect: m.GetHttpsRedirect(),
		}

	case *RedirectAction_SchemeRedirect:

		target.SchemeRewriteSpecifier = &RedirectAction_SchemeRedirect{
			SchemeRedirect: m.GetSchemeRedirect(),
		}

	}

	switch m.PathRewriteSpecifier.(type) {

	case *RedirectAction_PathRedirect:

		target.PathRewriteSpecifier = &RedirectAction_PathRedirect{
			PathRedirect: m.GetPathRedirect(),
		}

	case *RedirectAction_PrefixRewrite:

		target.PathRewriteSpecifier = &RedirectAction_PrefixRewrite{
			PrefixRewrite: m.GetPrefixRewrite(),
		}

	}

	return target
}

// Clone function
func (m *DirectResponseAction) Clone() proto.Message {
	var target *DirectResponseAction
	if m == nil {
		return target
	}
	target = &DirectResponseAction{}

	target.Status = m.GetStatus()

	if h, ok := interface{}(m.GetBody()).(clone.Cloner); ok {
		target.Body = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.DataSource)
	} else {
		target.Body = proto.Clone(m.GetBody()).(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.DataSource)
	}

	return target
}

// Clone function
func (m *Decorator) Clone() proto.Message {
	var target *Decorator
	if m == nil {
		return target
	}
	target = &Decorator{}

	target.Operation = m.GetOperation()

	return target
}

// Clone function
func (m *Tracing) Clone() proto.Message {
	var target *Tracing
	if m == nil {
		return target
	}
	target = &Tracing{}

	if h, ok := interface{}(m.GetClientSampling()).(clone.Cloner); ok {
		target.ClientSampling = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_external_envoy_type.FractionalPercent)
	} else {
		target.ClientSampling = proto.Clone(m.GetClientSampling()).(*github_com_solo_io_solo_kit_pkg_api_external_envoy_type.FractionalPercent)
	}

	if h, ok := interface{}(m.GetRandomSampling()).(clone.Cloner); ok {
		target.RandomSampling = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_external_envoy_type.FractionalPercent)
	} else {
		target.RandomSampling = proto.Clone(m.GetRandomSampling()).(*github_com_solo_io_solo_kit_pkg_api_external_envoy_type.FractionalPercent)
	}

	if h, ok := interface{}(m.GetOverallSampling()).(clone.Cloner); ok {
		target.OverallSampling = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_external_envoy_type.FractionalPercent)
	} else {
		target.OverallSampling = proto.Clone(m.GetOverallSampling()).(*github_com_solo_io_solo_kit_pkg_api_external_envoy_type.FractionalPercent)
	}

	return target
}

// Clone function
func (m *VirtualCluster) Clone() proto.Message {
	var target *VirtualCluster
	if m == nil {
		return target
	}
	target = &VirtualCluster{}

	target.Pattern = m.GetPattern()

	target.Name = m.GetName()

	target.Method = m.GetMethod()

	return target
}

// Clone function
func (m *RateLimit) Clone() proto.Message {
	var target *RateLimit
	if m == nil {
		return target
	}
	target = &RateLimit{}

	if h, ok := interface{}(m.GetStage()).(clone.Cloner); ok {
		target.Stage = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	} else {
		target.Stage = proto.Clone(m.GetStage()).(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	}

	target.DisableKey = m.GetDisableKey()

	if m.GetActions() != nil {
		target.Actions = make([]*RateLimit_Action, len(m.GetActions()))
		for idx, v := range m.GetActions() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.Actions[idx] = h.Clone().(*RateLimit_Action)
			} else {
				target.Actions[idx] = proto.Clone(v).(*RateLimit_Action)
			}

		}
	}

	return target
}

// Clone function
func (m *HeaderMatcher) Clone() proto.Message {
	var target *HeaderMatcher
	if m == nil {
		return target
	}
	target = &HeaderMatcher{}

	target.Name = m.GetName()

	target.InvertMatch = m.GetInvertMatch()

	switch m.HeaderMatchSpecifier.(type) {

	case *HeaderMatcher_ExactMatch:

		target.HeaderMatchSpecifier = &HeaderMatcher_ExactMatch{
			ExactMatch: m.GetExactMatch(),
		}

	case *HeaderMatcher_RegexMatch:

		target.HeaderMatchSpecifier = &HeaderMatcher_RegexMatch{
			RegexMatch: m.GetRegexMatch(),
		}

	case *HeaderMatcher_RangeMatch:

		if h, ok := interface{}(m.GetRangeMatch()).(clone.Cloner); ok {
			target.HeaderMatchSpecifier = &HeaderMatcher_RangeMatch{
				RangeMatch: h.Clone().(*github_com_solo_io_gloo_projects_gloo_pkg_api_external_envoy_type.Int64Range),
			}
		} else {
			target.HeaderMatchSpecifier = &HeaderMatcher_RangeMatch{
				RangeMatch: proto.Clone(m.GetRangeMatch()).(*github_com_solo_io_gloo_projects_gloo_pkg_api_external_envoy_type.Int64Range),
			}
		}

	case *HeaderMatcher_PresentMatch:

		target.HeaderMatchSpecifier = &HeaderMatcher_PresentMatch{
			PresentMatch: m.GetPresentMatch(),
		}

	case *HeaderMatcher_PrefixMatch:

		target.HeaderMatchSpecifier = &HeaderMatcher_PrefixMatch{
			PrefixMatch: m.GetPrefixMatch(),
		}

	case *HeaderMatcher_SuffixMatch:

		target.HeaderMatchSpecifier = &HeaderMatcher_SuffixMatch{
			SuffixMatch: m.GetSuffixMatch(),
		}

	}

	return target
}

// Clone function
func (m *QueryParameterMatcher) Clone() proto.Message {
	var target *QueryParameterMatcher
	if m == nil {
		return target
	}
	target = &QueryParameterMatcher{}

	target.Name = m.GetName()

	target.Value = m.GetValue()

	if h, ok := interface{}(m.GetRegex()).(clone.Cloner); ok {
		target.Regex = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	} else {
		target.Regex = proto.Clone(m.GetRegex()).(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	}

	return target
}

// Clone function
func (m *WeightedCluster_ClusterWeight) Clone() proto.Message {
	var target *WeightedCluster_ClusterWeight
	if m == nil {
		return target
	}
	target = &WeightedCluster_ClusterWeight{}

	target.Name = m.GetName()

	if h, ok := interface{}(m.GetWeight()).(clone.Cloner); ok {
		target.Weight = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	} else {
		target.Weight = proto.Clone(m.GetWeight()).(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	}

	if h, ok := interface{}(m.GetMetadataMatch()).(clone.Cloner); ok {
		target.MetadataMatch = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.Metadata)
	} else {
		target.MetadataMatch = proto.Clone(m.GetMetadataMatch()).(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.Metadata)
	}

	if m.GetRequestHeadersToAdd() != nil {
		target.RequestHeadersToAdd = make([]*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.HeaderValueOption, len(m.GetRequestHeadersToAdd()))
		for idx, v := range m.GetRequestHeadersToAdd() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.RequestHeadersToAdd[idx] = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.HeaderValueOption)
			} else {
				target.RequestHeadersToAdd[idx] = proto.Clone(v).(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.HeaderValueOption)
			}

		}
	}

	if m.GetRequestHeadersToRemove() != nil {
		target.RequestHeadersToRemove = make([]string, len(m.GetRequestHeadersToRemove()))
		for idx, v := range m.GetRequestHeadersToRemove() {

			target.RequestHeadersToRemove[idx] = v

		}
	}

	if m.GetResponseHeadersToAdd() != nil {
		target.ResponseHeadersToAdd = make([]*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.HeaderValueOption, len(m.GetResponseHeadersToAdd()))
		for idx, v := range m.GetResponseHeadersToAdd() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.ResponseHeadersToAdd[idx] = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.HeaderValueOption)
			} else {
				target.ResponseHeadersToAdd[idx] = proto.Clone(v).(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.HeaderValueOption)
			}

		}
	}

	if m.GetResponseHeadersToRemove() != nil {
		target.ResponseHeadersToRemove = make([]string, len(m.GetResponseHeadersToRemove()))
		for idx, v := range m.GetResponseHeadersToRemove() {

			target.ResponseHeadersToRemove[idx] = v

		}
	}

	if m.GetPerFilterConfig() != nil {
		target.PerFilterConfig = make(map[string]*github_com_golang_protobuf_ptypes_struct.Struct, len(m.GetPerFilterConfig()))
		for k, v := range m.GetPerFilterConfig() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.PerFilterConfig[k] = h.Clone().(*github_com_golang_protobuf_ptypes_struct.Struct)
			} else {
				target.PerFilterConfig[k] = proto.Clone(v).(*github_com_golang_protobuf_ptypes_struct.Struct)
			}

		}
	}

	if m.GetTypedPerFilterConfig() != nil {
		target.TypedPerFilterConfig = make(map[string]*github_com_golang_protobuf_ptypes_any.Any, len(m.GetTypedPerFilterConfig()))
		for k, v := range m.GetTypedPerFilterConfig() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.TypedPerFilterConfig[k] = h.Clone().(*github_com_golang_protobuf_ptypes_any.Any)
			} else {
				target.TypedPerFilterConfig[k] = proto.Clone(v).(*github_com_golang_protobuf_ptypes_any.Any)
			}

		}
	}

	return target
}

// Clone function
func (m *RouteMatch_ConnectMatcher) Clone() proto.Message {
	var target *RouteMatch_ConnectMatcher
	if m == nil {
		return target
	}
	target = &RouteMatch_ConnectMatcher{}

	return target
}

// Clone function
func (m *RouteMatch_GrpcRouteMatchOptions) Clone() proto.Message {
	var target *RouteMatch_GrpcRouteMatchOptions
	if m == nil {
		return target
	}
	target = &RouteMatch_GrpcRouteMatchOptions{}

	return target
}

// Clone function
func (m *RouteAction_RequestMirrorPolicy) Clone() proto.Message {
	var target *RouteAction_RequestMirrorPolicy
	if m == nil {
		return target
	}
	target = &RouteAction_RequestMirrorPolicy{}

	target.Cluster = m.GetCluster()

	target.RuntimeKey = m.GetRuntimeKey()

	if h, ok := interface{}(m.GetRuntimeFraction()).(clone.Cloner); ok {
		target.RuntimeFraction = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.RuntimeFractionalPercent)
	} else {
		target.RuntimeFraction = proto.Clone(m.GetRuntimeFraction()).(*github_com_solo_io_solo_kit_pkg_api_external_envoy_api_v2_core.RuntimeFractionalPercent)
	}

	return target
}

// Clone function
func (m *RouteAction_HashPolicy) Clone() proto.Message {
	var target *RouteAction_HashPolicy
	if m == nil {
		return target
	}
	target = &RouteAction_HashPolicy{}

	target.Terminal = m.GetTerminal()

	switch m.PolicySpecifier.(type) {

	case *RouteAction_HashPolicy_Header_:

		if h, ok := interface{}(m.GetHeader()).(clone.Cloner); ok {
			target.PolicySpecifier = &RouteAction_HashPolicy_Header_{
				Header: h.Clone().(*RouteAction_HashPolicy_Header),
			}
		} else {
			target.PolicySpecifier = &RouteAction_HashPolicy_Header_{
				Header: proto.Clone(m.GetHeader()).(*RouteAction_HashPolicy_Header),
			}
		}

	case *RouteAction_HashPolicy_Cookie_:

		if h, ok := interface{}(m.GetCookie()).(clone.Cloner); ok {
			target.PolicySpecifier = &RouteAction_HashPolicy_Cookie_{
				Cookie: h.Clone().(*RouteAction_HashPolicy_Cookie),
			}
		} else {
			target.PolicySpecifier = &RouteAction_HashPolicy_Cookie_{
				Cookie: proto.Clone(m.GetCookie()).(*RouteAction_HashPolicy_Cookie),
			}
		}

	case *RouteAction_HashPolicy_ConnectionProperties_:

		if h, ok := interface{}(m.GetConnectionProperties()).(clone.Cloner); ok {
			target.PolicySpecifier = &RouteAction_HashPolicy_ConnectionProperties_{
				ConnectionProperties: h.Clone().(*RouteAction_HashPolicy_ConnectionProperties),
			}
		} else {
			target.PolicySpecifier = &RouteAction_HashPolicy_ConnectionProperties_{
				ConnectionProperties: proto.Clone(m.GetConnectionProperties()).(*RouteAction_HashPolicy_ConnectionProperties),
			}
		}

	}

	return target
}

// Clone function
func (m *RouteAction_UpgradeConfig) Clone() proto.Message {
	var target *RouteAction_UpgradeConfig
	if m == nil {
		return target
	}
	target = &RouteAction_UpgradeConfig{}

	target.UpgradeType = m.GetUpgradeType()

	if h, ok := interface{}(m.GetEnabled()).(clone.Cloner); ok {
		target.Enabled = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	} else {
		target.Enabled = proto.Clone(m.GetEnabled()).(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	}

	return target
}

// Clone function
func (m *RouteAction_HashPolicy_Header) Clone() proto.Message {
	var target *RouteAction_HashPolicy_Header
	if m == nil {
		return target
	}
	target = &RouteAction_HashPolicy_Header{}

	target.HeaderName = m.GetHeaderName()

	return target
}

// Clone function
func (m *RouteAction_HashPolicy_Cookie) Clone() proto.Message {
	var target *RouteAction_HashPolicy_Cookie
	if m == nil {
		return target
	}
	target = &RouteAction_HashPolicy_Cookie{}

	target.Name = m.GetName()

	if h, ok := interface{}(m.GetTtl()).(clone.Cloner); ok {
		target.Ttl = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.Ttl = proto.Clone(m.GetTtl()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	target.Path = m.GetPath()

	return target
}

// Clone function
func (m *RouteAction_HashPolicy_ConnectionProperties) Clone() proto.Message {
	var target *RouteAction_HashPolicy_ConnectionProperties
	if m == nil {
		return target
	}
	target = &RouteAction_HashPolicy_ConnectionProperties{}

	target.SourceIp = m.GetSourceIp()

	return target
}

// Clone function
func (m *RetryPolicy_RetryPriority) Clone() proto.Message {
	var target *RetryPolicy_RetryPriority
	if m == nil {
		return target
	}
	target = &RetryPolicy_RetryPriority{}

	target.Name = m.GetName()

	switch m.ConfigType.(type) {

	case *RetryPolicy_RetryPriority_Config:

		if h, ok := interface{}(m.GetConfig()).(clone.Cloner); ok {
			target.ConfigType = &RetryPolicy_RetryPriority_Config{
				Config: h.Clone().(*github_com_golang_protobuf_ptypes_struct.Struct),
			}
		} else {
			target.ConfigType = &RetryPolicy_RetryPriority_Config{
				Config: proto.Clone(m.GetConfig()).(*github_com_golang_protobuf_ptypes_struct.Struct),
			}
		}

	case *RetryPolicy_RetryPriority_TypedConfig:

		if h, ok := interface{}(m.GetTypedConfig()).(clone.Cloner); ok {
			target.ConfigType = &RetryPolicy_RetryPriority_TypedConfig{
				TypedConfig: h.Clone().(*github_com_golang_protobuf_ptypes_any.Any),
			}
		} else {
			target.ConfigType = &RetryPolicy_RetryPriority_TypedConfig{
				TypedConfig: proto.Clone(m.GetTypedConfig()).(*github_com_golang_protobuf_ptypes_any.Any),
			}
		}

	}

	return target
}

// Clone function
func (m *RetryPolicy_RetryHostPredicate) Clone() proto.Message {
	var target *RetryPolicy_RetryHostPredicate
	if m == nil {
		return target
	}
	target = &RetryPolicy_RetryHostPredicate{}

	target.Name = m.GetName()

	switch m.ConfigType.(type) {

	case *RetryPolicy_RetryHostPredicate_Config:

		if h, ok := interface{}(m.GetConfig()).(clone.Cloner); ok {
			target.ConfigType = &RetryPolicy_RetryHostPredicate_Config{
				Config: h.Clone().(*github_com_golang_protobuf_ptypes_struct.Struct),
			}
		} else {
			target.ConfigType = &RetryPolicy_RetryHostPredicate_Config{
				Config: proto.Clone(m.GetConfig()).(*github_com_golang_protobuf_ptypes_struct.Struct),
			}
		}

	case *RetryPolicy_RetryHostPredicate_TypedConfig:

		if h, ok := interface{}(m.GetTypedConfig()).(clone.Cloner); ok {
			target.ConfigType = &RetryPolicy_RetryHostPredicate_TypedConfig{
				TypedConfig: h.Clone().(*github_com_golang_protobuf_ptypes_any.Any),
			}
		} else {
			target.ConfigType = &RetryPolicy_RetryHostPredicate_TypedConfig{
				TypedConfig: proto.Clone(m.GetTypedConfig()).(*github_com_golang_protobuf_ptypes_any.Any),
			}
		}

	}

	return target
}

// Clone function
func (m *RetryPolicy_RetryBackOff) Clone() proto.Message {
	var target *RetryPolicy_RetryBackOff
	if m == nil {
		return target
	}
	target = &RetryPolicy_RetryBackOff{}

	if h, ok := interface{}(m.GetBaseInterval()).(clone.Cloner); ok {
		target.BaseInterval = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.BaseInterval = proto.Clone(m.GetBaseInterval()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	if h, ok := interface{}(m.GetMaxInterval()).(clone.Cloner); ok {
		target.MaxInterval = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.MaxInterval = proto.Clone(m.GetMaxInterval()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	return target
}

// Clone function
func (m *RateLimit_Action) Clone() proto.Message {
	var target *RateLimit_Action
	if m == nil {
		return target
	}
	target = &RateLimit_Action{}

	switch m.ActionSpecifier.(type) {

	case *RateLimit_Action_SourceCluster_:

		if h, ok := interface{}(m.GetSourceCluster()).(clone.Cloner); ok {
			target.ActionSpecifier = &RateLimit_Action_SourceCluster_{
				SourceCluster: h.Clone().(*RateLimit_Action_SourceCluster),
			}
		} else {
			target.ActionSpecifier = &RateLimit_Action_SourceCluster_{
				SourceCluster: proto.Clone(m.GetSourceCluster()).(*RateLimit_Action_SourceCluster),
			}
		}

	case *RateLimit_Action_DestinationCluster_:

		if h, ok := interface{}(m.GetDestinationCluster()).(clone.Cloner); ok {
			target.ActionSpecifier = &RateLimit_Action_DestinationCluster_{
				DestinationCluster: h.Clone().(*RateLimit_Action_DestinationCluster),
			}
		} else {
			target.ActionSpecifier = &RateLimit_Action_DestinationCluster_{
				DestinationCluster: proto.Clone(m.GetDestinationCluster()).(*RateLimit_Action_DestinationCluster),
			}
		}

	case *RateLimit_Action_RequestHeaders_:

		if h, ok := interface{}(m.GetRequestHeaders()).(clone.Cloner); ok {
			target.ActionSpecifier = &RateLimit_Action_RequestHeaders_{
				RequestHeaders: h.Clone().(*RateLimit_Action_RequestHeaders),
			}
		} else {
			target.ActionSpecifier = &RateLimit_Action_RequestHeaders_{
				RequestHeaders: proto.Clone(m.GetRequestHeaders()).(*RateLimit_Action_RequestHeaders),
			}
		}

	case *RateLimit_Action_RemoteAddress_:

		if h, ok := interface{}(m.GetRemoteAddress()).(clone.Cloner); ok {
			target.ActionSpecifier = &RateLimit_Action_RemoteAddress_{
				RemoteAddress: h.Clone().(*RateLimit_Action_RemoteAddress),
			}
		} else {
			target.ActionSpecifier = &RateLimit_Action_RemoteAddress_{
				RemoteAddress: proto.Clone(m.GetRemoteAddress()).(*RateLimit_Action_RemoteAddress),
			}
		}

	case *RateLimit_Action_GenericKey_:

		if h, ok := interface{}(m.GetGenericKey()).(clone.Cloner); ok {
			target.ActionSpecifier = &RateLimit_Action_GenericKey_{
				GenericKey: h.Clone().(*RateLimit_Action_GenericKey),
			}
		} else {
			target.ActionSpecifier = &RateLimit_Action_GenericKey_{
				GenericKey: proto.Clone(m.GetGenericKey()).(*RateLimit_Action_GenericKey),
			}
		}

	case *RateLimit_Action_HeaderValueMatch_:

		if h, ok := interface{}(m.GetHeaderValueMatch()).(clone.Cloner); ok {
			target.ActionSpecifier = &RateLimit_Action_HeaderValueMatch_{
				HeaderValueMatch: h.Clone().(*RateLimit_Action_HeaderValueMatch),
			}
		} else {
			target.ActionSpecifier = &RateLimit_Action_HeaderValueMatch_{
				HeaderValueMatch: proto.Clone(m.GetHeaderValueMatch()).(*RateLimit_Action_HeaderValueMatch),
			}
		}

	}

	return target
}

// Clone function
func (m *RateLimit_Action_SourceCluster) Clone() proto.Message {
	var target *RateLimit_Action_SourceCluster
	if m == nil {
		return target
	}
	target = &RateLimit_Action_SourceCluster{}

	return target
}

// Clone function
func (m *RateLimit_Action_DestinationCluster) Clone() proto.Message {
	var target *RateLimit_Action_DestinationCluster
	if m == nil {
		return target
	}
	target = &RateLimit_Action_DestinationCluster{}

	return target
}

// Clone function
func (m *RateLimit_Action_RequestHeaders) Clone() proto.Message {
	var target *RateLimit_Action_RequestHeaders
	if m == nil {
		return target
	}
	target = &RateLimit_Action_RequestHeaders{}

	target.HeaderName = m.GetHeaderName()

	target.DescriptorKey = m.GetDescriptorKey()

	return target
}

// Clone function
func (m *RateLimit_Action_RemoteAddress) Clone() proto.Message {
	var target *RateLimit_Action_RemoteAddress
	if m == nil {
		return target
	}
	target = &RateLimit_Action_RemoteAddress{}

	return target
}

// Clone function
func (m *RateLimit_Action_GenericKey) Clone() proto.Message {
	var target *RateLimit_Action_GenericKey
	if m == nil {
		return target
	}
	target = &RateLimit_Action_GenericKey{}

	target.DescriptorValue = m.GetDescriptorValue()

	return target
}

// Clone function
func (m *RateLimit_Action_HeaderValueMatch) Clone() proto.Message {
	var target *RateLimit_Action_HeaderValueMatch
	if m == nil {
		return target
	}
	target = &RateLimit_Action_HeaderValueMatch{}

	target.DescriptorValue = m.GetDescriptorValue()

	if h, ok := interface{}(m.GetExpectMatch()).(clone.Cloner); ok {
		target.ExpectMatch = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	} else {
		target.ExpectMatch = proto.Clone(m.GetExpectMatch()).(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	}

	if m.GetHeaders() != nil {
		target.Headers = make([]*HeaderMatcher, len(m.GetHeaders()))
		for idx, v := range m.GetHeaders() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.Headers[idx] = h.Clone().(*HeaderMatcher)
			} else {
				target.Headers[idx] = proto.Clone(v).(*HeaderMatcher)
			}

		}
	}

	return target
}
