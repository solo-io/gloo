// Code generated by protoc-gen-ext. DO NOT EDIT.
// source: github.com/solo-io/gloo/projects/gloo/api/external/envoy/config/route/v3/route_components.proto

package v3

import (
	"encoding/binary"
	"errors"
	"fmt"
	"hash"
	"hash/fnv"
	"strconv"

	safe_hasher "github.com/solo-io/protoc-gen-ext/pkg/hasher"
	"github.com/solo-io/protoc-gen-ext/pkg/hasher/hashstructure"
)

// ensure the imports are used
var (
	_ = errors.New("")
	_ = fmt.Print
	_ = binary.LittleEndian
	_ = new(hash.Hash64)
	_ = fnv.New64
	_ = strconv.Itoa
	_ = hashstructure.Hash
	_ = new(safe_hasher.SafeHasher)
)

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *VirtualHost) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.VirtualHost")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Name")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetName())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Domains")); err != nil {
		return 0, err
	}
	for i, v := range m.GetDomains() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if _, err = hasher.Write([]byte("v")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(v)); err != nil {
			return 0, err
		}

	}

	if _, err = hasher.Write([]byte("Routes")); err != nil {
		return 0, err
	}
	for i, v := range m.GetRoutes() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if _, err = hasher.Write([]byte("RequireTls")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetRequireTls())
	if err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("VirtualClusters")); err != nil {
		return 0, err
	}
	for i, v := range m.GetVirtualClusters() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if _, err = hasher.Write([]byte("RateLimits")); err != nil {
		return 0, err
	}
	for i, v := range m.GetRateLimits() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if _, err = hasher.Write([]byte("RequestHeadersToAdd")); err != nil {
		return 0, err
	}
	for i, v := range m.GetRequestHeadersToAdd() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if _, err = hasher.Write([]byte("RequestHeadersToRemove")); err != nil {
		return 0, err
	}
	for i, v := range m.GetRequestHeadersToRemove() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if _, err = hasher.Write([]byte("v")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(v)); err != nil {
			return 0, err
		}

	}

	if _, err = hasher.Write([]byte("ResponseHeadersToAdd")); err != nil {
		return 0, err
	}
	for i, v := range m.GetResponseHeadersToAdd() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if _, err = hasher.Write([]byte("ResponseHeadersToRemove")); err != nil {
		return 0, err
	}
	for i, v := range m.GetResponseHeadersToRemove() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if _, err = hasher.Write([]byte("v")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(v)); err != nil {
			return 0, err
		}

	}

	if h, ok := interface{}(m.GetCors()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Cors")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetCors(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Cors")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	{
		var result uint64
		innerHash := fnv.New64()
		for k, v := range m.GetTypedPerFilterConfig() {
			innerHash.Reset()

			if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
				if _, err = innerHash.Write([]byte("v")); err != nil {
					return 0, err
				}
				if _, err = h.Hash(innerHash); err != nil {
					return 0, err
				}
			} else {
				if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
					return 0, err
				} else {
					if _, err = innerHash.Write([]byte("v")); err != nil {
						return 0, err
					}
					if err := binary.Write(innerHash, binary.LittleEndian, fieldValue); err != nil {
						return 0, err
					}
				}
			}

			if _, err = innerHash.Write([]byte("k")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(k)); err != nil {
				return 0, err
			}

			result = result ^ innerHash.Sum64()
		}
		err = binary.Write(hasher, binary.LittleEndian, result)
		if err != nil {
			return 0, err
		}

	}

	if _, err = hasher.Write([]byte("IncludeRequestAttemptCount")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetIncludeRequestAttemptCount())
	if err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("IncludeAttemptCountInResponse")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetIncludeAttemptCountInResponse())
	if err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetRetryPolicy()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("RetryPolicy")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetRetryPolicy(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("RetryPolicy")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetRetryPolicyTypedConfig()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("RetryPolicyTypedConfig")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetRetryPolicyTypedConfig(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("RetryPolicyTypedConfig")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetHedgePolicy()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("HedgePolicy")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetHedgePolicy(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("HedgePolicy")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetPerRequestBufferLimitBytes()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("PerRequestBufferLimitBytes")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetPerRequestBufferLimitBytes(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("PerRequestBufferLimitBytes")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *FilterAction) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.FilterAction")); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetAction()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Action")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetAction(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Action")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *Route) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.Route")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Name")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetName())); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetMatch()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Match")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetMatch(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Match")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetMetadata()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Metadata")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetMetadata(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Metadata")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetDecorator()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Decorator")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetDecorator(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Decorator")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	{
		var result uint64
		innerHash := fnv.New64()
		for k, v := range m.GetTypedPerFilterConfig() {
			innerHash.Reset()

			if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
				if _, err = innerHash.Write([]byte("v")); err != nil {
					return 0, err
				}
				if _, err = h.Hash(innerHash); err != nil {
					return 0, err
				}
			} else {
				if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
					return 0, err
				} else {
					if _, err = innerHash.Write([]byte("v")); err != nil {
						return 0, err
					}
					if err := binary.Write(innerHash, binary.LittleEndian, fieldValue); err != nil {
						return 0, err
					}
				}
			}

			if _, err = innerHash.Write([]byte("k")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(k)); err != nil {
				return 0, err
			}

			result = result ^ innerHash.Sum64()
		}
		err = binary.Write(hasher, binary.LittleEndian, result)
		if err != nil {
			return 0, err
		}

	}

	if _, err = hasher.Write([]byte("RequestHeadersToAdd")); err != nil {
		return 0, err
	}
	for i, v := range m.GetRequestHeadersToAdd() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if _, err = hasher.Write([]byte("RequestHeadersToRemove")); err != nil {
		return 0, err
	}
	for i, v := range m.GetRequestHeadersToRemove() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if _, err = hasher.Write([]byte("v")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(v)); err != nil {
			return 0, err
		}

	}

	if _, err = hasher.Write([]byte("ResponseHeadersToAdd")); err != nil {
		return 0, err
	}
	for i, v := range m.GetResponseHeadersToAdd() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if _, err = hasher.Write([]byte("ResponseHeadersToRemove")); err != nil {
		return 0, err
	}
	for i, v := range m.GetResponseHeadersToRemove() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if _, err = hasher.Write([]byte("v")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(v)); err != nil {
			return 0, err
		}

	}

	if h, ok := interface{}(m.GetTracing()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Tracing")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetTracing(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Tracing")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetPerRequestBufferLimitBytes()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("PerRequestBufferLimitBytes")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetPerRequestBufferLimitBytes(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("PerRequestBufferLimitBytes")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	switch m.Action.(type) {

	case *Route_Route:

		if h, ok := interface{}(m.GetRoute()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("Route")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetRoute(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("Route")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *Route_Redirect:

		if h, ok := interface{}(m.GetRedirect()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("Redirect")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetRedirect(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("Redirect")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *Route_DirectResponse:

		if h, ok := interface{}(m.GetDirectResponse()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("DirectResponse")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetDirectResponse(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("DirectResponse")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *Route_FilterAction:

		if h, ok := interface{}(m.GetFilterAction()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("FilterAction")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetFilterAction(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("FilterAction")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *WeightedCluster) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.WeightedCluster")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Clusters")); err != nil {
		return 0, err
	}
	for i, v := range m.GetClusters() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if h, ok := interface{}(m.GetTotalWeight()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("TotalWeight")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetTotalWeight(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("TotalWeight")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if _, err = hasher.Write([]byte("RuntimeKeyPrefix")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetRuntimeKeyPrefix())); err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RouteMatch) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RouteMatch")); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetCaseSensitive()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("CaseSensitive")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetCaseSensitive(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("CaseSensitive")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetRuntimeFraction()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("RuntimeFraction")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetRuntimeFraction(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("RuntimeFraction")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if _, err = hasher.Write([]byte("Headers")); err != nil {
		return 0, err
	}
	for i, v := range m.GetHeaders() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if _, err = hasher.Write([]byte("QueryParameters")); err != nil {
		return 0, err
	}
	for i, v := range m.GetQueryParameters() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if h, ok := interface{}(m.GetGrpc()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Grpc")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetGrpc(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Grpc")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetTlsContext()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("TlsContext")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetTlsContext(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("TlsContext")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	switch m.PathSpecifier.(type) {

	case *RouteMatch_Prefix:

		if _, err = hasher.Write([]byte("Prefix")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(m.GetPrefix())); err != nil {
			return 0, err
		}

	case *RouteMatch_Path:

		if _, err = hasher.Write([]byte("Path")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(m.GetPath())); err != nil {
			return 0, err
		}

	case *RouteMatch_SafeRegex:

		if h, ok := interface{}(m.GetSafeRegex()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("SafeRegex")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetSafeRegex(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("SafeRegex")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *RouteMatch_ConnectMatcher_:

		if h, ok := interface{}(m.GetConnectMatcher()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("ConnectMatcher")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetConnectMatcher(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("ConnectMatcher")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *CorsPolicy) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.CorsPolicy")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("AllowOriginStringMatch")); err != nil {
		return 0, err
	}
	for i, v := range m.GetAllowOriginStringMatch() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if _, err = hasher.Write([]byte("AllowMethods")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetAllowMethods())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("AllowHeaders")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetAllowHeaders())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ExposeHeaders")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetExposeHeaders())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("MaxAge")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetMaxAge())); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetAllowCredentials()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("AllowCredentials")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetAllowCredentials(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("AllowCredentials")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetShadowEnabled()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("ShadowEnabled")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetShadowEnabled(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("ShadowEnabled")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	switch m.EnabledSpecifier.(type) {

	case *CorsPolicy_FilterEnabled:

		if h, ok := interface{}(m.GetFilterEnabled()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("FilterEnabled")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetFilterEnabled(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("FilterEnabled")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RouteAction) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RouteAction")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ClusterNotFoundResponseCode")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetClusterNotFoundResponseCode())
	if err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetMetadataMatch()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("MetadataMatch")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetMetadataMatch(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("MetadataMatch")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if _, err = hasher.Write([]byte("PrefixRewrite")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetPrefixRewrite())); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetRegexRewrite()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("RegexRewrite")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetRegexRewrite(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("RegexRewrite")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetTimeout()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Timeout")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetTimeout(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Timeout")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetIdleTimeout()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("IdleTimeout")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetIdleTimeout(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("IdleTimeout")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetRetryPolicy()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("RetryPolicy")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetRetryPolicy(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("RetryPolicy")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetRetryPolicyTypedConfig()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("RetryPolicyTypedConfig")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetRetryPolicyTypedConfig(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("RetryPolicyTypedConfig")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if _, err = hasher.Write([]byte("RequestMirrorPolicies")); err != nil {
		return 0, err
	}
	for i, v := range m.GetRequestMirrorPolicies() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if _, err = hasher.Write([]byte("Priority")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetPriority())
	if err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("RateLimits")); err != nil {
		return 0, err
	}
	for i, v := range m.GetRateLimits() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if h, ok := interface{}(m.GetIncludeVhRateLimits()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("IncludeVhRateLimits")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetIncludeVhRateLimits(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("IncludeVhRateLimits")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if _, err = hasher.Write([]byte("HashPolicy")); err != nil {
		return 0, err
	}
	for i, v := range m.GetHashPolicy() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if h, ok := interface{}(m.GetCors()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Cors")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetCors(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Cors")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetMaxGrpcTimeout()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("MaxGrpcTimeout")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetMaxGrpcTimeout(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("MaxGrpcTimeout")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetGrpcTimeoutOffset()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("GrpcTimeoutOffset")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetGrpcTimeoutOffset(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("GrpcTimeoutOffset")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if _, err = hasher.Write([]byte("UpgradeConfigs")); err != nil {
		return 0, err
	}
	for i, v := range m.GetUpgradeConfigs() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if h, ok := interface{}(m.GetInternalRedirectPolicy()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("InternalRedirectPolicy")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetInternalRedirectPolicy(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("InternalRedirectPolicy")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if _, err = hasher.Write([]byte("InternalRedirectAction")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetInternalRedirectAction())
	if err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetMaxInternalRedirects()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("MaxInternalRedirects")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetMaxInternalRedirects(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("MaxInternalRedirects")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetHedgePolicy()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("HedgePolicy")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetHedgePolicy(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("HedgePolicy")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	switch m.ClusterSpecifier.(type) {

	case *RouteAction_Cluster:

		if _, err = hasher.Write([]byte("Cluster")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(m.GetCluster())); err != nil {
			return 0, err
		}

	case *RouteAction_ClusterHeader:

		if _, err = hasher.Write([]byte("ClusterHeader")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(m.GetClusterHeader())); err != nil {
			return 0, err
		}

	case *RouteAction_WeightedClusters:

		if h, ok := interface{}(m.GetWeightedClusters()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("WeightedClusters")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetWeightedClusters(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("WeightedClusters")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	switch m.HostRewriteSpecifier.(type) {

	case *RouteAction_HostRewriteLiteral:

		if _, err = hasher.Write([]byte("HostRewriteLiteral")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(m.GetHostRewriteLiteral())); err != nil {
			return 0, err
		}

	case *RouteAction_AutoHostRewrite:

		if h, ok := interface{}(m.GetAutoHostRewrite()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("AutoHostRewrite")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetAutoHostRewrite(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("AutoHostRewrite")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *RouteAction_HostRewriteHeader:

		if _, err = hasher.Write([]byte("HostRewriteHeader")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(m.GetHostRewriteHeader())); err != nil {
			return 0, err
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RetryPolicy) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RetryPolicy")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("RetryOn")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetRetryOn())); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetNumRetries()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("NumRetries")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetNumRetries(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("NumRetries")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetPerTryTimeout()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("PerTryTimeout")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetPerTryTimeout(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("PerTryTimeout")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetRetryPriority()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("RetryPriority")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetRetryPriority(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("RetryPriority")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if _, err = hasher.Write([]byte("RetryHostPredicate")); err != nil {
		return 0, err
	}
	for i, v := range m.GetRetryHostPredicate() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if _, err = hasher.Write([]byte("HostSelectionRetryMaxAttempts")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetHostSelectionRetryMaxAttempts())
	if err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("RetriableStatusCodes")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetRetriableStatusCodes())
	if err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetRetryBackOff()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("RetryBackOff")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetRetryBackOff(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("RetryBackOff")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if _, err = hasher.Write([]byte("RetriableHeaders")); err != nil {
		return 0, err
	}
	for i, v := range m.GetRetriableHeaders() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if _, err = hasher.Write([]byte("RetriableRequestHeaders")); err != nil {
		return 0, err
	}
	for i, v := range m.GetRetriableRequestHeaders() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *HedgePolicy) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.HedgePolicy")); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetInitialRequests()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("InitialRequests")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetInitialRequests(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("InitialRequests")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetAdditionalRequestChance()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("AdditionalRequestChance")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetAdditionalRequestChance(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("AdditionalRequestChance")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if _, err = hasher.Write([]byte("HedgeOnPerTryTimeout")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetHedgeOnPerTryTimeout())
	if err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RedirectAction) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RedirectAction")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("HostRedirect")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetHostRedirect())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("PortRedirect")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetPortRedirect())
	if err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("ResponseCode")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetResponseCode())
	if err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("StripQuery")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetStripQuery())
	if err != nil {
		return 0, err
	}

	switch m.SchemeRewriteSpecifier.(type) {

	case *RedirectAction_HttpsRedirect:

		if _, err = hasher.Write([]byte("HttpsRedirect")); err != nil {
			return 0, err
		}
		err = binary.Write(hasher, binary.LittleEndian, m.GetHttpsRedirect())
		if err != nil {
			return 0, err
		}

	case *RedirectAction_SchemeRedirect:

		if _, err = hasher.Write([]byte("SchemeRedirect")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(m.GetSchemeRedirect())); err != nil {
			return 0, err
		}

	}

	switch m.PathRewriteSpecifier.(type) {

	case *RedirectAction_PathRedirect:

		if _, err = hasher.Write([]byte("PathRedirect")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(m.GetPathRedirect())); err != nil {
			return 0, err
		}

	case *RedirectAction_PrefixRewrite:

		if _, err = hasher.Write([]byte("PrefixRewrite")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(m.GetPrefixRewrite())); err != nil {
			return 0, err
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *DirectResponseAction) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.DirectResponseAction")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Status")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetStatus())
	if err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetBody()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Body")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetBody(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Body")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *Decorator) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.Decorator")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Operation")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetOperation())); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetPropagate()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Propagate")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetPropagate(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Propagate")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *Tracing) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.Tracing")); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetClientSampling()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("ClientSampling")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetClientSampling(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("ClientSampling")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetRandomSampling()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("RandomSampling")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetRandomSampling(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("RandomSampling")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetOverallSampling()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("OverallSampling")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetOverallSampling(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("OverallSampling")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if _, err = hasher.Write([]byte("CustomTags")); err != nil {
		return 0, err
	}
	for i, v := range m.GetCustomTags() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *VirtualCluster) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.VirtualCluster")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Headers")); err != nil {
		return 0, err
	}
	for i, v := range m.GetHeaders() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if _, err = hasher.Write([]byte("Name")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetName())); err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RateLimit) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RateLimit")); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetStage()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Stage")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetStage(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Stage")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if _, err = hasher.Write([]byte("DisableKey")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetDisableKey())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Actions")); err != nil {
		return 0, err
	}
	for i, v := range m.GetActions() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if h, ok := interface{}(m.GetLimit()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Limit")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetLimit(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Limit")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *HeaderMatcher) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.HeaderMatcher")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Name")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetName())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("InvertMatch")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetInvertMatch())
	if err != nil {
		return 0, err
	}

	switch m.HeaderMatchSpecifier.(type) {

	case *HeaderMatcher_ExactMatch:

		if _, err = hasher.Write([]byte("ExactMatch")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(m.GetExactMatch())); err != nil {
			return 0, err
		}

	case *HeaderMatcher_SafeRegexMatch:

		if h, ok := interface{}(m.GetSafeRegexMatch()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("SafeRegexMatch")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetSafeRegexMatch(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("SafeRegexMatch")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *HeaderMatcher_RangeMatch:

		if h, ok := interface{}(m.GetRangeMatch()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("RangeMatch")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetRangeMatch(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("RangeMatch")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *HeaderMatcher_PresentMatch:

		if _, err = hasher.Write([]byte("PresentMatch")); err != nil {
			return 0, err
		}
		err = binary.Write(hasher, binary.LittleEndian, m.GetPresentMatch())
		if err != nil {
			return 0, err
		}

	case *HeaderMatcher_PrefixMatch:

		if _, err = hasher.Write([]byte("PrefixMatch")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(m.GetPrefixMatch())); err != nil {
			return 0, err
		}

	case *HeaderMatcher_SuffixMatch:

		if _, err = hasher.Write([]byte("SuffixMatch")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(m.GetSuffixMatch())); err != nil {
			return 0, err
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *QueryParameterMatcher) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.QueryParameterMatcher")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Name")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetName())); err != nil {
		return 0, err
	}

	switch m.QueryParameterMatchSpecifier.(type) {

	case *QueryParameterMatcher_StringMatch:

		if h, ok := interface{}(m.GetStringMatch()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("StringMatch")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetStringMatch(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("StringMatch")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *QueryParameterMatcher_PresentMatch:

		if _, err = hasher.Write([]byte("PresentMatch")); err != nil {
			return 0, err
		}
		err = binary.Write(hasher, binary.LittleEndian, m.GetPresentMatch())
		if err != nil {
			return 0, err
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *InternalRedirectPolicy) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.InternalRedirectPolicy")); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetMaxInternalRedirects()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("MaxInternalRedirects")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetMaxInternalRedirects(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("MaxInternalRedirects")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if _, err = hasher.Write([]byte("RedirectResponseCodes")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetRedirectResponseCodes())
	if err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Predicates")); err != nil {
		return 0, err
	}
	for i, v := range m.GetPredicates() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if _, err = hasher.Write([]byte("AllowCrossSchemeRedirect")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetAllowCrossSchemeRedirect())
	if err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *WeightedCluster_ClusterWeight) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.WeightedCluster_ClusterWeight")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Name")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetName())); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetWeight()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Weight")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetWeight(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Weight")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetMetadataMatch()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("MetadataMatch")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetMetadataMatch(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("MetadataMatch")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if _, err = hasher.Write([]byte("RequestHeadersToAdd")); err != nil {
		return 0, err
	}
	for i, v := range m.GetRequestHeadersToAdd() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if _, err = hasher.Write([]byte("RequestHeadersToRemove")); err != nil {
		return 0, err
	}
	for i, v := range m.GetRequestHeadersToRemove() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if _, err = hasher.Write([]byte("v")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(v)); err != nil {
			return 0, err
		}

	}

	if _, err = hasher.Write([]byte("ResponseHeadersToAdd")); err != nil {
		return 0, err
	}
	for i, v := range m.GetResponseHeadersToAdd() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	if _, err = hasher.Write([]byte("ResponseHeadersToRemove")); err != nil {
		return 0, err
	}
	for i, v := range m.GetResponseHeadersToRemove() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if _, err = hasher.Write([]byte("v")); err != nil {
			return 0, err
		}
		if _, err = hasher.Write([]byte(v)); err != nil {
			return 0, err
		}

	}

	{
		var result uint64
		innerHash := fnv.New64()
		for k, v := range m.GetTypedPerFilterConfig() {
			innerHash.Reset()

			if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
				if _, err = innerHash.Write([]byte("v")); err != nil {
					return 0, err
				}
				if _, err = h.Hash(innerHash); err != nil {
					return 0, err
				}
			} else {
				if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
					return 0, err
				} else {
					if _, err = innerHash.Write([]byte("v")); err != nil {
						return 0, err
					}
					if err := binary.Write(innerHash, binary.LittleEndian, fieldValue); err != nil {
						return 0, err
					}
				}
			}

			if _, err = innerHash.Write([]byte("k")); err != nil {
				return 0, err
			}
			if _, err = innerHash.Write([]byte(k)); err != nil {
				return 0, err
			}

			result = result ^ innerHash.Sum64()
		}
		err = binary.Write(hasher, binary.LittleEndian, result)
		if err != nil {
			return 0, err
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RouteMatch_GrpcRouteMatchOptions) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RouteMatch_GrpcRouteMatchOptions")); err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RouteMatch_TlsContextMatchOptions) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RouteMatch_TlsContextMatchOptions")); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetPresented()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Presented")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetPresented(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Presented")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetValidated()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Validated")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetValidated(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Validated")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RouteMatch_ConnectMatcher) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RouteMatch_ConnectMatcher")); err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RouteAction_RequestMirrorPolicy) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RouteAction_RequestMirrorPolicy")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Cluster")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetCluster())); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetRuntimeFraction()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("RuntimeFraction")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetRuntimeFraction(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("RuntimeFraction")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetTraceSampled()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("TraceSampled")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetTraceSampled(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("TraceSampled")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RouteAction_HashPolicy) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RouteAction_HashPolicy")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Terminal")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetTerminal())
	if err != nil {
		return 0, err
	}

	switch m.PolicySpecifier.(type) {

	case *RouteAction_HashPolicy_Header_:

		if h, ok := interface{}(m.GetHeader()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("Header")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetHeader(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("Header")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *RouteAction_HashPolicy_Cookie_:

		if h, ok := interface{}(m.GetCookie()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("Cookie")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetCookie(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("Cookie")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *RouteAction_HashPolicy_ConnectionProperties_:

		if h, ok := interface{}(m.GetConnectionProperties()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("ConnectionProperties")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetConnectionProperties(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("ConnectionProperties")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *RouteAction_HashPolicy_QueryParameter_:

		if h, ok := interface{}(m.GetQueryParameter()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("QueryParameter")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetQueryParameter(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("QueryParameter")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *RouteAction_HashPolicy_FilterState_:

		if h, ok := interface{}(m.GetFilterState()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("FilterState")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetFilterState(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("FilterState")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RouteAction_UpgradeConfig) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RouteAction_UpgradeConfig")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("UpgradeType")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetUpgradeType())); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetEnabled()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Enabled")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetEnabled(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Enabled")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetConnectConfig()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("ConnectConfig")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetConnectConfig(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("ConnectConfig")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RouteAction_HashPolicy_Header) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RouteAction_HashPolicy_Header")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("HeaderName")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetHeaderName())); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetRegexRewrite()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("RegexRewrite")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetRegexRewrite(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("RegexRewrite")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RouteAction_HashPolicy_Cookie) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RouteAction_HashPolicy_Cookie")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Name")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetName())); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetTtl()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("Ttl")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetTtl(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("Ttl")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if _, err = hasher.Write([]byte("Path")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetPath())); err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RouteAction_HashPolicy_ConnectionProperties) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RouteAction_HashPolicy_ConnectionProperties")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("SourceIp")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetSourceIp())
	if err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RouteAction_HashPolicy_QueryParameter) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RouteAction_HashPolicy_QueryParameter")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Name")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetName())); err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RouteAction_HashPolicy_FilterState) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RouteAction_HashPolicy_FilterState")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Key")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetKey())); err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RouteAction_UpgradeConfig_ConnectConfig) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RouteAction_UpgradeConfig_ConnectConfig")); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetProxyProtocolConfig()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("ProxyProtocolConfig")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetProxyProtocolConfig(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("ProxyProtocolConfig")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RetryPolicy_RetryPriority) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RetryPolicy_RetryPriority")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Name")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetName())); err != nil {
		return 0, err
	}

	switch m.ConfigType.(type) {

	case *RetryPolicy_RetryPriority_TypedConfig:

		if h, ok := interface{}(m.GetTypedConfig()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("TypedConfig")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetTypedConfig(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("TypedConfig")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RetryPolicy_RetryHostPredicate) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RetryPolicy_RetryHostPredicate")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("Name")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetName())); err != nil {
		return 0, err
	}

	switch m.ConfigType.(type) {

	case *RetryPolicy_RetryHostPredicate_TypedConfig:

		if h, ok := interface{}(m.GetTypedConfig()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("TypedConfig")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetTypedConfig(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("TypedConfig")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RetryPolicy_RetryBackOff) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RetryPolicy_RetryBackOff")); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetBaseInterval()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("BaseInterval")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetBaseInterval(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("BaseInterval")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if h, ok := interface{}(m.GetMaxInterval()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("MaxInterval")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetMaxInterval(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("MaxInterval")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RateLimit_Action) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RateLimit_Action")); err != nil {
		return 0, err
	}

	switch m.ActionSpecifier.(type) {

	case *RateLimit_Action_SourceCluster_:

		if h, ok := interface{}(m.GetSourceCluster()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("SourceCluster")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetSourceCluster(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("SourceCluster")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *RateLimit_Action_DestinationCluster_:

		if h, ok := interface{}(m.GetDestinationCluster()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("DestinationCluster")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetDestinationCluster(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("DestinationCluster")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *RateLimit_Action_RequestHeaders_:

		if h, ok := interface{}(m.GetRequestHeaders()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("RequestHeaders")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetRequestHeaders(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("RequestHeaders")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *RateLimit_Action_RemoteAddress_:

		if h, ok := interface{}(m.GetRemoteAddress()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("RemoteAddress")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetRemoteAddress(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("RemoteAddress")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *RateLimit_Action_GenericKey_:

		if h, ok := interface{}(m.GetGenericKey()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("GenericKey")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetGenericKey(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("GenericKey")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *RateLimit_Action_HeaderValueMatch_:

		if h, ok := interface{}(m.GetHeaderValueMatch()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("HeaderValueMatch")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetHeaderValueMatch(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("HeaderValueMatch")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	case *RateLimit_Action_DynamicMetadata:

		if h, ok := interface{}(m.GetDynamicMetadata()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("DynamicMetadata")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetDynamicMetadata(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("DynamicMetadata")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RateLimit_Override) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RateLimit_Override")); err != nil {
		return 0, err
	}

	switch m.OverrideSpecifier.(type) {

	case *RateLimit_Override_DynamicMetadata_:

		if h, ok := interface{}(m.GetDynamicMetadata()).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("DynamicMetadata")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(m.GetDynamicMetadata(), nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("DynamicMetadata")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RateLimit_Action_SourceCluster) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RateLimit_Action_SourceCluster")); err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RateLimit_Action_DestinationCluster) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RateLimit_Action_DestinationCluster")); err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RateLimit_Action_RequestHeaders) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RateLimit_Action_RequestHeaders")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("HeaderName")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetHeaderName())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("DescriptorKey")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetDescriptorKey())); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("SkipIfAbsent")); err != nil {
		return 0, err
	}
	err = binary.Write(hasher, binary.LittleEndian, m.GetSkipIfAbsent())
	if err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RateLimit_Action_RemoteAddress) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RateLimit_Action_RemoteAddress")); err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RateLimit_Action_GenericKey) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RateLimit_Action_GenericKey")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("DescriptorValue")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetDescriptorValue())); err != nil {
		return 0, err
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RateLimit_Action_HeaderValueMatch) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RateLimit_Action_HeaderValueMatch")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("DescriptorValue")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetDescriptorValue())); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetExpectMatch()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("ExpectMatch")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetExpectMatch(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("ExpectMatch")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	if _, err = hasher.Write([]byte("Headers")); err != nil {
		return 0, err
	}
	for i, v := range m.GetHeaders() {
		if _, err = hasher.Write([]byte(strconv.Itoa(i))); err != nil {
			return 0, err
		}

		if h, ok := interface{}(v).(safe_hasher.SafeHasher); ok {
			if _, err = hasher.Write([]byte("v")); err != nil {
				return 0, err
			}
			if _, err = h.Hash(hasher); err != nil {
				return 0, err
			}
		} else {
			if fieldValue, err := hashstructure.Hash(v, nil); err != nil {
				return 0, err
			} else {
				if _, err = hasher.Write([]byte("v")); err != nil {
					return 0, err
				}
				if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
					return 0, err
				}
			}
		}

	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RateLimit_Action_DynamicMetaData) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RateLimit_Action_DynamicMetaData")); err != nil {
		return 0, err
	}

	if _, err = hasher.Write([]byte("DescriptorKey")); err != nil {
		return 0, err
	}
	if _, err = hasher.Write([]byte(m.GetDescriptorKey())); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetMetadataKey()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("MetadataKey")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetMetadataKey(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("MetadataKey")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	return hasher.Sum64(), nil
}

// HashUnique function generates a hash of the object that is unique to the object by
// hashing field name and value pairs.
// Replaces Hash due to original hashing implemention only using field values. The omission
// of the field name in the hash calculation can lead to hash collisions.
func (m *RateLimit_Override_DynamicMetadata) HashUnique(hasher hash.Hash64) (uint64, error) {
	if m == nil {
		return 0, nil
	}
	if hasher == nil {
		hasher = fnv.New64()
	}
	var err error
	if _, err = hasher.Write([]byte("solo.io.envoy.config.route.v3.github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/route/v3.RateLimit_Override_DynamicMetadata")); err != nil {
		return 0, err
	}

	if h, ok := interface{}(m.GetMetadataKey()).(safe_hasher.SafeHasher); ok {
		if _, err = hasher.Write([]byte("MetadataKey")); err != nil {
			return 0, err
		}
		if _, err = h.Hash(hasher); err != nil {
			return 0, err
		}
	} else {
		if fieldValue, err := hashstructure.Hash(m.GetMetadataKey(), nil); err != nil {
			return 0, err
		} else {
			if _, err = hasher.Write([]byte("MetadataKey")); err != nil {
				return 0, err
			}
			if err := binary.Write(hasher, binary.LittleEndian, fieldValue); err != nil {
				return 0, err
			}
		}
	}

	return hasher.Sum64(), nil
}
