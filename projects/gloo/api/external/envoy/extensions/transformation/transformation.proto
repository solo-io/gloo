syntax = "proto3";

package envoy.api.v2.filter.http;

option go_package = "github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/extensions/transformation";
import "extproto/ext.proto";
option (extproto.hash_all) = true;
option (extproto.clone_all) = true;
option (extproto.equal_all) = true;


import "google/protobuf/empty.proto";
import "google/protobuf/wrappers.proto";
import "validate/validate.proto";

import "github.com/solo-io/gloo/projects/gloo/api/external/envoy/config/route/v3/route_components.proto";
import "github.com/solo-io/gloo/projects/gloo/api/external/envoy/type/matcher/v3/string.proto";
import "github.com/solo-io/gloo/projects/gloo/api/external/envoy/config/core/v3/extension.proto";

message FilterTransformations {
  // Specifies transformations based on the route matches. The first matched
  // transformation will be applied. If there are overlapped match conditions,
  // please put the most specific match first.
  repeated TransformationRule transformations = 1;

  // Only RouteTransformations.RouteTransformation with matching stage will be
  // used with this filter.
  uint32 stage = 2 [ (validate.rules).uint32 = {lte : 10} ];

  // Logs request/response sensitive information
  // By default, this is false so no request or response sensitive information is logged.
  // If set to true, the filter will log the request/response body and headers before and
  // after any transformation is applied.
  bool log_request_response_info = 3;
}

message TransformationRule {
  // The route matching parameter. Only when the match is satisfied, the
  // "requires" field will apply.
  //
  // For example: following match will match all requests.
  //
  // .. code-block:: yaml
  //
  //    match:
  //      prefix: /
  //
  solo.io.envoy.config.route.v3.RouteMatch match = 1
      [ (validate.rules).message = {required : true} ];

  message Transformations {
    // Apply a transformation to requests.
    Transformation request_transformation = 1;
    // Clear the route cache if the request transformation was applied.
    bool clear_route_cache = 3;
    // Apply a transformation to responses.
    Transformation response_transformation = 2;
    // Apply a transformation in the onStreamComplete callback
    // (for modifying headers and dynamic metadata for access logs)
    Transformation on_stream_completion_transformation = 4;
  }
  // transformation to perform
  Transformations route_transformations = 2;
}

message RouteTransformations {
  // deprecated. Use transformations[].request_match.request_transformation
  // instead.
  Transformation request_transformation = 1 [ deprecated = true ];
  // deprecated. Use transformations[].request_match.response_transformation
  // instead.
  Transformation response_transformation = 2 [ deprecated = true ];
  // deprecated. Use transformations[].request_match.clear_route_cache instead.
  bool clear_route_cache = 3 [ deprecated = true ];

  message RouteTransformation {
    // Stage number. This transformation will only be processed by filters with
    // the same stage number.
    uint32 stage = 1 [ (validate.rules).uint32 = {lte : 10} ];

    message RequestMatch {
      // if no match is specified, will match all
      solo.io.envoy.config.route.v3.RouteMatch match = 1;
      // transformation to perform
      Transformation request_transformation = 2;
      Transformation response_transformation = 3;
      // clear the route cache if the request transformation was applied
      bool clear_route_cache = 4;
    }

    message ResponseMatch {
      ResponseMatcher match = 1;
      // transformation to perform
      Transformation response_transformation = 2;
    }

    oneof match {
      option (validate.required) = true;
      RequestMatch request_match = 2;
      ResponseMatch response_match = 3;
    }
  }

  repeated RouteTransformation transformations = 4;
}

message ResponseMatcher {
  // Specifies a set of headers that the route should match on. The router will
  // check the response headers against all the specified headers in the route
  // config. A match will happen if all the headers in the route are present in
  // the request with the same values (or based on presence if the value field
  // is not in the config).
  repeated solo.io.envoy.config.route.v3.HeaderMatcher headers = 1;

  // Only match responses with non empty response code details (this usually
  // implies a local reply).
  solo.io.envoy.type.matcher.v3.StringMatcher response_code_details = 2;
}

message ResponseTransformationRule {
  ResponseMatcher match = 1;
  // transformation to perform
  Transformation response_transformation = 2;
}

// This message defines a transformation.
// This proto is for envoy filter config, not user-facing API.
message Transformation {
  // The type of transformation to apply.
  oneof transformation_type {
    // Apply transformation templates.
    TransformationTemplate transformation_template = 1;
    // This type of transformation will make all the headers available in the
    // response body. The resulting JSON body will consist of two attributes:
    // 'headers', containing the headers, and 'body', containing the original
    // body.
    HeaderBodyTransform header_body_transform = 2;
    // Configuration for an externally implemented transformer, used by
    // envoy transformation filter.
    solo.io.envoy.config.core.v3.TypedExtensionConfig transformer_config = 3;
  }

  // Logs request/response sensitive information
  // By default, this is false so no request or response sensitive information is logged.
  // If set to true, the filter will log the request/response body and headers before and
  // after this transformation is applied.
  google.protobuf.BoolValue log_request_response_info = 4;
}

// Extractions can be used to extract information from the request/response.
// The extracted information can then be referenced in template fields.
message Extraction {

  // The source of the extraction
  oneof source {
    // Extract information from headers
    string header = 1;
    // Extract information from the request/response body
    google.protobuf.Empty body = 4;
  }

  // Only strings matching this regular expression will be part of the
  // extraction. This regex **must match the entire source** in order for a value to be extracted.
  // The most simple value for this field is '.*', which matches the
  // whole source. The field is required. If extraction fails the result is an
  // empty value.
  string regex = 2;

  // If your regex contains capturing groups, use this field to determine which
  // group should be selected.
  uint32 subgroup = 3;
}

// Defines a transformation template.
message TransformationTemplate {

  // If set to true, use JSON pointer notation (e.g. "time/start") instead of
  // dot notation (e.g. "time.start") to access JSON elements. Defaults to
  // false.
  //
  // Please note that, if set to 'true', you will need to use the `extraction`
  // function to access extractors in the template (e.g. '{{
  // extraction("my_extractor") }}'); if the default value of 'false' is used,
  // extractors will simply be available by their name (e.g. '{{ my_extractor
  // }}').
  bool advanced_templates = 1;

  // Use this attribute to extract information from the request. It consists of
  // a map of strings to extractors. The extractor will defines which
  // information will be extracted, while the string key will provide the
  // extractor with a name. You can reference extractors by their name in
  // templates, e.g. "{{ my-extractor }}" will render to the value of the
  // "my-extractor" extractor.
  map<string, Extraction> extractors = 2;
  // Use this attribute to transform request/response headers. It consists of a
  // map of strings to templates. The string key determines the name of the
  // resulting header, the rendered template will determine the value. Any existing
  // headers with the same header name will be replaced by the transformed header.
  // If a header name is included in `headers` and `headers_to_append`, it will first
  // be replaced the template in `headers`, then additional header values will be appended
  // by the templates defined in `headers_to_append`.
  // For example, the following header transformation configuration:
  //
  // ```yaml
  //    headers:
  //      x-header-one: {"text": "first {{inja}} template"}
  //      x-header-one: {"text": "second {{inja}} template"}
  //    headersToAppend:
  //      - key: x-header-one
  //        value: {"text": "first appended {{inja}} template"}
  //      - key: x-header-one
  //        value: {"text": "second appended {{inja}} template"}
  // ```
  // will result in the following headers on the HTTP message:
  //
  // ```
  // x-header-one: first inja template
  // x-header-one: first appended inja template
  // x-header-one: second appended inja template
  // ```
  map<string, InjaTemplate> headers = 3;

  // Defines a header-template pair to be used in `headers_to_append`
  message HeaderToAppend {
    // Header name
    string key = 1;
    // Apply a template to the header value
    InjaTemplate value = 2;
  }

  // Use this attribute to transform request/response headers. It consists of
  // an array of string/template objects. Use this attribute to define multiple
  // templates for a single header. Header template(s) defined here will be appended to any
  // existing headers with the same header name, not replace existing ones.
  // See `headers` documentation to see an example of usage.
  repeated HeaderToAppend headers_to_append = 10;

  // Attribute to remove headers from requests. If a header is present multiple
  // times, all instances of the header will be removed.
  repeated string headers_to_remove = 11;

  // Determines the type of transformation to apply to the request/response body
  oneof body_transformation {
    // Apply a template to the body
    InjaTemplate body = 4;
    // This will cause the transformation filter not to buffer the body.
    // Use this setting if the response body is large and you don't need to
    // transform nor extract information from it.
    Passthrough passthrough = 5;
    // Merge all defined extractors to the request/response body.
    // If you want to nest elements inside the body, use dot separator in the
    // extractor name.
    MergeExtractorsToBody merge_extractors_to_body = 6;
  }

  // Determines how the body will be parsed.
  enum RequestBodyParse {
    // Will attempt to parse the request/response body as JSON
    ParseAsJson = 0;
    // The request/response body will be treated as plain text
    DontParse = 1;
  }
  RequestBodyParse parse_body_behavior = 7;

  // If set to true, Envoy will not throw an exception in case the body parsing
  // fails.
  bool ignore_error_on_parse = 8;

  // Defines an [Envoy Dynamic
  // Metadata](https://www.envoyproxy.io/docs/envoy/latest/configuration/advanced/well_known_dynamic_metadata)
  // entry.
  message DynamicMetadataValue {

    // The metadata namespace. Defaults to the filter namespace.
    string metadata_namespace = 1;

    // The metadata key.
    string key = 2 [ (validate.rules).string = {min_bytes : 1} ];

    // A template that determines the metadata value.
    InjaTemplate value = 3;
  }
  // Use this field to set Dynamic Metadata.
  repeated DynamicMetadataValue dynamic_metadata_values = 9;
}

// Defines an [Inja template](https://github.com/pantor/inja) that will be
// rendered by Gloo. In addition to the core template functions, the Gloo
// transformation filter defines the following custom functions:
// - header(header_name): returns the value of the header with the given name.
// - extraction(extractor_name): returns the value of the extractor with the
// given name.
// - env(env_var_name): returns the value of the environment variable with the
// given name.
// - body(): returns the request/response body.
// - context(): returns the base JSON context (allowing for example to range on
// a JSON body that is an array).
// - request_header(header_name): returns the value of the request header with
// the given name. Use this option when you want to include request header values in response
// transformations.
// - base64_encode(string): encodes the input string to base64.
// - base64_decode(string): decodes the input string from base64.
// - substring(string, start_pos, substring_len): returns a substring of the
// input string, starting at `start_pos` and extending for `substring_len`
// characters. If no `substring_len` is provided or `substring_len` is <= 0, the
// substring extends to the end of the input string.
message InjaTemplate { string text = 1; }

message Passthrough {}

message MergeExtractorsToBody {}

message HeaderBodyTransform {
  // When transforming a request, setting this to true will additionally add "queryString", 
  // "queryStringParameters", "multiValueQueryStringParameters", "httpMethod", "path",
  // and "multiValueHeaders" to the body
  bool add_request_metadata = 1;
}
