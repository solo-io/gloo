syntax = "proto3";
package gloo.solo.io;
option go_package = "github.com/solo-io/gloo/projects/gloo/pkg/api/v1";


import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";
import "extproto/ext.proto";
option (extproto.equal_all) = true;
option (extproto.hash_all) = true;
option (extproto.clone_all) = true;


// Fine tune the settings for connections to an upstream
message ConnectionConfig {
    // Maximum requests for a single upstream connection (unspecified or zero = no limit)
    uint32 max_requests_per_connection = 1;
    // The timeout for new network connections to hosts in the cluster
    google.protobuf.Duration connect_timeout = 2;

    // If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
    // see more info here: https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/core/address.proto#envoy-api-msg-core-tcpkeepalive
    message TcpKeepAlive{
        // Maximum number of keepalive probes to send without response before deciding the connection is dead.
        uint32 keepalive_probes = 1;
        // The number of seconds a connection needs to be idle before keep-alive probes start being sent. This is rounded up to the second.
        google.protobuf.Duration keepalive_time = 2;
        // The number of seconds between keep-alive probes. This is rounded up to the second.
        google.protobuf.Duration keepalive_interval = 3;
    }
    // Configure OS-level tcp keepalive checks
    TcpKeepAlive tcp_keepalive = 3;

    // Soft limit on size of the clusterâ€™s connections read and write buffers. If unspecified, an implementation defined default is applied (1MiB).
    // For more info, see the [envoy docs](https://www.envoyproxy.io/docs/envoy/v1.14.1/api-v2/api/v2/cluster.proto#cluster)
    google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 4;

    message HttpProtocolOptions {
        // The idle timeout for connections. The idle timeout is defined as the
        // period in which there are no active requests. When the
        // idle timeout is reached the connection will be closed. If the connection is an HTTP/2
        // downstream connection a drain sequence will occur prior to closing the connection, see
        // :ref:`drain_timeout
        // <envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.drain_timeout>`.
        // Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive.
        // If not specified, this defaults to 1 hour. To disable idle timeouts explicitly set this to 0.
        //
        // .. warning::
        //   Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP
        //   FIN packets, etc.
        google.protobuf.Duration idle_timeout = 1;

        // Note: max_connection_duration is not included here because it is "not implemented for upstream connections," per Envoy's documentation.

        // The maximum number of headers. If unconfigured, the default
        // maximum number of request headers allowed is 100. Requests that exceed this limit will receive
        // a 431 response for HTTP/1.x and cause a stream reset for HTTP/2.
        uint32 max_headers_count = 2;

        // Total duration to keep alive an HTTP request/response stream. If the time limit is reached the stream will be
        // reset independent of any other timeouts. If not specified, this value is not set.
        google.protobuf.Duration max_stream_duration = 3;

        // Action to take when Envoy receives client request with header names containing underscore
        // characters.
        // Underscore character is allowed in header names by the RFC-7230 and this behavior is implemented
        // as a security measure due to systems that treat '_' and '-' as interchangeable. Envoy by default allows client request headers with underscore
        // characters.
        enum HeadersWithUnderscoresAction {
            // Allow headers with underscores. This is the default behavior.
            ALLOW = 0;

            // Reject client request. HTTP/1 requests are rejected with the 400 status. HTTP/2 requests
            // end with the stream reset. The "httpN.requests_rejected_with_underscores_in_headers" counter
            // is incremented for each rejected request.
            REJECT_REQUEST = 1;

            // Drop the header with name containing underscores. The header is dropped before the filter chain is
            // invoked and as such filters will not see dropped headers. The
            // "httpN.dropped_headers_with_underscores" is incremented for each dropped header.
            DROP_HEADER = 2;
        }
        // Action to take when a client request with a header name containing underscore characters is received.
        // If this setting is not specified, the value defaults to ALLOW.
        // Note: upstream responses are not affected by this setting.
        HeadersWithUnderscoresAction headers_with_underscores_action = 4;
    }
    // Additional options when handling HTTP requests upstream. These options will be applicable to
    // both HTTP1 and HTTP2 requests.
    HttpProtocolOptions common_http_protocol_options = 5;

    message Http1ProtocolOptions {
        // Enables trailers for HTTP/1. By default the HTTP/1 codec drops proxied trailers.
        // Note: Trailers must also be enabled at the gateway level in order for this option to take effect. 
        bool enable_trailers = 1;

        oneof header_format {
            // Formats the REQUEST HEADER by proper casing words: the first character and any character following
            // a special character will be capitalized if it's an alpha character. For example,
            // "content-type" becomes "Content-Type", and "foo$b#$are" becomes "Foo$B#$Are".
            // Note that while this results in most headers following conventional casing, certain headers
            // are not covered. For example, the "TE" header will be formatted as "Te".
            bool proper_case_header_key_format = 22;
    
            // Generates configuration for a stateful formatter extension that allows using received headers to
            // affect the output of encoding headers. Specifically: preserving REQUEST HEADER case during proxying.
            bool preserve_case_header_key_format = 31;
        }

        // Allows invalid HTTP messaging. When this option is false, then Envoy will terminate
        // HTTP/1.1 connections upon receiving an invalid HTTP message. However,
        // when this option is true, then Envoy will leave the HTTP/1.1 connection
        // open where possible.
        // If set, this overrides any HCM :ref:`stream_error_on_invalid_http_messaging
        // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`.
        google.protobuf.BoolValue override_stream_error_on_invalid_http_message = 2;
    }

    // Additional Options when handling HTTP requests upstream. These options will be applicable only to HTTP1 requests.
    Http1ProtocolOptions http1_protocol_options = 6;
}
