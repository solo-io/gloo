syntax = "proto3";
package enterprise.gloo.solo.io;

option go_package = "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1";

import "github.com/solo-io/solo-kit/api/v1/ref.proto";

import "extproto/ext.proto";
option (extproto.equal_all) = true;
option (extproto.hash_all) = true;

import "github.com/solo-io/solo-kit/api/v1/metadata.proto";
import "github.com/solo-io/solo-kit/api/v1/status.proto";
import "github.com/solo-io/solo-kit/api/v1/solo-kit.proto";
import "github.com/solo-io/solo-kit/api/external/envoy/api/v2/discovery.proto";
import "google/api/annotations.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/wrappers.proto";
import "google/protobuf/empty.proto";

// This is the user-facing auth configuration. When processed by Gloo, certain configuration types (i.a. oauth, opa)
// will be translated, e.g. to resolve resource references. See the `ExtAuthConfig.AuthConfig` for the final config
// format that will be included in the extauth snapshot.
message AuthConfig {

    option (core.solo.io.resource).short_name = "ac";
    option (core.solo.io.resource).plural_name = "auth_configs";

    // Status indicates the validation status of this resource.
    // Status is read-only by clients, and set by gloo during validation
    core.solo.io.Status status = 1;

    // Metadata contains the object metadata for this resource
    core.solo.io.Metadata metadata = 2;

    message Config {

        // optional: used when defining complex boolean logic, if `boolean_expr` is defined below. Also used
        // in logging. If omitted, an automatically generated name will be used (e.g. config_0, of the
        // pattern 'config_$INDEX_IN_CHAIN'). In the case of plugin auth, this field is ignored in favor of
        // the name assigned on the plugin config itself.
        google.protobuf.StringValue name = 9;

        oneof auth_config {
            BasicAuth basic_auth = 1;
            OAuth oauth = 2 [deprecated = true];
            OAuth2 oauth2 = 8;
            ApiKeyAuth api_key_auth = 4;
            AuthPlugin plugin_auth = 5;
            OpaAuth opa_auth = 6;
            Ldap ldap = 7;
            // This is a "dummy" extauth service which can be used to support multiple auth mechanisms with JWT authentication.
            // If Jwt authentication is to be used in the [boolean expression](https://docs.solo.io/gloo-edge/latest/reference/api/github.com/solo-io/gloo/projects/gloo/api/v1/enterprise/options/extauth/v1/extauth.proto.sk/#authconfig) in an AuthConfig, you can use this auth config type to include Jwt as an Auth config.
            // In addition, `allow_missing_or_failed_jwt` must be set on the Virtual Host or Route that uses JWT auth or else the JWT filter will short circuit this behaviour.
            google.protobuf.Empty jwt = 11;
            PassThroughAuth pass_through_auth = 12;
        }
    }

    // List of auth configs to be checked for requests on a route referencing this auth config,
    // By default, every config must be authorized for the entire request to be authorized. This
    // behavior can be changed by defining names for each config and defining `boolean_expr` below.
    //
    // State is shared between successful requests on the chain, i.e., the headers returned from each
    // successful auth service get appended into the final auth response.
    repeated Config configs = 3;

    // How to handle processing of named configs within an auth config chain.
    // An example config might be: `( basic1 || basic2 || (oidc1 && !oidc2) )`
    // The boolean expression is evaluated left to right but honors parenthesis and short-circuiting.
    google.protobuf.StringValue boolean_expr = 10;
}

// Auth configurations defined on virtual hosts, routes, and weighted destinations will be unmarshalled to this message.
message ExtAuthExtension {
    oneof spec {
        //  Set to true to disable auth on the virtual host/route.
        bool disable = 1;
        // A reference to an AuthConfig. This is used to configure the GlooE extauth server.
        core.solo.io.ResourceRef config_ref = 2;
        // Use this field if you are running your own custom extauth server.
        CustomAuth custom_auth = 3;
    }
}

// Global external auth settings
message Settings {
    // The upstream to ask about auth decisions
    core.solo.io.ResourceRef extauthz_server_ref = 1;

    // If this is set, communication to the upstream will be via HTTP and not GRPC.
    HttpService http_service = 2;

    // If the auth server trusted id of the user, it will be set in this header.
    // Specifically this means that this header will be sanitized form the incoming request.
    string user_id_header = 3;

    // Timeout for the ext auth service to respond. Defaults to 200ms
    google.protobuf.Duration request_timeout = 4;

    // In case of a failure or timeout querying the auth server, normally a request is denied.
    // if this is set to true, the request will be allowed.
    bool failure_mode_allow = 5;

    // Set this if you also want to send the body of the request, and not just the headers.
    BufferSettings request_body = 6;

    // Clears route cache in order to allow the external authorization service to correctly affect
    // routing decisions. Filter clears all cached routes when:
    //
    // 1. The field is set to *true*.
    //
    // 2. The status returned from the authorization service is a HTTP 200 or gRPC 0.
    //
    // 3. At least one *authorization response header* is added to the client request, or is used for
    // altering another client request header.
    //
    bool clear_route_cache = 7;

    // Sets the HTTP status that is returned to the client when there is a network error between the
    // filter and the authorization server. The default status is HTTP 403 Forbidden.
    // If set, this must be one of the following:
    // - 100
    // - 200 201 202 203 204 205 206 207 208 226
    // - 300 301 302 303 304 305 307 308
    // - 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 421 422 423 424 426 428 429 431
    // - 500 501 502 503 504 505 506 507 508 510 511
    uint32 status_on_error = 8;

    // Describes the transport protocol version to use when connecting to the ext auth server.
    enum ApiVersion {
        // Use v2 API.
        V2 = 0;

        // Use v3 API.
        V3 = 1;
    }

    // Determines the API version for the `ext_authz` transport protocol that will be used by Envoy
    // to communicate with the auth server. Defaults to `V2`. For more info, see the `transport_api_version` field
    // [here](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/http/ext_authz/v3/ext_authz.proto#extensions-filters-http-ext-authz-v3-extauthz).
    ApiVersion transport_api_version = 9;
}

message HttpService {
    // Sets a prefix to the value of authorization request header *Path*.
    string path_prefix = 1;

    message Request {
        // These headers will be copied from the incoming request to the request going
        // to the auth server. Note that in addition to the user's supplied matchers:
        //
        // 1. *Host*, *Method*, *Path* and *Content-Length* are automatically included to the list.
        //
        // 2. *Content-Length* will be set to 0 and the request to the authorization service will not have
        // a message body.
        repeated string allowed_headers = 1;

        // These headers that will be included to the request to authorization service. Note that
        // client request of the same key will be overridden.
        map<string, string> headers_to_add = 2;
    }
    Request request = 2;

    message Response {
        // When this is set, authorization response headers that have a will be added to the original client request and sent to the upstream.
        // Note that coexistent headers will be overridden.
        repeated string allowed_upstream_headers = 1;

        // When this. is set, authorization response headers that will be added to the client's response when auth request is denied.
        // Note that when this list is *not* set, all the authorization response headers, except *Authority
        // (Host)* will be in the response to the client. When a header is included in this list, *Path*,
        // *Status*, *Content-Length*, *WWW-Authenticate* and *Location* are automatically added.
        repeated string allowed_client_headers = 2;
    }
    Response response = 3;
}

// Configuration for buffering the request data.
message BufferSettings {
    // Sets the maximum size of a message body that the filter will hold in memory. Envoy will return
    // *HTTP 413* and will *not* initiate the authorization process when buffer reaches the number
    // set in this field. Note that this setting will have precedence over failure_mode_allow.
    // Defaults to 4KB.
    uint32 max_request_bytes = 1;

    // When this field is true, Envoy will buffer the message until *max_request_bytes* is reached.
    // The authorization request will be dispatched and no 413 HTTP error will be returned by the
    // filter.
    bool allow_partial_message = 2;

    // When this field is true, Envoy will send the body sent to the external authorization service with raw bytes.
    bool pack_as_bytes = 3;
}

// Gloo is not expected to configure the ext auth server in this case.
// This is used with custom auth servers.
message CustomAuth {
    // When a request matches the virtual host, route, or weighted destination on which this configuration is defined,
    // Gloo will add the given context_extensions to the request that is sent to the external authorization server.
    // This allows the server to base the auth decision on metadata that you define on the source of the request.
    //
    // This attribute is analogous to Envoy's config.filter.http.ext_authz.v2.CheckSettings. See the official
    // [Envoy documentation](https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/filter/http/ext_authz/v2/ext_authz.proto.html?highlight=ext_authz#config-filter-http-ext-authz-v2-checksettings)
    // for more details.
    map<string, string> context_extensions = 1;
}

message AuthPlugin {
    // Name of the plugin
    string name = 1;
    // Name of the compiled plugin file. If not specified, GlooE will look for an ".so" file with same name as the plugin.
    string plugin_file_name = 2;
    // Name of the exported symbol that implements the plugin interface in the plugin.
    // If not specified, defaults to the name of the plugin
    string exported_symbol_name = 3;

    google.protobuf.Struct config = 4;
}

message BasicAuth {
    string realm = 1;

    message Apr {
        message SaltedHashedPassword {
            string salt = 1;
            string hashed_password = 2;
        }
        map<string, SaltedHashedPassword> users = 2;
    }
    Apr apr = 2;
}

// Deprecated: Prefer OAuth2
message OAuth {
    // your client id as registered with the issuer
    string client_id = 1 [deprecated = true];

    // your client secret as registered with the issuer
    core.solo.io.ResourceRef client_secret_ref = 2 [deprecated = true];

    // The url of the issuer. We will look for OIDC information in issuerUrl+
    // ".well-known/openid-configuration"
    string issuer_url = 3 [deprecated = true];

    // extra query parameters to apply to the Ext-Auth service's authorization request to the identity provider.
    map<string, string> auth_endpoint_query_params = 7 [deprecated = true];

    // we to redirect after successful auth, if we can't determine the original
    // url this should be your publicly available app url.
    string app_url = 4 [deprecated = true];

    // a callback path relative to app url that will be used for OIDC callbacks.
    // needs to not be used by the application
    string callback_path = 5 [deprecated = true];

    // Scopes to request in addition to openid scope.
    repeated string scopes = 6 [deprecated = true];
}

message OAuth2 {
    oneof oauth_type {
        // provide issuer location and let gloo handle OIDC flow for you.
        // requests authorized by validating the contents of ID token.
        // can also authorize the access token if configured.
        OidcAuthorizationCode oidc_authorization_code = 1;

        // provide the access token on the request and let gloo handle authorization.
        //
        // according to https://tools.ietf.org/html/rfc6750 you can pass tokens through:
        // - form-encoded body parameter. recommended, more likely to appear. e.g.: Authorization: Bearer mytoken123
        // - URI query parameter e.g. access_token=mytoken123
        // - and (preferably) secure cookies
        AccessTokenValidation access_token_validation = 2;
    }
}

message RedisOptions {
    // address of the redis. can be address:port or unix://path/to/unix.sock
    string host = 1;
    // db to use. can leave unset for db 0.
    int32 db = 2;
    // size of the connection pool. can leave unset for default.
    // defaults to 10 connections per every CPU
    int32 pool_size = 3;
}

message UserSession {
    message InternalSession {
    }
    message RedisSession {
        // Options to connect to redis
        RedisOptions options = 1;
        // Key prefix inside redis
        string key_prefix = 2;
        // Cookie name to set and store the session id. If empty the default "__session" is used.
        string cookie_name = 3;
        // When set, refresh expired id-tokens using the refresh-token. Defaults to true.
        // Explicitly set to false to disable refreshing.
        google.protobuf.BoolValue allow_refreshing = 4;
    }

    // should we fail auth flow when failing to get a session from redis, or allow it to continue,
    // potentially starting a new auth flow and setting a new session.
    bool fail_on_fetch_failure = 1;

    message CookieOptions {
        // Max age for the cookie. Leave unset for a default of 30 days (2592000 seconds).
        // To disable cookie expiry, set explicitly to 0.
        google.protobuf.UInt32Value max_age = 1;
        // Use a non-secure cookie. Note - this should only be used for testing and in trusted
        // environments.
        bool not_secure = 2;
        // Path of the cookie. If unset, defaults to "/". Set it explicitly to "" to avoid setting a
        // path.
        google.protobuf.StringValue path = 3;
        // Cookie domain
        string domain = 4;
    }

    // Set-Cookie options
    CookieOptions cookie_options = 2;
    oneof session {
        // Set the tokens in the cookie itself. No need for server side state.
        InternalSession cookie = 3;
        // Use redis to store the tokens and just store a random id in the cookie.
        RedisSession redis = 4;
    }
}

message HeaderConfiguration {
    // If set, the id token will be forward upstream using this header name.
    string id_token_header = 1;
    // If set, the access token will be forward upstream using this header name.
    string access_token_header = 2;
}

// OIDC configuration is discovered at <issuerUrl>/.well-known/openid-configuration
// The discovery override defines any properties that should override this discovery configuration
// https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata
message DiscoveryOverride {
    // url of the provider authorization endpoint
    string auth_endpoint = 1;

    // url of the provider token endpoint
    string token_endpoint = 2;

    // url of the provider json web key set
    string jwks_uri = 3;

    // list of scope values that the provider supports
    repeated string scopes = 4;

    // list of response types that the provider supports
    repeated string response_types = 5;

    // list of subject identifier types that the provider supports
    repeated string subjects = 6;

    // list of json web signature signing algorithms that the provider supports for encoding claims in a jwt
    repeated string id_token_algs = 7;

    // list of client authentication methods supported by the provider token endpoint
    repeated string auth_methods = 8;

    // list of claim types that the provider supports
    repeated string claims = 9;
}


message OidcAuthorizationCode {
    // your client id as registered with the issuer
    string client_id = 1;

    // your client secret as registered with the issuer
    core.solo.io.ResourceRef client_secret_ref = 2;

    // The url of the issuer. We will look for OIDC information in issuerUrl+
    // ".well-known/openid-configuration"
    string issuer_url = 3;

    // extra query parameters to apply to the Ext-Auth service's authorization request to the identity provider.
    map<string, string> auth_endpoint_query_params = 4;

    // we to redirect after successful auth, if we can't determine the original
    // url this should be your publicly available app url.
    string app_url = 5;

    // a callback path relative to app url that will be used for OIDC callbacks.
    // should not be used by the application.
    string callback_path = 6;

    // a path relative to app url that will be used for logging out from an OIDC session.
    // should not be used by the application.
    // If not provided, logout functionality will be disabled.
    string logout_path = 9;

    // Scopes to request in addition to openid scope.
    repeated string scopes = 7;

    // Configuration related to the user session.
    UserSession session = 8;

    // Configures headers added to requests.
    HeaderConfiguration headers = 10;

    // OIDC configuration is discovered at <issuerUrl>/.well-known/openid-configuration
    // The discovery override defines any properties that should override this discovery configuration
    // For example, the following AuthConfig CRD could be defined as:
    //    ```yaml
    //    apiVersion: enterprise.gloo.solo.io/v1
    //    kind: AuthConfig
    //    metadata:
    //      name: google-oidc
    //      namespace: gloo-system
    //    spec:
    //      configs:
    //      - oauth:
    //          app_url: http://localhost:8080
    //          callback_path: /callback
    //          client_id: $CLIENT_ID
    //          client_secret_ref:
    //            name: google
    //            namespace: gloo-system
    //          issuer_url: https://accounts.google.com
    //          discovery_override:
    //            token_endpoint: "https://token.url/gettoken"
    //    ```
    //
    // And this will ensure that regardless of what value is discovered at
    // <issuerUrl>/.well-known/openid-configuration, "https://token.url/gettoken" will be used as the token endpoint
    DiscoveryOverride discovery_override = 11;

    // in the future we may implement this:
    // add optional configuration for validation of the access token received during the OIDC flow
    // AccessTokenValidation access_token_validation = 8;
}

message AccessTokenValidation {

    oneof validation_type {
        // the url for the OAuth2.0 access token introspection endpoint.
        // if provided, the (opaque) access token provided or received from the oauth authorization endpoint
        // will be validated against this endpoint, or locally cached responses for this access token.
        string introspection_url = 1;

        // in the future we may implement jwt and hmac validation
    }

    // the url for the OIDC userinfo endpoint.
    // if provided, the (opaque) access token provided or received from the oauth endpoint
    // will be queried and the userinfo response (or cached response) will be put in the `AuthorizationRequest` state.
    // this can be useful to leverage the userinfo response in, for example, an extauth server plugin.
    string userinfo_url = 4;

    // how long the token introspection and userinfo endpoint response for a specific access token should be kept
    // in the in-memory cache. the result will be invalidated at this timeout, or at "exp" time from the introspection
    // result, whichever comes sooner. if omitted, defaults to 10 minutes. if zero, then no caching will be done.
    google.protobuf.Duration cache_timeout = 5;
}

message OauthSecret {
    string client_secret = 1;
}

message ApiKeyAuth {
    // Identify all valid API key secrets that match the provided label selector.<br/>
    // API key secrets must be in one of the watch namespaces for gloo to locate them.
    map<string, string> label_selector = 1;

    // A way to directly reference API key secrets. This configuration can be useful for testing,
    // but in general the more flexible label selector should be preferred.
    repeated core.solo.io.ResourceRef api_key_secret_refs = 2;

    // When receiving a request, the Gloo Enterprise external auth server will look for an API key in a header
    // with this name. This field is optional; if not provided it defaults to `api-key`.
    string header_name = 3;

    // API key secrets might contain additional data (e.g. the ID of the user that the API key belongs to)
    // in the form of extra keys included in the secret's `data` field.
    // This configuration can be used to add this data to the headers of successfully authenticated requests.
    // Each key in the map represents the name of header to be added; the corresponding value determines the key
    // in the secret data that will be inspected to determine the value for the header.
    map<string, SecretKey> headers_from_metadata = 4;

    message SecretKey {
        // (Required) The key of the secret data entry to inspect.
        string name = 1;
        // If this field is set to `true`, Gloo will reject an API key secret that does not contain the given key.
        // Defaults to `false`. In this case, if a secret does not contain the requested data, no header will be added
        // to the request.
        bool required = 2;
    }
}

message ApiKeySecret {
    // If true, generate an API key.
    // This field is deprecated as it was used only internally by `glooctl` and is not actually part of the secret API.
    bool generate_api_key = 1 [deprecated = true];
    // The value of the API key.
    string api_key = 2;
    // A list of labels (key=value) for the apikey secret.<br/>
    // These labels are used when creating an ApiKeySecret via `glooctl` and then are copied to the metadata of the created secret.
    // This field is deprecated as it was used only internally by `glooctl` and is not actually part of the secret API.
    repeated string labels = 3 [deprecated = true];
    // If the secret data contains entries in addition to the API key one, they will be copied to this field.
    map<string, string> metadata = 4;
}

message OpaAuth {
    // An optional resource reference to config maps containing modules to assist in the resolution of `query`.
    repeated core.solo.io.ResourceRef modules = 1;

    // The query that determines the auth decision. The result of this query must be either a boolean
    // or an array with boolean as the first element. A boolean `true` value means that the request
    // will be authorized. Any other value, or error, means that the request will be denied.
    string query = 2;
}

// Authenticates and authorizes requests by querying an LDAP server. Gloo makes the following assumptions:
//  * Requests provide credentials via the basic HTTP authentication header. Gloo will BIND to the LDAP server using the
//    credentials extracted from the header.
//  * Your LDAP server is configured so that each entry you want to authorize has an attribute that indicates its group
//    memberships. A common way of achieving this is by using the [*memberof* overlay](http://www.openldap.org/software/man.cgi?query=slapo-memberof).
message Ldap {

    // Configuration properties for pooling connections to the LDAP server. If the pool is exhausted when a connection
    // is requested (meaning that all the polled connections are in use), the connection will be created on the fly.
    message ConnectionPool {
        // Maximum number connections that are pooled at any give time. The default value is 5.
        google.protobuf.UInt32Value maxSize = 1;
        // Number of connections that the pool will be pre-populated with upon initialization. The default value is 2.
        google.protobuf.UInt32Value initialSize = 2;
    }

    // Address of the LDAP server to query. Should be in the form ADDRESS:PORT, e.g. `ldap.default.svc.cluster.local:389`.
    string address = 1;

    // Template to build user entry distinguished names (DN). This must contains a single occurrence of the "%s" placeholder.
    // When processing a request, Gloo will substitute the name of the user (extracted from the auth header) for the
    // placeholder and issue a search request with the resulting DN as baseDN (and 'base' search scope).
    // E.g. "uid=%s,ou=people,dc=solo,dc=io"
    string userDnTemplate = 2;

    // Case-insensitive name of the attribute that contains the names of the groups an entry is member of. Gloo will look
    // for attributes with the given name to determine which groups the user entry belongs to. Defaults to 'memberOf' if not provided.
    string membershipAttributeName = 3;

    // In order for the request to be authenticated, the membership attribute (e.g. *memberOf*) on the user entry must
    // contain at least of one of the group DNs specified via this option.
    // E.g. []string{ "cn=managers,ou=groups,dc=solo,dc=io", "cn=developers,ou=groups,dc=solo,dc=io" }
    repeated string allowedGroups = 4;

    // Use this property to tune the pool of connections to the LDAP server that Gloo maintains.
    ConnectionPool pool = 5;
}

// Authorizes requests by querying a custom extauth server.
message PassThroughAuth {

    oneof protocol {
        PassThroughGrpc grpc = 1;
    }
}

// Authorizes requests by querying a custom extauth grpc server
// Assumes that the server implements the envoy external authorization spec:
// https://github.com/envoyproxy/envoy/blob/ae1ed1fa74f096dabe8dd5b19fc70333621b0309/api/envoy/service/auth/v3/external_auth.proto#L29
message PassThroughGrpc {

    // Address of the auth server to query. Should be in the form ADDRESS:PORT, e.g. `default.svc.cluster.local:389`.
    string address = 1;

    // Timeout for the auth server to respond. Defaults to 5s
    google.protobuf.Duration connection_timeout = 2;
}

/*
@solo-kit:xds-service=ExtAuthDiscoveryService
@solo-kit:resource.no_references
 */
message ExtAuthConfig {

    // @solo-kit:resource.name
    // This is the identifier of the AuthConfig resource that this configuration is associated with.
    // Any request to the external auth server includes an identifier that is matched against this field to determine
    // which AuthConfig should be applied to it.
    string auth_config_ref_name = 1;

    // Deprecated, prefer OAuth2Config
    message OAuthConfig {
        // your client id as registered with the issuer
        string client_id = 1 [deprecated = true];

        // your client secret as registered with the issuer
        string client_secret = 2 [deprecated = true, (extproto.sensitive) = true];

        // The url of the issuer. We will look for OIDC information in issuerUrl+
        // ".well-known/openid-configuration"
        string issuer_url = 3 [deprecated = true];

        // extra query parameters to apply to the Ext-Auth service's authorization request to the identity provider.
        map<string, string> auth_endpoint_query_params = 7 [deprecated = true];

        // we to redirect after successful auth, if we can't determine the original
        // url this should be your publicly available app url.
        string app_url = 4 [deprecated = true];

        // a callback path relative to app url that will be used for OIDC callbacks.
        // needs to not be used by the application
        string callback_path = 5 [deprecated = true];

        // scopes to request in addition to the openid scope.
        repeated string scopes = 6 [deprecated = true];

    }

    message OidcAuthorizationCodeConfig {

        // your client id as registered with the issuer
        string client_id = 1;

        // your client secret as registered with the issuer
        string client_secret = 2 [(extproto.sensitive) = true];

        // The url of the issuer. We will look for OIDC information in issuerUrl+
        // ".well-known/openid-configuration"
        string issuer_url = 3;

        // extra query parameters to apply to the Ext-Auth service's authorization request to the identity provider.
        map<string, string> auth_endpoint_query_params = 4;

        // we to redirect after successful auth, if we can't determine the original
        // url this should be your publicly available app url.
        string app_url = 5;

        // a callback path relative to app url that will be used for OIDC callbacks.
        // needs to not be used by the application
        string callback_path = 6;

        // a path relative to app url that will be used for logging out from an OIDC session.
        // should not be used by the application.
        // If not provided, logout functionality will be disabled.
        string logout_path = 9;

        // scopes to request in addition to the openid scope.
        repeated string scopes = 7;

        UserSession session = 8;

        // Configures headers added to requests.
        HeaderConfiguration headers = 10;

        // OIDC configuration is discovered at <issuerUrl>/.well-known/openid-configuration
        // The configuration override defines any properties that should override this discovery configuration
        // For example, the following AuthConfig CRD could be defined as:
        //    ```yaml
        //    apiVersion: enterprise.gloo.solo.io/v1
        //    kind: AuthConfig
        //    metadata:
        //      name: google-oidc
        //      namespace: gloo-system
        //    spec:
        //      configs:
        //      - oauth:
        //          app_url: http://localhost:8080
        //          callback_path: /callback
        //          client_id: $CLIENT_ID
        //          client_secret_ref:
        //            name: google
        //            namespace: gloo-system
        //          issuer_url: https://accounts.google.com
        //          discovery_override:
        //            token_endpoint: "https://token.url/gettoken"
        //    ```
        //
        // And this will ensure that regardless of what value is discovered at
        // <issuerUrl>/.well-known/openid-configuration, "https://token.url/gettoken" will be used as the token endpoint
        DiscoveryOverride discovery_override = 11;

        // in the future we may implement this:
        // add optional configuration for validation of the access token received during the OIDC flow
        // AccessTokenValidation access_token_validation = 8;
    }

    message OAuth2Config {
        oneof oauth_type {
            // provide issuer location and let gloo handle OIDC flow for you.
            // requests authorized by validating the contents of ID token.
            // can also authorize the access token if configured.
            OidcAuthorizationCodeConfig oidc_authorization_code = 1;

            // provide the access token on the request and let gloo handle authorization.
            //
            // according to https://tools.ietf.org/html/rfc6750 you can pass tokens through:
            // - form-encoded body parameter. recommended, more likely to appear. e.g.: Authorization: Bearer mytoken123
            // - URI query parameter e.g. access_token=mytoken123
            // - and (preferably) secure cookies
            AccessTokenValidation access_token_validation = 2;
        }
    }

    // **NOTE: This configuration is not user-facing and will be auto generated**
    message ApiKeyAuthConfig {

        message KeyMetadata {
            // The user is mapped as the name of `Secret` which contains the `ApiKeySecret`
            string username = 1;
            // The metadata present on the `ApiKeySecret`.
            map<string, string> metadata = 2;
        }

        // A mapping of valid API keys to their associated metadata.
        // This map is automatically populated with the information from the relevant `ApiKeySecret`s.
        map<string, KeyMetadata> valid_api_keys = 1 [(extproto.sensitive) = true];

        // (Optional) When receiving a request, the Gloo Enterprise external auth server will look for an API key
        // in a header with this name. This field is optional; if not provided it defaults to `api-key`.
        string header_name = 2;

        // Determines the key metadata that will be included as headers on the upstream request.
        // Each entry represents a header to add: the key is the name of the header, and the
        // value is the key that will be used to look up the data entry in the key metadata.
        map<string, string> headers_from_key_metadata = 3;
    }

    message OpaAuthConfig {
        // An optional modules (filename, module content) maps containing modules assist in the resolution of `query`.
        map<string, string> modules = 1;

        // The query that determines the auth decision. The result of this query must be either a boolean
        // or an array with boolean as the first element. A boolean `true` value means that the request
        // will be authorized. Any other value, or error, means that the request will be denied.
        string query = 2;
    }

    message Config {

        reserved 1, 2;

        // optional: used when defining complex boolean logic, if `boolean_expr` is defined below. Also used
        // in logging. If omitted, an automatically generated name will be used (e.g. config_0, of the
        // pattern 'config_$INDEX_IN_CHAIN'). In the case of plugin auth, this field is ignored in favor of
        // the name assigned on the plugin config itself.
        google.protobuf.StringValue name = 11;

        oneof auth_config {
            OAuthConfig oauth = 3 [deprecated = true];
            OAuth2Config oauth2 = 9;
            BasicAuth basic_auth = 4;
            ApiKeyAuthConfig api_key_auth = 5;
            AuthPlugin plugin_auth = 6;
            OpaAuthConfig opa_auth = 7;
            Ldap ldap = 8;
            // This is a "dummy" extauth service which can be used to support multiple auth mechanisms with JWT authentication.
            // If Jwt authentication is to be used in the [boolean expression](https://docs.solo.io/gloo-edge/latest/reference/api/github.com/solo-io/gloo/projects/gloo/api/v1/enterprise/options/extauth/v1/extauth.proto.sk/#authconfig) in an AuthConfig, you can use this auth config type to include Jwt as an Auth config.
            // In addition, `allow_missing_or_failed_jwt` must be set on the Virtual Host or Route that uses JWT auth or else the JWT filter will short circuit this behaviour.
            google.protobuf.Empty jwt = 12;
            PassThroughAuth pass_through_auth = 13;
        }
    }

    // List of auth configs to be checked for requests on a route referencing this auth config,
    // By default, every config must be authorized for the entire request to be authorized. This
    // behavior can be changed by defining names for each config and defining `boolean_expr` below.
    //
    // State is shared between successful requests on the chain, i.e., the headers returned from each
    // successful auth service get appended into the final auth response.
    repeated Config configs = 8;

    // How to handle processing of named configs within an auth config chain.
    // An example config might be: `( basic1 || basic2 || (oidc1 && !oidc2) )`
    // The boolean expression is evaluated left to right but honors parenthesis and short-circuiting.
    google.protobuf.StringValue boolean_expr = 10;
}

/*
@solo-kit:resource.xds-enabled
*/
service ExtAuthDiscoveryService {
    rpc StreamExtAuthConfig (stream envoy.api.v2.DiscoveryRequest) returns (stream envoy.api.v2.DiscoveryResponse) {
    }

    rpc DeltaExtAuthConfig (stream envoy.api.v2.DeltaDiscoveryRequest) returns (stream envoy.api.v2.DeltaDiscoveryResponse) {
    }

    rpc FetchExtAuthConfig (envoy.api.v2.DiscoveryRequest) returns (envoy.api.v2.DiscoveryResponse) {
        option (google.api.http) = {
      post : "/v2/discovery:extauthconfig"
      body : "*"
    };
    }
}
