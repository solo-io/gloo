syntax = "proto3";
package enterprise.gloo.solo.io;

option go_package = "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1";

import "github.com/solo-io/solo-kit/api/v1/ref.proto";

import "extproto/ext.proto";
option (extproto.equal_all) = true;
option (extproto.hash_all) = true;
option (extproto.clone_all) = true;

import "github.com/solo-io/solo-kit/api/v1/metadata.proto";
import "github.com/solo-io/solo-kit/api/v1/status.proto";
import "github.com/solo-io/solo-kit/api/v1/solo-kit.proto";
import "github.com/solo-io/solo-kit/api/external/envoy/api/v2/discovery.proto";
import "google/api/annotations.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/wrappers.proto";
import "google/protobuf/empty.proto";

// This is the user-facing auth configuration. When processed by Gloo, certain configuration types (i.a. oauth, opa)
// will be translated, e.g. to resolve resource references. See the `ExtAuthConfig.AuthConfig` for the final config
// format that will be included in the extauth snapshot.
message AuthConfig {

    option (core.solo.io.resource).short_name = "ac";
    option (core.solo.io.resource).plural_name = "auth_configs";

    reserved 1;
    // NamespacedStatuses indicates the validation status of this resource.
    // NamespacedStatuses is read-only by clients, and set by gloo during validation
    core.solo.io.NamespacedStatuses namespaced_statuses = 13 [(extproto.skip_hashing) = true];

    // Metadata contains the object metadata for this resource
    core.solo.io.Metadata metadata = 2;

    message Config {

        // optional: used when defining complex boolean logic, if `boolean_expr` is defined below. Also used
        // in logging. If omitted, an automatically generated name will be used (e.g. config_0, of the
        // pattern 'config_$INDEX_IN_CHAIN'). In the case of plugin auth, this field is ignored in favor of
        // the name assigned on the plugin config itself.
        google.protobuf.StringValue name = 9;

        oneof auth_config {
            BasicAuth basic_auth = 1;
            OAuth oauth = 2 [deprecated = true];
            OAuth2 oauth2 = 8;
            ApiKeyAuth api_key_auth = 4;
            AuthPlugin plugin_auth = 5;
            OpaAuth opa_auth = 6;
            Ldap ldap = 7;
            // This is a "dummy" extauth service which can be used to support multiple auth mechanisms with JWT authentication.
            // If Jwt authentication is to be used in the [boolean expression](https://docs.solo.io/gloo-edge/latest/reference/api/github.com/solo-io/gloo/projects/gloo/api/v1/enterprise/options/extauth/v1/extauth.proto.sk/#authconfig) in an AuthConfig, you can use this auth config type to include Jwt as an Auth config.
            // In addition, `allow_missing_or_failed_jwt` must be set on the Virtual Host or Route that uses JWT auth or else the JWT filter will short circuit this behaviour.
            google.protobuf.Empty jwt = 11;
            PassThroughAuth pass_through_auth = 12;
            HmacAuth hmac_auth = 13;
        }
    }

    // List of auth configs to be checked for requests on a route referencing this auth config,
    // By default, every config must be authorized for the entire request to be authorized. This
    // behavior can be changed by defining names for each config and defining `boolean_expr` below.
    //
    // State is shared between successful requests on the chain, i.e., the headers returned from each
    // successful auth service get appended into the final auth response.
    repeated Config configs = 3;

    // How to handle processing of named configs within an auth config chain.
    // An example config might be: `( basic1 || basic2 || (oidc1 && !oidc2) )`
    // The boolean expression is evaluated left to right but honors parenthesis and short-circuiting.
    google.protobuf.StringValue boolean_expr = 10;

    // How the service should handle a redirect response from an OIDC issuer. In the default false mode,
    // the redirect will be considered a successful response, and the client will receive a 302 with a location header.
    // If this is set to true, the client will instead receive a 401 unauthorized response. This is useful in cases where
    // API calls are being made or other such occurrences where the client cannot handle the redirect.
    bool fail_on_redirect = 11;
}

// Auth configurations defined on virtual hosts, routes, and weighted destinations will be unmarshalled to this message.
message ExtAuthExtension {
    oneof spec {
        //  Set to true to disable auth on the virtual host/route.
        bool disable = 1;
        // A reference to an AuthConfig. This is used to configure the Gloo Edge Enterprise extauth server.
        core.solo.io.ResourceRef config_ref = 2;
        // Use this field if you are running your own custom extauth server.
        CustomAuth custom_auth = 3;
    }
}

// Global external auth settings
message Settings {
    // The upstream to ask about auth decisions
    core.solo.io.ResourceRef extauthz_server_ref = 1;

    oneof service_type {
        // If this is set, communication to the upstream will be via HTTP and not GRPC (default).
        HttpService http_service = 2;

        // Optional, if set the communication to the upstream will be via GRPC.
        GrpcService grpc_service = 11;
    }


    // If the auth server trusted id of the user, it will be set in this header.
    // Specifically this means that this header will be sanitized form the incoming request.
    string user_id_header = 3;

    // Timeout for the ext auth service to respond. Defaults to 200ms
    google.protobuf.Duration request_timeout = 4;

    // In case of a failure or timeout querying the auth server, normally a request is denied.
    // if this is set to true, the request will be allowed.
    bool failure_mode_allow = 5;

    // Set this if you also want to send the body of the request, and not just the headers.
    BufferSettings request_body = 6;

    // Clears route cache in order to allow the external authorization service to correctly affect
    // routing decisions. Filter clears all cached routes when:
    //
    // 1. The field is set to *true*.
    //
    // 2. The status returned from the authorization service is a HTTP 200 or gRPC 0.
    //
    // 3. At least one *authorization response header* is added to the client request, or is used for
    // altering another client request header.
    //
    bool clear_route_cache = 7;

    // Sets the HTTP status that is returned to the client when there is a network error between the
    // filter and the authorization server. The default status is HTTP 403 Forbidden.
    // If set, this must be one of the following:
    // - 100
    // - 200 201 202 203 204 205 206 207 208 226
    // - 300 301 302 303 304 305 307 308
    // - 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 421 422 423 424 426 428 429 431
    // - 500 501 502 503 504 505 506 507 508 510 511
    uint32 status_on_error = 8;

    // Describes the transport protocol version to use when connecting to the ext auth server.
    enum ApiVersion {
        // Use v3 API.
        V3 = 0;
    }

    // Determines the API version for the `ext_authz` transport protocol that will be used by Envoy
    // to communicate with the auth server. Defaults to `V2`. For more info, see the `transport_api_version` field
    // [here](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/http/ext_authz/v3/ext_authz.proto#extensions-filters-http-ext-authz-v3-extauthz).
    ApiVersion transport_api_version = 9;

    // Optional additional prefix to use when emitting statistics.
    // This allows to distinguish emitted statistics between configured ext_authz filters in an HTTP filter chain.
    string stat_prefix = 10;
}

message GrpcService {
    // Set the authority header when calling the GRPC service.
    string authority = 1;
}

message HttpService {
    // Sets a prefix to the value of authorization request header *Path*.
    string path_prefix = 1;

    message Request {
        // These headers will be copied from the incoming request to the request going
        // to the auth server. Note that in addition to the user's supplied matchers:
        //
        // 1. *Host*, *Method*, *Path* and *Content-Length* are automatically included to the list.
        //
        // 2. *Content-Length* will be set to 0 and the request to the authorization service will not have
        // a message body.
        repeated string allowed_headers = 1;

        // These headers that will be included to the request to authorization service. Note that
        // client request of the same key will be overridden.
        map<string, string> headers_to_add = 2;

        // Headers that match these regex patterns will be copied from the incoming request
        // to the request going to the auth server.
        repeated string allowed_headers_regex = 3;
    }
    Request request = 2;

    message Response {
        // When this is set, authorization response headers that have a header in this list will be added to the original client request and sent to the upstream.
        // Note that coexistent headers will be overridden.
        repeated string allowed_upstream_headers = 1;

        // When this is set, authorization response headers in this list will be added to the client's response when the auth request is denied.
        // Note that when this list is *not* set, all the authorization response headers, except *Authority
        // (Host)* will be in the response to the client. When a header is included in this list, *Path*,
        // *Status*, *Content-Length*, *WWW-Authenticate* and *Location* are automatically added.
        repeated string allowed_client_headers = 2;

        // When this is set, authorization response headers that have a correspondent match will be added to the client's response.
        // Note that coexistent headers will be appended.
        repeated string allowed_upstream_headers_to_append = 3;
    }
    Response response = 3;
}

// Configuration for buffering the request data.
message BufferSettings {
    // Sets the maximum size of a message body that the filter will hold in memory. Envoy will return
    // *HTTP 413* and will *not* initiate the authorization process when buffer reaches the number
    // set in this field. Note that this setting will have precedence over failure_mode_allow.
    // Defaults to 4KB.
    uint32 max_request_bytes = 1;

    // When this field is true, Envoy will buffer the message until *max_request_bytes* is reached.
    // The authorization request will be dispatched and no 413 HTTP error will be returned by the
    // filter.
    bool allow_partial_message = 2;

    // When this field is true, Envoy will send the body sent to the external authorization service with raw bytes.
    bool pack_as_bytes = 3;
}

// Gloo is not expected to configure the ext auth server in this case.
// This is used with custom auth servers.
message CustomAuth {
    // When a request matches the virtual host, route, or weighted destination on which this configuration is defined,
    // Gloo will add the given context_extensions to the request that is sent to the external authorization server.
    // This allows the server to base the auth decision on metadata that you define on the source of the request.
    //
    // This attribute is analogous to Envoy's config.filter.http.ext_authz.v2.CheckSettings. See the official
    // [Envoy documentation](https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/filter/http/ext_authz/v2/ext_authz.proto.html?highlight=ext_authz#config-filter-http-ext-authz-v2-checksettings)
    // for more details.
    map<string, string> context_extensions = 1;

    // [Enterprise-only]
    // Only required in the case where multiple auth servers are configured in Settings
    // This name must match a key in the named_extauth Settings.
    string name = 2;
}

message AuthPlugin {
    // Name of the plugin
    string name = 1;
    // Name of the compiled plugin file. If not specified, Gloo Edge will look for an ".so" file with same name as the plugin.
    string plugin_file_name = 2;
    // Name of the exported symbol that implements the plugin interface in the plugin.
    // If not specified, defaults to the name of the plugin
    string exported_symbol_name = 3;

    google.protobuf.Struct config = 4;
}

message BasicAuth {
    string realm = 1;

    message Apr {
        message SaltedHashedPassword {
            string salt = 1;
            string hashed_password = 2;
        }
        map<string, SaltedHashedPassword> users = 2;
    }
    Apr apr = 2;
}

// HMAC is a message authentication technique that can use multiple algorithms for finding credentials and generating signed messages.
// It conforms to https://www.ietf.org/rfc/rfc2104.txt
message HmacAuth {
    // Configuration for how secrets are stored.
    oneof secret_storage {
        SecretRefList secret_refs = 1;
    }
    // Algorithm to use to turn the request into a hashable string
    oneof implementation_type{
        HmacParametersInHeaders parameters_in_headers = 2;
    }
}
message SecretRefList {
    // list of secrets as registered with the issuer
    repeated core.solo.io.ResourceRef secret_refs = 1;
}
// Extract the HMAC parameters from the HTTP headers and use SHA-1 hashing
message HmacParametersInHeaders {}

// Deprecated: Prefer OAuth2
message OAuth {
    // your client id as registered with the issuer
    string client_id = 1 [deprecated = true];

    // your client secret as registered with the issuer
    core.solo.io.ResourceRef client_secret_ref = 2 [deprecated = true];

    // The url of the issuer. We will look for OIDC information in issuerUrl+
    // ".well-known/openid-configuration"
    string issuer_url = 3 [deprecated = true];

    // extra query parameters to apply to the Ext-Auth service's authorization request to the identity provider.
    map<string, string> auth_endpoint_query_params = 7 [deprecated = true];

    // we to redirect after successful auth, if we can't determine the original
    // url this should be your publicly available app url.
    string app_url = 4 [deprecated = true];

    // a callback path relative to app url that will be used for OIDC callbacks.
    // needs to not be used by the application
    string callback_path = 5 [deprecated = true];

    // Scopes to request in addition to openid scope.
    repeated string scopes = 6 [deprecated = true];
}

message OAuth2 {
    oneof oauth_type {
        // provide issuer location and let gloo handle OIDC flow for you.
        // requests authorized by validating the contents of ID token.
        // can also authorize the access token if configured.
        OidcAuthorizationCode oidc_authorization_code = 1;

        // provide the access token on the request and let gloo handle authorization.
        //
        // according to https://tools.ietf.org/html/rfc6750 you can pass tokens through:
        // - form-encoded body parameter. recommended, more likely to appear. e.g.: Authorization: Bearer mytoken123
        // - URI query parameter e.g. access_token=mytoken123
        // - and (preferably) secure cookies
        AccessTokenValidation access_token_validation = 2;

        // Enterprise-Only: THIS FEATURE IS IN TECH PREVIEW. APIs are versioned as alpha and subject to change.
        // provide issuer location and let Gloo handle Oauth2 flow for you.
        // requests authorized by validating the contents of access token.
        // Prefer to use OIDC for better security.
        PlainOAuth2 oauth2 = 3;
    }
}

message RedisOptions {
    // address of the redis. can be address:port or unix://path/to/unix.sock
    string host = 1;
    // db to use. can leave unset for db 0.
    int32 db = 2;
    // size of the connection pool. can leave unset for default.
    // defaults to 10 connections per every CPU
    int32 pool_size = 3;
	// enabled with a socket type of TLS. this is the tls cert mount path for this particular host.
	// the generic secret can include the keys 'ca.crt', 'tls.crt', and 'tls.key'.
	// the secret can contain the root-ca ,'ca.crt', at minimum. If a
	// certificate is needed, both the 'tls.crt' and 'tls.key' need to be included.
	// reference this to equal the 'mountPath' on the 'redis.certs[x].mountPath' in the helm chart values.
	// an example of a mount path is '/certs'.
    string tls_cert_mount_path = 4;
    // redis socket types
    enum SocketType {
        // TCP connection socket, this is the default.
        TCP = 0;
        // TLS connection socket.
        TLS = 1;
    }
    // the socket type, default is TCP.
    SocketType socket_type = 5;
}

message UserSession {
    message InternalSession {
        // Refresh expired id-tokens using the refresh-token. The tokens refreshes when the client issues a call.
        // Defaults to false. To enable refreshing, set to true.
        google.protobuf.BoolValue allow_refreshing = 1;
        // Prefix to append to cookie keys, such as for separate domain and subdomain prefixes.
        // Cookie keys are stored in the form `<key_prefix>_<cookie_name>`.
        // For more information, see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#attributes
        string key_prefix = 2;
        // Domain used to validate against requests in order to ensure that request host name matches target domain.
        // If the target domain is provided will prevent requests that do not match the target domain according to
        // the domain matching specifications in RFC 6265. For more information, see https://datatracker.ietf.org/doc/html/rfc6265#section-5.1.3
        string target_domain = 3;
    }
    message RedisSession {
        // Options to connect to redis
        RedisOptions options = 1;
        // Key prefix inside redis
        string key_prefix = 2;
        // Cookie name to set and store the session id. If empty the default "__session" is used.
        string cookie_name = 3;
        // Refresh expired id-tokens using the refresh-token. The tokens refreshes when the client issues a call.
        // Defaults to true. To disable refreshing, set to false.
        google.protobuf.BoolValue allow_refreshing = 4;
        // Specifies a time buffer in which an id-token will be refreshed prior to its
        // actual expiration. Defaults to 2 seconds. A duration of 0 will only refresh
        // tokens after they have already expired. To refresh tokens, you must also set
        // 'allowRefreshing' to 'true'; otherwise, this field is ignored.
        google.protobuf.Duration pre_expiry_buffer = 5;
        // Domain used to validate against requests in order to ensure that request host name matches target domain.
        // If the target domain is provided will prevent requests that do not match the target domain according to
        // the domain matching specifications in RFC 6265. For more information, see https://datatracker.ietf.org/doc/html/rfc6265#section-5.1.3
        string target_domain = 6;

        // If set, the name of the header that will include the randomly generated session id
        // This would be used as part of the code exchange with the Oauth2 token endpoint
        string header_name = 7;
    }

    // should we fail auth flow when failing to get a session from redis, or allow it to continue,
    // potentially starting a new auth flow and setting a new session.
    bool fail_on_fetch_failure = 1;

    message CookieOptions {
        // Max age for the cookie. Leave unset for a default of 30 days (2592000 seconds).
        // To disable cookie expiry, set explicitly to 0.
        google.protobuf.UInt32Value max_age = 1;
        // Use a non-secure cookie. Note - this should only be used for testing and in trusted
        // environments.
        bool not_secure = 2;
        // Set the cookie to be HttpOnly. defaults to true. Set explicity to false to disable.
        google.protobuf.BoolValue http_only = 5;
        // Path of the cookie. If unset, defaults to "/". Set it explicitly to "" to avoid setting a
        // path.
        google.protobuf.StringValue path = 3;
        // The SameSite options. The default value is LaxMode.
        enum SameSite {
            // Default Mode is the same as LaxMode but will not show up in the Cookie Header. This value is ignored.
            DefaultMode = 0;
            // Cookies are not sent on normal cross-site subrequests, but are sent when
            // navigating to the origin site.
            LaxMode = 1;
            // Only be sent in a first-party context and not be sent along with requests
            // initiated by third party websites.
            StrictMode = 2;
            // Cookies are sent in all contexts. Cookie NotSecure must be unset.
            NoneMode = 3;
        }
        // Whether the cookie should be restricted to a first-party or same-site context.
        // The default mode is LaxMode.
        SameSite same_site = 6;
        // Cookie domain
        string domain = 4;
    }

    // Set-Cookie options
    CookieOptions cookie_options = 2;
    oneof session {
        // Set the tokens in the cookie itself. No need for server side state.
        InternalSession cookie = 3;
        // Use redis to store the tokens and just store a random id in the cookie.
        RedisSession redis = 4;
    }
    // the cipher config is used to encrypt session cookie values.  This is currently only available for OIDC.
    message CipherConfig {
        // to enable the cipher encryption, the key has to be present. Note that the key has to be found and 32 bytes in 
        // length for the authconfig to not be rejected.
        oneof key {
            // The key reference used for the cipher. The reference must be a Kubernetes Secret of type `gloo.solo.io.EncryptionKeySecret`.
            core.solo.io.ResourceRef key_ref = 1;
        }
    }
    // the cipher config enables the symmetric key encryption of the cookie values of the user session.
    CipherConfig cipher_config = 5;
}

message HeaderConfiguration {
    // If set, the id token will be forward upstream using this header name.
    string id_token_header = 1;
    // If set, the access token will be forward upstream using this header name.
    string access_token_header = 2;
    // If true, adds the "Bearer" prefix to the upstream access token header value.
    google.protobuf.BoolValue use_bearer_schema_for_authorization = 3;
}

// OIDC configuration is discovered at <issuerUrl>/.well-known/openid-configuration
// The discovery override defines any properties that should override this discovery configuration
// https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata
message DiscoveryOverride {
    // url of the provider authorization endpoint
    string auth_endpoint = 1;

    // url of the provider token endpoint
    string token_endpoint = 2;

    // url of the provider json web key set
    string jwks_uri = 3;

    // list of scope values that the provider supports
    repeated string scopes = 4;

    // list of response types that the provider supports
    repeated string response_types = 5;

    // list of subject identifier types that the provider supports
    repeated string subjects = 6;

    // list of json web signature signing algorithms that the provider supports for encoding claims in a jwt
    repeated string id_token_algs = 7;

    // list of client authentication methods supported by the provider token endpoint
    repeated string auth_methods = 8;

    // list of claim types that the provider supports
    repeated string claims = 9;

    // url of the provider token revocation endpoint
    string revocation_endpoint = 10;

    // url of the provider end session endpoint
    string end_session_endpoint = 11;
}

// The json web key set (JWKS) (https://tools.ietf.org/html/rfc7517) is discovered at an interval
// from a remote source. When keys rotate in the remote source, there may be a delay in the
// local source picking up those new keys. Therefore, a user could execute a request with a token
// that has been signed by a key in the remote JWKS, but the local cache doesn't have the key yet.
// The request would fail because the key isn't contained in the local set. Since most IdPs publish key
// keys in their remote JWKS before they are used, this is not an issue most of the time.
// This policy lets you define the behavior for when a user has a token with a key
// not yet in the local cache.
message JwksOnDemandCacheRefreshPolicy {
    oneof policy {
        // Never refresh the local JWKS cache on demand. If a key is not in the cache, it is assumed to be malicious.
        // This is the default policy since we assume that IdPs publish keys before they rotate them,
        // and frequent polling finds the newest keys.
        google.protobuf.Empty never = 1;

        // If a key is not in the cache, fetch the most recent keys from the IdP and update the cache.
        // NOTE: This should only be done in trusted environments, since missing keys will each trigger
        // a request to the IdP. Using this in an environment exposed to the internet will allow malicious agents to
        // execute a DDoS attack by spamming protected endpoints with tokens signed by invalid keys.
        google.protobuf.Empty always = 2;

        // If a key is not in the cache, fetch the most recent keys from the IdP and update the cache.
        // This value sets the number of requests to the IdP per polling interval. If that limit is exceeded,
        // we will stop fetching from the IdP for the remainder of the polling interval.
        uint32 max_idp_req_per_polling_interval = 3;
    }
}

message AutoMapFromMetadata {
    // The namespace from which to map metadata
    string namespace = 1;
}

message EndSessionProperties {
    // The Method used to make the request.
    enum MethodType {
        // Uses GET method when making the request
        GetMethod = 0;
        // Uses POST method when making the request
        PostMethod = 1;
    }
    // The method type used by the end session endpoint, defaults to GET.
    MethodType methodType = 1;
}


message OidcAuthorizationCode {
    // your client id as registered with the issuer
    string client_id = 1;

    // your client secret as registered with the issuer.
    // This is required unless `disable_client_secret` is true
    core.solo.io.ResourceRef client_secret_ref = 2;

    // The url of the issuer. We will look for OIDC information in issuerUrl+
    // ".well-known/openid-configuration"
    string issuer_url = 3;

    // extra query parameters to apply to the Ext-Auth service's authorization request to the identity provider.
    // this can be useful for flows such as PKCE (https://www.oauth.com/oauth2-servers/pkce/authorization-request/)
    // to set the `code_challenge` and `code_challenge_method`.
    map<string, string> auth_endpoint_query_params = 4;

    // extra query parameters to apply to the Ext-Auth service's token request to the identity provider.
    // this can be useful for flows such as PKCE (https://www.oauth.com/oauth2-servers/pkce/authorization-request/)
    // to set the `code_verifier`.
    map<string, string> token_endpoint_query_params = 14;

    // where to redirect after successful auth, if we can't determine the original url.
    // this should be your publicly available app url.
    string app_url = 5;

    // a callback path relative to app url that will be used for OIDC callbacks.
    // should not be used by the application.
    string callback_path = 6;

    // a path relative to app url that will be used for logging out from an OIDC session.
    // should not be used by the application.
    // If not provided, logout functionality will be disabled.
    string logout_path = 9;

    // url to redirect to after logout.
    // This should be a publicly available URL. If not provided, will default to the `app_url`.
    string after_logout_url = 15;

    // Scopes to request in addition to openid scope.
    repeated string scopes = 7;

    // Configuration related to the user session.
    UserSession session = 8;

    // Configures headers added to requests.
    HeaderConfiguration headers = 10;

    // OIDC configuration is discovered at <issuerUrl>/.well-known/openid-configuration
    // The discovery override defines any properties that should override this discovery configuration
    // For example, the following AuthConfig CRD could be defined as:
    //    ```yaml
    //    apiVersion: enterprise.gloo.solo.io/v1
    //    kind: AuthConfig
    //    metadata:
    //      name: google-oidc
    //      namespace: gloo-system
    //    spec:
    //      configs:
    //      - oauth:
    //          app_url: http://localhost:8080
    //          callback_path: /callback
    //          client_id: $CLIENT_ID
    //          client_secret_ref:
    //            name: google
    //            namespace: gloo-system
    //          issuer_url: https://accounts.google.com
    //          discovery_override:
    //            token_endpoint: "https://token.url/gettoken"
    //    ```
    //
    // And this will ensure that regardless of what value is discovered at
    // <issuerUrl>/.well-known/openid-configuration, "https://token.url/gettoken" will be used as the token endpoint
    DiscoveryOverride discovery_override = 11;

    // The interval at which OIDC configuration is discovered at <issuerUrl>/.well-known/openid-configuration
    // If not specified, the default value is 30 minutes.
    google.protobuf.Duration discovery_poll_interval = 12;

    // If a user executes a request with a key that is not found in the JWKS, it could be
    // that the keys have rotated on the remote source, and not yet in the local cache.
    // This policy lets you define the behavior for how to refresh the local cache during a request
    // where an invalid key is provided
    JwksOnDemandCacheRefreshPolicy jwks_cache_refresh_policy = 13;

    // in the future we may implement this:
    // add optional configuration for validation of the access token received during the OIDC flow
    // AccessTokenValidation access_token_validation = 8;

    // DEPRECATED: Prefer the RedisSession.HeaderName field
    // If set, the randomly generated session id will be sent to the token endpoint as part of the code exchange
    // The session id is used as the key for sessions in Redis
    string session_id_header_name = 16 [deprecated = true];

    // If set, CallbackPath will be evaluated as a regular expression
    bool parse_callback_path_as_regex = 17;

    // If specified, authEndpointQueryParams and tokenEndpointQueryParams will be populated using dynamic metadata values.
    // By default parameters will be extracted from the solo_authconfig_oidc namespace
    // this behavior can be overridden by explicitly specifying a namespace
    AutoMapFromMetadata auto_map_from_metadata = 18;

    // If specified, these are properties defined for the end session endpoint
    // specifications. Noted [here](https://openid.net/specs/openid-connect-rpinitiated-1_0.html)
    // in the OIDC documentation.
    EndSessionProperties end_session_properties = 19;

    // Skip value 20 which is used in main for metadata_from_claims

    // If true, do not check for or use the client secret.
    // Generally the client secret is required and AuthConfigs will be rejected if it isn't set.
    // However certain implementations of the PKCE flow do not use a client secret (including Okta) so this setting allows configuring Oidc without a client secret.
    google.protobuf.BoolValue disable_client_secret = 21;
}

message PlainOAuth2 {
    // Your client ID as registered with the issuer
    string client_id = 1;

    // Your client secret as registered with the issuer.
    // This is required unless `disable_client_secret` is set.
    core.solo.io.ResourceRef client_secret_ref = 2;

    // Extra query parameters to apply to the Ext-Auth service's authorization request to the identity provider.
    // These parameters can be useful for flows such as [PKCE](https://www.oauth.com/oauth2-servers/pkce/authorization-request/)
    // to set the `code_challenge` and `code_challenge_method`.
    map<string, string> auth_endpoint_query_params = 3;

    // Where to redirect after successful auth, if Gloo can't determine the original URL.
    // Set this field to your publicly available app URL.
    string app_url = 4;

    // A callback path relative to the app URL to be used for OAuth2 callbacks.
    // Do not use this path in the application itself.
    string callback_path = 5;

    // Scopes to request for.
    repeated string scopes = 6;

    // Configuration related to the user session.
    UserSession session = 7;

    // A path relative to the app URL to use for logging out from an OAuth2 session.
    // Do not use this path in the application itself.
    // If not provided, logout functionality is disabled.
    string logout_path = 8;

    // Extra query parameters to apply to the Ext-Auth service's token request to the identity provider.
    // These parameters can be useful for flows such as [PKCE](https://www.oauth.com/oauth2-servers/pkce/authorization-request/)
    // to set the `code_verifier`.
    map<string, string> token_endpoint_query_params = 9;

    // URL to redirect to after logout.
    // Set this field to a publicly available URL. If not provided, this value defaults to the `app_url` value.
    string after_logout_url = 10;

    // The URL of the provider authorization endpoint.
    string auth_endpoint = 11;

    // The URL of the provider token endpoint.
    string token_endpoint = 12;

    // The URL of the provider token revocation endpoint.
    // For more information, refer to https://www.rfc-editor.org/rfc/rfc7009.
    string revocation_endpoint = 13;
    // If true, do not check for or use the client secret.
    // Generally the client secret is required and AuthConfigs will be rejected if it isn't set.
    // However certain implementations of the PKCE flow do not use a client secret (including Okta) so this setting allows configuring Oauth2 without a client secret.
    google.protobuf.BoolValue disable_client_secret = 14;
}

// Defines how JSON Web Token (JWT) access tokens are validated.
//
// Tokens are validated using a JSON Web Key Set (as defined in
// [Section 5 of RFC7517](https://tools.ietf.org/html/rfc7517#section-5)),
// which can be either inlined in the configuration or fetched from a remote location via HTTP.
// Any keys in the JWKS that are not intended for signature verification (i.e. whose
// ["use" parameter](https://tools.ietf.org/html/rfc7517#section-4.2) is not "sig")
// will be ignored by the system, as will keys that do not specify a
// ["kid" (Key ID) parameter](https://tools.ietf.org/html/rfc7517#section-4.2).
//
// The JWT to be validated must define non-empty "kid" and "alg" headers. The "kid" header
// determines which key in the JWKS will be used to verify the signature of the token;
// if no matching key is found, the token will be rejected.
//
// If present, the server will verify the "exp", "iat", and "nbf" standard JWT claims.
// Validation of the "iss" claim and of token scopes can be configured as well.
// If the JWT has been successfully validated, its set of claims will be added to the
// `AuthorizationRequest` state under the "jwtAccessToken" key.
message JwtValidation {

    // Specifies how to fetch JWKS from remote and how to cache it.
    message RemoteJwks {
        // The HTTP URI to fetch the JWKS.
        string url = 1;

        // The frequency at which the JWKS should be refreshed.
        // If not specified, the default value is 5 minutes.
        google.protobuf.Duration refresh_interval = 2;
    }

    // Represents a locally available JWKS.
    message LocalJwks {
        // JWKS is embedded as a string.
        string inline_string = 1;
    }

    oneof jwks_source_specifier {
        // Fetches the JWKS from a remote location.
        RemoteJwks remote_jwks = 1;
        // Loads the JWKS from a local data source.
        LocalJwks local_jwks = 2;
    }

    // Allow only tokens that have been issued by this principal (i.e. whose "iss" claim matches this value).
    // If empty, issuer validation will be skipped.
    string issuer = 3;
}

// Defines how (opaque) access tokens, received from the oauth authorization endpoint, are validated
// [OAuth2.0 Token Introspection](https://tools.ietf.org/html/rfc7662)
//
// If the token introspection url requires client authentication, both the client_id and client_secret
// are required. Unless disable_client_secret is set, when only one is provided, the config will be rejected.
// These values will be encoded in a basic auth header in order to authenticate the client.
message IntrospectionValidation {
    // The URL for the [OAuth2.0 Token Introspection](https://tools.ietf.org/html/rfc7662) endpoint.
    // If provided, the (opaque) access token provided or received from the oauth authorization endpoint
    // will be validated against this endpoint, or locally cached responses for this access token.
    string introspection_url = 1;

    // Your client id as registered with the issuer.
    // Optional: Use if the token introspection url requires client authentication.
    string client_id = 2;

    // Your client secret as registered with the issuer.
    // Optional: Use if the token introspection url requires client authentication.
    core.solo.io.ResourceRef client_secret_ref = 3;

    // The name of the [introspection response](https://tools.ietf.org/html/rfc7662#section-2.2)
    // attribute that contains the ID of the resource owner (e.g. `sub`, `username`).
    // If specified, the external auth server will use the value of the attribute as the identifier of the
    // authenticated user and add it to the request headers and/or dynamic metadata (depending on how the
    // server is configured); if the field is set and the attribute cannot be found, the request will be denied.
    // This field is optional and by default the server will not try to derive the user ID.
    string user_id_attribute_name = 4;

    // Allows setting a client id but not a client secret.
    google.protobuf.BoolValue disable_client_secret = 5;

}

message AccessTokenValidation {

    oneof validation_type {
        // The URL for the [OAuth2.0 Token Introspection](https://tools.ietf.org/html/rfc7662) endpoint.
        // If provided, the (opaque) access token provided or received from the oauth authorization endpoint
        // will be validated against this endpoint, or locally cached responses for this access token.
        // This field is deprecated as it does not support authenticated introspection requests
        string introspection_url = 1 [deprecated = true];

        // Validate access tokens that conform to the
        // [JSON Web Token (JWT)](https://datatracker.ietf.org/doc/rfc7662/) specification.
        JwtValidation jwt = 2;

        // Defines how (opaque) access tokens, received from the oauth authorization endpoint, are validated
        // [OAuth2.0 Token Introspection](https://tools.ietf.org/html/rfc7662) specification.
        IntrospectionValidation introspection = 3;

        // In the future we may implement HMAC validation
    }

    // The URL for the OIDC userinfo endpoint.
    // If provided, the (opaque) access token provided or received from the oauth endpoint
    // will be queried and the userinfo response (or cached response) will be added to the
    // `AuthorizationRequest` state under the "introspection" key.
    // This can be useful to leverage the userinfo response in, for example, an external auth server plugin.
    string userinfo_url = 4;

    // How long the token introspection and userinfo endpoint response for a specific access token should be kept
    // in the in-memory cache. The result will be invalidated at this timeout, or at "exp" time from the introspection
    // result, whichever comes sooner. If omitted, defaults to 10 minutes. If zero, then no caching will be done.
    google.protobuf.Duration cache_timeout = 5;

    // Optional criteria for validating the scopes of a token.
    oneof scope_validation {
        // Require access token to have all of the scopes in the given list.
        // This configuration applies to both opaque and JWT tokens. In the case of opaque tokens,
        // this will check the scopes returned in the "scope" member of introspection response
        // (as described in [Section 2.2 of RFC7662](https://tools.ietf.org/html/rfc7662#section-2.2).
        // In case of JWTs the scopes to be validated are expected to be contained in the "scope" claim of the
        // token in the form of a space-separated string.
        // Omitting this field means that scope validation will be skipped.
        ScopeList required_scopes = 6;

        // in the future we may add other types of scope validation (e.g. predicate matching)
    }

    message ScopeList {
      repeated string scope = 1;
    }
}

message OauthSecret {
    string client_secret = 1;
}

// Defines how API keys are validated.
//
// When the provided API key token has been successfully validated, it's token will be
// added to the `AuthorizationRequest` state under the "api_key_value" key name.
message ApiKeyAuth {
    // DEPRECATED: use K8sSecretApiKeyStorage to configure secrets storage backend. Values here
    // will be overwritten if values are specified in the storage backend.
    // Identify all valid API key secrets that match the provided label selector.
    // API key secrets must be in one of the watch namespaces for gloo to locate them.
    map<string, string> label_selector = 1 [deprecated = true];

    // DEPRECATED: use K8sSecretApiKeyStorage to configure secrets storage backend. Values here
    // will be overwritten if values are specified in the storage backend.
    // A way to directly reference API key secrets. This configuration can be useful for testing,
    // but in general the more flexible label selector should be preferred.
    repeated core.solo.io.ResourceRef api_key_secret_refs = 2 [deprecated = true];

    // When receiving a request, the Gloo Edge Enterprise external auth server will look for an API key in a header
    // with this name. This field is optional; if not provided it defaults to `api-key`.
    string header_name = 3;

    // DEPRECATED: use headers_from_metadata_entry
    map<string, SecretKey> headers_from_metadata = 4 [deprecated = true];

    // API key structures might contain additional data (e.g. the ID of the user that the API key belongs to)
    // in the form of extra fields included in the API key metadata structure.
    // This configuration can be used to add this data to the headers of successfully authenticated requests.
    // Each key in the map represents the name of header to be added; the corresponding value determines the key
    // in the API key metadata structure that will be inspected to determine the value for the header.
    //
    // When the provided API key token has been successfully validated, and this field has been configured, then
    // any extra API key metadata fields that were able to be discovered will be added to the `AuthorizationRequest`
    // state under the key name that was configured. For example, using the `x-user-name` string as the header name,
    // and referencing an existing "user-email" API key metadata entry will result in the value of this "user-email"
    // metadata entry being accessable in other auth modules in the `AuthorizationRequest.State["x-user-name"]` key.
    // This behavior allows other modules (e.g. OPA) to build more powerful rules to further validate the contents
    // of the extra API key metadata than what's possible using the standalone API key module.
    map<string, MetadataEntry> headers_from_metadata_entry = 5;

    oneof storage_backend {
        K8sSecretApiKeyStorage k8s_secret_apikey_storage = 6;
        AerospikeApiKeyStorage aerospike_apikey_storage = 7;
    }

    // DEPRECATED: use generalized MetadataEntry
    message SecretKey {
        // DEPRECATED
        // (Required) The key of the API key metadata entry to inspect.
        string name = 1;
        // DEPRECATED
        // If this field is set to `true`, Gloo will reject an API key structure that does not contain data for the given key.
        // Defaults to `false`. In this case, if an API key structure does not contain the requested data, no header will be added
        // to the request.
        bool required = 2;
    }

    // For the K8s secret backend, this data is stored as key-value data in the secret itself.
    // For the Aerospike backend, this data is stored as bins on the key's record
    message MetadataEntry {
        // (Required) The key of the API key metadata entry to inspect.
        string name = 1;
        // If this field is set to `true`, Gloo will reject an API key structure that does not contain data for the given key.
        // Defaults to `false`. In this case, if an API key structure does not contain the requested data, no header will be added
        // to the request.
        bool required = 2;
    }
}
message K8sSecretApiKeyStorage {
    // Identify all valid API key secrets that match the provided label selector.<br/>
    // API key secrets must be in one of the watch namespaces for gloo to locate them.
    map<string, string> label_selector = 1;

    // A way to directly reference API key secrets. This configuration can be useful for testing,
    // but in general the more flexible label selector should be preferred.
    repeated core.solo.io.ResourceRef api_key_secret_refs = 2;
}

message AerospikeApiKeyStorage {
    // The IP address or hostname of one of the cluster members of your Aerospike database. The address must be reachable from Gloo Edge, such as in a virtual machine with a public IP address or in a pod in the cluster.
    // The client automatically discovers other members of the cluster after establishing a connection.
	string hostname = 1;
    // The Aerospike namespace of the database. Defaults to "solo-namespace".
	string namespace = 2;
    // The Aerospike set to use for storage of API keys. Defaults to "apikeys".
	string set = 3;
    // The port on which to connect to the Aerospike server. Defaults to 3000.
	int32 port = 4;
    // The size of the batch, which is the number of keys sent in the request. Defaults to 5000.
	int32 batch_size = 5;

	// The write settings for guaranteed consistency when committing a transaction on the Aerospike server. For more information, see the [Aerospike commit policy](https://github.com/aerospike/aerospike-client-go/blob/master/commit_policy.go).
    // Defaults to "commit_all".
    oneof commit_level {
        // "commit_all" indicates that the server waits until successfully committing the master and all replicas.
        uint32 commit_all = 6;
        // "commit_master" indicates that the server waits until successfully committing the master only.
        uint32 commit_master = 7;
    }

    // The read settings for strong consistency (SC). For possible values, see the [Aerospike read mode SC](https://github.com/aerospike/aerospike-client-go/blob/master/read_mode_sc.go).
    // Defaults to "read_mode_sc_session".
    readModeSc read_mode_sc = 8;
    message readModeSc {
        oneof read_mode_sc {
            // The session ensures this client sees only an increasing sequence of record versions.
            // Server reads only from master, which is the default.
            uint32 read_mode_sc_session = 1;
            // "linearize" ensures that ALL clients see only an increasing sequence of record versions.
            // "server" reads only from master.
            uint32 read_mode_sc_linearize = 2;

            // "replica" indicates that the server can read from master or any full (non-migrating) replica.
            // An increasing sequence of record versions is not guaranteed.
            uint32 read_mode_sc_replica = 3;

            // "allow_unavailable" indicates that the server can read from master or any full (non-migrating) replica or from unavailable
            // partitions. An increasing sequence of record versions is not guaranteed.
            uint32 read_mode_sc_allow_unavailable = 4;
        }
    }

    // The read settings for availability (AP). For possible values, see the [Aerospike read mode AP](https://github.com/aerospike/aerospike-client-go/blob/master/read_mode_ap.go).
    // Defaults to "read_mode_ap_one".
    readModeAp read_mode_ap = 9;
    message readModeAp {
        oneof read_mode_ap {
            // "one" indicates that a single node is involved in the read operation.
            uint32 read_mode_ap_one = 1;

            // "all" indicates that all duplicate nodes are consulted in
            // the read operation.
            uint32 read_mode_ap_all = 2;
        }
    }

	// TLS settings to enable mutual TLS (mTLS) on the server side. These configuration options must match what you configured in your Aerospike setup. For more information, see the Aerospike [security](https://docs.aerospike.com/server/guide/security/tls) and [network TLS](https://docs.aerospike.com/server/operations/configure/network/tls) guides.
    // The subject name of the TLS authority. For more information, see the [Aerospike docs](https://docs.aerospike.com/reference/configuration#tls-name).
	string node_tls_name = 10;
    // The path to the TLS certfiicate.
	string cert_path = 11;
    // The path to the key.
	string key_path = 12;
	// The TLS insecure setting. If set to `true`, the authority of the certificate on the client's end is not authenticated. You might use insecure mode in non-production environments when the certificate is not known.
	bool allow_insecure = 13;
	// If the root certificate authority (CA) is not set, add the system certs by default.
	string root_ca_path = 14;
	// The TLS version. Versions 1.0, 1.1, 1.2, and 1.3 are supported. Defaults to 1.3
	string tls_version = 15;
	// The TLS identifier for an elliptic curve. For more information, see [TLS supported groups](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8).
    repeated tlsCurveID tls_curve_groups = 16;
    message tlsCurveID {
        oneof curve_id {
            uint32 curve_p256 = 1;
            uint32 curve_p384 = 2;
            uint32 curve_p521 = 3;
            uint32 x_25519 = 4;
        }
    }

    // Identify the set of required labels (key/value) which an Aerospike secret must contain
    // If a secret contains the provided set of labels, it will be considered valid when authorizing an ApiKey provided in a request
    map<string, string> label_selector = 17;
}

message ApiKey {
    // The string value of the API key.
    string api_key = 2;
    // A list of labels (key=value) for the apikey secret.
    // These labels are used by the storage driver to facilitate lookups by label
    repeated string labels = 3;
    // additional data the client needs associated with this API key
    map<string, string> metadata = 4;
    // Optional: Unique identifier for the API key
    string uuid = 5;
}

// DEPRECATED: use ApiKey
message ApiKeySecret {
    // The string value of the API key.
    string api_key = 2;
    // A list of labels (key=value) for the apikey secret.
    // These labels are used by the storage driver to facilitate lookups by label
    repeated string labels = 3;
    // additional data the client needs associated with this API key
    map<string, string> metadata = 4;
}

message OpaAuth {
    // An optional resource reference to config maps containing modules to assist in the resolution of `query`.
    repeated core.solo.io.ResourceRef modules = 1;

    // The query that determines the auth decision. The result of this query must be either a boolean
    // or an array with boolean as the first element. A boolean `true` value means that the request
    // will be authorized. Any other value, or error, means that the request will be denied.
    string query = 2;

    // Additional Options for Opa Auth configuration.
    OpaAuthOptions options = 3;
}

message OpaAuthOptions {
    // Decreases OPA latency by speeding up conversion of input to the OPA engine.
    // If this is set to true, only http_request and state fields which are a scalar, map, or string array
    // are included in the request input. All other fields are dropped. Dropped fields will not be evaluated by the OPA engine.
    // By default, this is set to false and all fields are evaluated by OPA.
    bool fast_input_conversion = 1;
}

// Authenticates and authorizes requests by querying an LDAP server. Gloo makes the following assumptions:
//  * Requests provide credentials via the basic HTTP authentication header. Gloo will BIND to the LDAP server using the
//    credentials extracted from the header.
//  * Your LDAP server is configured so that each entry you want to authorize has an attribute that indicates its group
//    memberships. A common way of achieving this is by using the [*memberof* overlay](http://www.openldap.org/software/man.cgi?query=slapo-memberof).
message Ldap {

    // Configuration properties for pooling connections to the LDAP server. If the pool is exhausted when a connection
    // is requested (meaning that all the pooled connections are in use), the connection will be created on the fly.
    message ConnectionPool {
        // Maximum number connections that are pooled at any give time. The default value is 5.
        google.protobuf.UInt32Value maxSize = 1;
        // Number of connections that the pool will be pre-populated with upon initialization. The default value is 2.
        google.protobuf.UInt32Value initialSize = 2;
    }

    // Address of the LDAP server to query. Should be in the form ADDRESS:PORT, e.g. `ldap.default.svc.cluster.local:389`.
    string address = 1;

    // Template to build user entry distinguished names (DN). This must contains a single occurrence of the "%s" placeholder.
    // When processing a request, Gloo will substitute the name of the user (extracted from the auth header) for the
    // placeholder and issue a search request with the resulting DN as baseDN (and 'base' search scope).
    // E.g. "uid=%s,ou=people,dc=solo,dc=io"
    string userDnTemplate = 2;

    // Case-insensitive name of the attribute that contains the names of the groups an entry is member of. Gloo will look
    // for attributes with the given name to determine which groups the user entry belongs to. Defaults to 'memberOf' if not provided.
    string membershipAttributeName = 3;

    // In order for the request to be authenticated, the membership attribute (e.g. *memberOf*) on the user entry must
    // contain at least of one of the group DNs specified via this option.
    // E.g. []string{ "cn=managers,ou=groups,dc=solo,dc=io", "cn=developers,ou=groups,dc=solo,dc=io" }
    repeated string allowedGroups = 4;

    // Use this property to tune the pool of connections to the LDAP server that Gloo maintains.
    ConnectionPool pool = 5;

    // Use to set a custom filter when searching a member. Defaults to "(uid=*)".
    string searchFilter = 6;

    // Disables group checking, regardless of the value for allowedGroups,
    // and disables validation for the membership attribute of the user entry.
    // Group checking is enabled by default.
    bool disable_group_checking = 7;

    // Settings for using a separate service account for looking up group membership
    // To use this, you also need to configure credentials in a secret
    LdapServiceAccount group_lookup_settings = 8;
}

message LdapServiceAccount {
    // Reference to an AccountCredentialsSecret to use to authenticate as the service account
    core.solo.io.ResourceRef credentials_secret_ref = 1;
    // If true, Gloo will use the service account to check group membership
    bool check_groups_with_service_account = 2;
}
// Authorizes requests by querying a custom extauth server.
message PassThroughAuth {

    oneof protocol {
        PassThroughGrpc grpc = 1;
        PassThroughHttp http = 2;
    }

    // Custom config to be passed per request to the passthrough auth service.
    google.protobuf.Struct config = 4;

    // If set to true, the service will accept client request even if the communication with
    //  the authorization service has failed, or if the authorization service has returned a server error.
    // Defaults to false.
    bool failure_mode_allow = 5;
}

// Authorizes requests by querying a custom extauth grpc server
// Assumes that the server implements the envoy external authorization spec:
// https://github.com/envoyproxy/envoy/blob/ae1ed1fa74f096dabe8dd5b19fc70333621b0309/api/envoy/service/auth/v3/external_auth.proto#L29
message PassThroughGrpc {

    // Address of the auth server to query. Should be in the form ADDRESS:PORT, e.g. `default.svc.cluster.local:389`.
    string address = 1;

    // Timeout for the auth server to respond. Defaults to 5s
    google.protobuf.Duration connection_timeout = 2;

    // TLS config for the Grpc passthrough, if not configured the connection will use insecure.
    PassThroughGrpcTLSConfig tlsConfig =3;
}
// TLS configuration for the extauth grpc passthrough connection
message PassThroughGrpcTLSConfig {
}

// Authorizes requests by making a POST HTTP/1 request to a custom HTTP auth server
// Assumes the request is authorized if the server returns a OK (200) status code,
// else the request is unauthorized.
message PassThroughHttp {
    // Required: URL of the passthrough http service, is a fully qualified domain name.
    // Example: http://ext-auth-service.svc.local:9001. Path provided in the URL will be respected.
    // To use https, provide the cert in the HTTPS_PASSTHROUGH_CA_CERT environment variable to the ext-auth-service
    // pod as a base64-encoded string
    string url = 1;

    /* The passthrough http request can be configured to pass through the incoming request body,
     the ext-auth state (which is shared between different auth methods within one ext-auth instance), and
     the [filterMetadata](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/advanced/data_sharing_between_filters#metadata)
     The body of the passthrough auth request will be a JSON as follows:
     {
       "body" : string,
       "state": object (map[string]interface{}),
       "filterMetadata": object (map[string]protobuf.Struct),
       "config": object (protobuf.Struct),
     }
     `config` is the struct block specified under the passthrough auth configuration.
     If `passthrough_body`, `passthrough_state`, `passthrough_filter_metadata`, and `config` are all false/nil,
     the body of the auth request will remain empty. Setting any of these will increase latency slightly due to
     JSON marshalling.

    */
    message Request {
        // These headers will be copied from the incoming request to the request going
        // to the auth server. By default, no headers are copied from the incoming request.
        // Pseudo-headers such as `:Path`, and `:Method` can not be specified here.
        repeated string allowed_headers = 1;

        // These headers that will be included to the request to authorization service. Note that
        // client request of the same key will be overridden.
        // Pseudo-headers such as `:Path`, and `:Method` can not be specified here.
        map<string, string> headers_to_add = 2;

        // Whether or not to include the ext-auth state object in the passthrough request body.
        // If this is set to true, it is expected that the state is returned in the HTTP response from the
        // passthrough service. The state received from the response will be the state that is shared with
        // other ext-auth service methods.
        // If pass_through_body, pass_through_filter_metadata and pass_through_state are false,
        // the authorization request body will be empty. A non-empty body will increase latency times
        // slightly, so this is set to false by default, and should only be set to to true if the
        // extauth state is needed in the auth request.
        bool pass_through_state = 3;

        // Whether or not to include the filter metadata in the passthrough request body.
        // If pass_through_body, pass_through_filter_metadata and pass_through_state are false,
        // the authorization request body will be empty. A non-empty body will increase latency times
        // slightly, so this is set to false by default, and should only be set to to true if the
        // filter metadata is needed in the auth request.
        bool pass_through_filter_metadata = 4;

        // Whether or not to include the body in the passthrough request body.
        // In order for this to work, the settings.extauth.requestBody must be set in the Gloo Edge Settings CRD so that
        // the request body is buffered and sent to the ext-auth service.
        // If pass_through_body, pass_through_filter_metadata and pass_through_state are false,
        // the authorization request body will be empty. A non-empty body will increase latency times
        // slightly, so this is set to false by default, and should only be set to to true if the
        // request body is needed in the auth request.
        bool pass_through_body = 5;
    }
    Request request = 3;

    message Response {
        // When this is set, authorization response headers that have a header in this list will be added to the original client request and sent to the upstream
        // when the auth request is successful. These will be appended to any request headers that already exist.
        // If this is empty, by default, no authorization response headers will be added to the upstream request.
        repeated string allowed_upstream_headers = 1;

        // When this is set, authorization response headers in this list will be added to the client's response when the auth request is denied.
        // If the response header already exists, it will replace the response header.
        // If this is empty, by default, no authorization response headers will be added to the client response.
        repeated string allowed_client_headers_on_denied = 2;

        // If this is set to true, the body of the response from the http passthrough auth server is expected to have shape
        // {
        //   "state": object (map[string]interface{})
        // }
        // The state will be marshalled from the response body and this is the state that will be passed on to other auth configs.
        // Because of the marshalling from JSON to Go map, this will add some latency to the request.
        // If the marshalling fails, the authorization check will fail and the request will be unauthorized after the ext-auth-service pod
        // logs the marshal error.
        bool read_state_from_response = 3;
    }
    Response response = 4;

    // Timeout for the auth server to respond. Defaults to 5s
    google.protobuf.Duration connection_timeout = 8;
}

/*
@solo-kit:xds-service=ExtAuthDiscoveryService
@solo-kit:resource.no_references

This is an internal API used to share configuration between gloo-ee and extauth. Although this API is only used in gloo-ee,
rules about breaking changes still apply to ensure we do not get errors during upgrade and downgrade.
 */
message ExtAuthConfig {

    // @solo-kit:resource.name
    // This is the identifier of the AuthConfig resource that this configuration is associated with.
    // Any request to the external auth server includes an identifier that is matched against this field to determine
    // which AuthConfig should be applied to it.
    string auth_config_ref_name = 1;
    // Deprecated, prefer OAuth2Config
    message OAuthConfig {
        // your client id as registered with the issuer
        string client_id = 1 [deprecated = true];

        // your client secret as registered with the issuer
        string client_secret = 2 [deprecated = true, (extproto.sensitive) = true];

        // The url of the issuer. We will look for OIDC information in issuerUrl+
        // ".well-known/openid-configuration"
        string issuer_url = 3 [deprecated = true];

        // extra query parameters to apply to the Ext-Auth service's authorization request to the identity provider.
        map<string, string> auth_endpoint_query_params = 7 [deprecated = true];

        // we to redirect after successful auth, if we can't determine the original
        // url this should be your publicly available app url.
        string app_url = 4 [deprecated = true];

        // a callback path relative to app url that will be used for OIDC callbacks.
        // needs to not be used by the application
        string callback_path = 5 [deprecated = true];

        // scopes to request in addition to the openid scope.
        repeated string scopes = 6 [deprecated = true];

    }

    message UserSessionConfig {
        // should we fail auth flow when failing to get a session from redis, or allow it to continue,
        // potentially starting a new auth flow and setting a new session.
        bool fail_on_fetch_failure = 1;
        // Set-Cookie options
        UserSession.CookieOptions cookie_options = 2;
        oneof session {
            // Set the tokens in the cookie itself. No need for server side state.
            UserSession.InternalSession cookie = 3;
            // Use redis to store the tokens and just store a random id in the cookie.
            UserSession.RedisSession redis = 4;
        }
        message CipherConfig {
            // to enable the cipher encryption, the key has to be present.
            // Note that the key has to be found and 32 bytes in length for the authconfig to not be rejected.
            string key = 1 [(extproto.sensitive) = true];
        }
        // the cipher config enables the symmetric key encryption of the cookie values of the user session.
        CipherConfig cipher_config = 5;
    }

    message OidcAuthorizationCodeConfig {

        // your client id as registered with the issuer
        string client_id = 1;

        // your client secret as registered with the issuer
        string client_secret = 2 [(extproto.sensitive) = true];

        // The url of the issuer. We will look for OIDC information in issuerUrl+
        // ".well-known/openid-configuration"
        string issuer_url = 3;

        // extra query parameters to apply to the Ext-Auth service's authorization request to the identity provider.
        // this can be useful for flows such as PKCE (https://www.oauth.com/oauth2-servers/pkce/authorization-request/)
        // to set the `code_challenge` and `code_challenge_method`.
        map<string, string> auth_endpoint_query_params = 4;

        // extra query parameters to apply to the Ext-Auth service's token request to the identity provider.
        // this can be useful for flows such as PKCE (https://www.oauth.com/oauth2-servers/pkce/authorization-request/)
        // to set the `code_verifier`.
        map<string, string> token_endpoint_query_params = 14;

        // we to redirect after successful auth, if we can't determine the original
        // url this should be your publicly available app url.
        string app_url = 5;

        // a callback path relative to app url that will be used for OIDC callbacks.
        // needs to not be used by the application
        string callback_path = 6;

        // a path relative to app url that will be used for logging out from an OIDC session.
        // should not be used by the application.
        // If not provided, logout functionality will be disabled.
        string logout_path = 9;

        // url to redirect to after logout.
        // This should be a publicly available URL. If not provided, will default to the `app_url`.
        string after_logout_url = 15;

        // scopes to request in addition to the openid scope.
        repeated string scopes = 7;

        // DEPRECATED: use userSessionConfig [userSession]
        UserSession session = 8 [deprecated = true];

        // Configures headers added to requests.
        HeaderConfiguration headers = 10;

        // OIDC configuration is discovered at <issuerUrl>/.well-known/openid-configuration
        // The configuration override defines any properties that should override this discovery configuration
        // For example, the following AuthConfig CRD could be defined as:
        //    ```yaml
        //    apiVersion: enterprise.gloo.solo.io/v1
        //    kind: AuthConfig
        //    metadata:
        //      name: google-oidc
        //      namespace: gloo-system
        //    spec:
        //      configs:
        //      - oauth:
        //          app_url: http://localhost:8080
        //          callback_path: /callback
        //          client_id: $CLIENT_ID
        //          client_secret_ref:
        //            name: google
        //            namespace: gloo-system
        //          issuer_url: https://accounts.google.com
        //          discovery_override:
        //            token_endpoint: "https://token.url/gettoken"
        //    ```
        //
        // And this will ensure that regardless of what value is discovered at
        // <issuerUrl>/.well-known/openid-configuration, "https://token.url/gettoken" will be used as the token endpoint
        DiscoveryOverride discovery_override = 11;

        // The interval at which OIDC configuration is discovered at <issuerUrl>/.well-known/openid-configuration
        // If not specified, the default value is 30 minutes.
        google.protobuf.Duration discovery_poll_interval = 12;

        // If a user executes a request with a key that is not found in the JWKS, it could be
        // that the keys have rotated on the remote source, and not yet in the local cache.
        // This policy lets you define the behavior for how to refresh the local cache during a request
        // where an invalid key is provided
        JwksOnDemandCacheRefreshPolicy jwks_cache_refresh_policy = 13;

        // in the future we may implement this:
        // add optional configuration for validation of the access token received during the OIDC flow
        // AccessTokenValidation access_token_validation = 8;

        // If set, the randomly generated session id will be sent to the token endpoint as part of the code exchange
        // The session id is used as the key for sessions in Redis
        string session_id_header_name = 16;

        // If set, CallbackPath will be evaluated as a regular expression
        bool parse_callback_path_as_regex = 17;

        // If specified, authEndpointQueryParams and tokenEndpointQueryParams will be populated using dynamic metadata values.
        // By default parameters will be extracted from the solo_authconfig_oidc namespace
        // this behavior can be overridden by explicitly specifying a namespace
        AutoMapFromMetadata auto_map_from_metadata = 18;

        // If specified, these are properties defined for the end session endpoint
        // specifications. Noted [here](https://openid.net/specs/openid-connect-rpinitiated-1_0.html)
        // in the OIDC documentation.
        EndSessionProperties end_session_properties = 19;

        // Configuration related to the user session.
        UserSessionConfig user_session = 20;

    }

    message AccessTokenValidationConfig {
        // Defines how JSON Web Token (JWT) access tokens are validated.
        //
        // Tokens are validated using a JSON Web Key Set (as defined in
        // [Section 5 of RFC7517](https://tools.ietf.org/html/rfc7517#section-5)),
        // which can be either inlined in the configuration or fetched from a remote location via HTTP.
        // Any keys in the JWKS that are not intended for signature verification (i.e. whose
        // ["use" parameter](https://tools.ietf.org/html/rfc7517#section-4.2) is not "sig")
        // will be ignored by the system, as will keys that do not specify a
        // ["kid" (Key ID) parameter](https://tools.ietf.org/html/rfc7517#section-4.2).
        //
        // The JWT to be validated must define non-empty "kid" and "alg" headers. The "kid" header
        // determines which key in the JWKS will be used to verify the signature of the token;
        // if no matching key is found, the token will be rejected.
        //
        // If present, the server will verify the "exp", "iat", and "nbf" standard JWT claims.
        // Validation of the "iss" claim and of token scopes can be configured as well.
        // If the JWT has been successfully validated, its set of claims will be added to the
        // `AuthorizationRequest` state under the "jwtAccessToken" key.
        message JwtValidation {

            // Specifies how to fetch JWKS from remote and how to cache it.
            message RemoteJwks {
                // The HTTP URI to fetch the JWKS.
                string url = 1;

                // The frequency at which the JWKS should be refreshed.
                // If not specified, the default value is 5 minutes.
                google.protobuf.Duration refresh_interval = 2;
            }

            // Represents a locally available JWKS.
            message LocalJwks {
                // JWKS is embedded as a string.
                string inline_string = 1;
            }

            oneof jwks_source_specifier {
                // Fetches the JWKS from a remote location.
                RemoteJwks remote_jwks = 1;
                // Loads the JWKS from a local data source.
                LocalJwks local_jwks = 2;
            }

            // Allow only tokens that have been issued by this principal (i.e. whose "iss" claim matches this value).
            // If empty, issuer validation will be skipped.
            string issuer = 3;
        }

        // Defines how (opaque) access tokens, received from the oauth authorization endpoint, are validated
        // [OAuth2.0 Token Introspection](https://tools.ietf.org/html/rfc7662)
        //
        // If the token introspection url requires client authentication, both the client_id and client_secret
        // are required. If only one is provided, the config will be rejected.
        // These values will be encoded in a basic auth header in order to authenticate the client.
        message IntrospectionValidation {
            // The URL for the [OAuth2.0 Token Introspection](https://tools.ietf.org/html/rfc7662) endpoint.
            // If provided, the (opaque) access token provided or received from the oauth authorization endpoint
            // will be validated against this endpoint, or locally cached responses for this access token.
            string introspection_url = 1;

            // Your client id as registered with the issuer.
            // Optional: Use if the token introspection url requires client authentication.
            string client_id = 2;

            // Your client secret as registered with the issuer.
            // Optional: Use if the token introspection url requires client authentication.
            string client_secret = 3 [(extproto.sensitive) = true];

            // The name of the [introspection response](https://tools.ietf.org/html/rfc7662#section-2.2)
            // attribute that contains the ID of the resource owner (e.g. `sub`, `username`).
            // If specified, the external auth server will use the value of the attribute as the identifier of the
            // authenticated user and add it to the request headers and/or dynamic metadata (depending on how the
            // server is configured); if the field is set and the attribute cannot be found, the request will be denied.
            // This field is optional and by default the server will not try to derive the user ID.
            string user_id_attribute_name = 4;

        }

        oneof validation_type {
            // The URL for the [OAuth2.0 Token Introspection](https://tools.ietf.org/html/rfc7662) endpoint.
            // If provided, the (opaque) access token provided or received from the oauth authorization endpoint
            // will be validated against this endpoint, or locally cached responses for this access token.
            // This field is deprecated as it does not support authenticated introspection requests
            string introspection_url = 1 [deprecated = true];

            // Validate access tokens that conform to the
            // [JSON Web Token (JWT)](https://datatracker.ietf.org/doc/rfc7662/) specification.
            JwtValidation jwt = 2;

            // Defines how (opaque) access tokens, received from the oauth authorization endpoint, are validated
            // [OAuth2.0 Token Introspection](https://tools.ietf.org/html/rfc7662) specification.
            IntrospectionValidation introspection = 3;

            // In the future we may implement HMAC validation
        }

        // The URL for the OIDC userinfo endpoint.
        // If provided, the (opaque) access token provided or received from the oauth endpoint
        // will be queried and the userinfo response (or cached response) will be added to the
        // `AuthorizationRequest` state under the "introspection" key.
        // This can be useful to leverage the userinfo response in, for example, an external auth server plugin.
        string userinfo_url = 4;

        // How long the token introspection and userinfo endpoint response for a specific access token should be kept
        // in the in-memory cache. The result will be invalidated at this timeout, or at "exp" time from the introspection
        // result, whichever comes sooner. If omitted, defaults to 10 minutes. If zero, then no caching will be done.
        google.protobuf.Duration cache_timeout = 5;

        // Optional criteria for validating the scopes of a token.
        oneof scope_validation {
            // Require access token to have all of the scopes in the given list.
            // This configuration applies to both opaque and JWT tokens. In the case of opaque tokens,
            // this will check the scopes returned in the "scope" member of introspection response
            // (as described in [Section 2.2 of RFC7662](https://tools.ietf.org/html/rfc7662#section-2.2).
            // In case of JWTs the scopes to be validated are expected to be contained in the "scope" claim of the
            // token in the form of a space-separated string.
            // Omitting this field means that scope validation will be skipped.
            ScopeList required_scopes = 6;

            // in the future we may add other types of scope validation (e.g. predicate matching)
        }

        message ScopeList {
            repeated string scope = 1;
        }
    }

    message PlainOAuth2Config {
        // Your client ID as registered with the issuer
        string client_id = 1;

        // Your client secret as registered with the issuer
        string client_secret = 2 [(extproto.sensitive) = true];

        // Extra query parameters to apply to the Ext-Auth service's authorization request to the identity provider.
        // These parameters can be useful for flows such as [PKCE](https://www.oauth.com/oauth2-servers/pkce/authorization-request/)
        // to set the `code_challenge` and `code_challenge_method`.
        map<string, string> auth_endpoint_query_params = 3;

        // Where to redirect after successful auth, if Gloo can't determine the original URL.
        // Set this field to your publicly available app URL.
        string app_url = 4;

        // A callback path relative to the app URL to be used for OAuth2 callbacks.
        // Do not use this path in the application itself.
        string callback_path = 5;

        // Scopes to request for.
        repeated string scopes = 6;

        // DEPRECATED: use userSessionConfig [userSession]
        UserSession session = 7 [deprecated = true];

        // A path relative to the app URL to use for logging out from an OAuth2 session.
        // Do not use this path in the application itself.
        // If not provided, logout functionality is disabled.
        string logout_path = 8;

        // Extra query parameters to apply to the Ext-Auth service's token request to the identity provider.
        // These parameters can be useful for flows such as [PKCE](https://www.oauth.com/oauth2-servers/pkce/authorization-request/)
        // to set the `code_verifier`.
        map<string, string> token_endpoint_query_params = 9;

        // URL to redirect to after logout.
        // Set this field to a publicly available URL. If not provided, this value defaults to the `app_url` value.
        string after_logout_url = 10;

        // The URL of the provider authorization endpoint.
        string auth_endpoint = 11;

        // The URL of the provider token endpoint.
        string token_endpoint = 12;

        // The URL of the provider token revocation endpoint.
        // For more information, refer to https://www.rfc-editor.org/rfc/rfc7009.
        string revocation_endpoint = 13;

        // Configuration related to the user session.
        UserSessionConfig user_session = 14;
    }

    message OAuth2Config {
        reserved 2;

        oneof oauth_type {
            // provide issuer location and let gloo handle OIDC flow for you.
            // requests authorized by validating the contents of ID token.
            // can also authorize the access token if configured.
            OidcAuthorizationCodeConfig oidc_authorization_code = 1;

            // provide the access token on the request and let gloo handle authorization.
            //
            // according to https://tools.ietf.org/html/rfc6750 you can pass tokens through:
            // - form-encoded body parameter. recommended, more likely to appear. e.g.: Authorization: Bearer mytoken123
            // - URI query parameter e.g. access_token=mytoken123
            // - and (preferably) secure cookies
            AccessTokenValidationConfig access_token_validation_config = 3;

            // Enterprise-Only: THIS FEATURE IS IN TECH PREVIEW. APIs are versioned as alpha and subject to change.
            // provide issuer location and let Gloo handle Oauth2 flow for you.
            // requests authorized by validating the contents of access token.
            // Prefer to use OIDC for better security.
            PlainOAuth2Config oauth2_config = 4;
        }
    }

    // **NOTE: This configuration is not user-facing and will be auto generated**
    message ApiKeyAuthConfig {

        message KeyMetadata {
            // The user is mapped as the name of `Secret` which contains the `ApiKey`
            string username = 1;
            // The metadata present on the `ApiKey`.
            map<string, string> metadata = 2;
        }

        // A mapping of valid API keys to their associated metadata.
        // This map is automatically populated with the information from the relevant `ApiKey`s.
        // Currently this is only configured when using the k8s Secret storage backend
        map<string, KeyMetadata> valid_api_keys = 1 [(extproto.sensitive) = true];

        // (Optional) When receiving a request, the Gloo Edge Enterprise external auth server will look for an API key
        // in a header with this name. This field is optional; if not provided it defaults to `api-key`.
        string header_name = 2;

        // Determines the key metadata that will be included as headers on the upstream request.
        // Each entry represents a header to add: the key is the name of the header, and the
        // value is the key that will be used to look up the data entry in the key metadata.
        map<string, string> headers_from_key_metadata = 3;

        oneof storage_backend {
            K8sSecretApiKeyStorage k8s_secret_apikey_storage = 4;
            AerospikeApiKeyStorage aerospike_apikey_storage = 5;
        }
    }

    message OpaAuthConfig {
        // An optional modules (filename, module content) maps containing modules assist in the resolution of `query`.
        map<string, string> modules = 1;

        // The query that determines the auth decision. The result of this query must be either a boolean
        // or an array with boolean as the first element. A boolean `true` value means that the request
        // will be authorized. Any other value, or error, means that the request will be denied.
        string query = 2;

        // Additional Options for Opa Auth configuration.
        OpaAuthOptions options = 3;
    }
    message LdapConfig {

        // Address of the LDAP server to query. Should be in the form ADDRESS:PORT, e.g. `ldap.default.svc.cluster.local:389`.
        string address = 1;

        // Template to build user entry distinguished names (DN). This must contains a single occurrence of the "%s" placeholder.
        // When processing a request, Gloo will substitute the name of the user (extracted from the auth header) for the
        // placeholder and issue a search request with the resulting DN as baseDN (and 'base' search scope).
        // E.g. "uid=%s,ou=people,dc=solo,dc=io"
        string userDnTemplate = 2;

        // Case-insensitive name of the attribute that contains the names of the groups an entry is member of. Gloo will look
        // for attributes with the given name to determine which groups the user entry belongs to. Defaults to 'memberOf' if not provided.
        string membershipAttributeName = 3;

        // In order for the request to be authenticated, the membership attribute (e.g. *memberOf*) on the user entry must
        // contain at least of one of the group DNs specified via this option.
        // E.g. []string{ "cn=managers,ou=groups,dc=solo,dc=io", "cn=developers,ou=groups,dc=solo,dc=io" }
        repeated string allowedGroups = 4;

        // Use this property to tune the pool of connections to the LDAP server that Gloo maintains.
        Ldap.ConnectionPool pool = 5;

        // Use to set a custom filter when searching a member. Defaults to "(uid=*)".
        string searchFilter = 6;

        // Disables group checking, regardless of the value for allowedGroups,
        // and disables validation for the membership attribute of the user entry.
        // Group checking is enabled by default.
        bool disable_group_checking = 7;

        // Settings for using a separate service account for looking up group membership
        // To use this, you also need to configure credentials
        LdapServiceAccountConfig group_lookup_settings = 8;
    }
    message LdapServiceAccountConfig {
        // username and password are taken from the secret during gloo-ee translation
        string username = 1 [(extproto.sensitive) = true];
        string password = 2 [(extproto.sensitive) = true];
        // If true, Gloo will use the service account to check group membership
        bool check_groups_with_service_account = 3;
    }
    message HmacAuthConfig {
        oneof secret_storage {
            InMemorySecretList secret_list = 1;
        }
        // Algorithm to use to turn the request into a hashable string
        oneof implementation_type{
            HmacParametersInHeaders parameters_in_headers = 2;
        }

    }
    message InMemorySecretList {
        // list of username/password pairs taken from secrets during gloo-ee translation
        map<string, string> secret_list = 1 [(extproto.sensitive) = true];
    }
    message Config {

        reserved 1, 2;

        // optional: used when defining complex boolean logic, if `boolean_expr` is defined below. Also used
        // in logging. If omitted, an automatically generated name will be used (e.g. config_0, of the
        // pattern 'config_$INDEX_IN_CHAIN'). In the case of plugin auth, this field is ignored in favor of
        // the name assigned on the plugin config itself.
        google.protobuf.StringValue name = 11;

        oneof auth_config {
            OAuthConfig oauth = 3 [deprecated = true];
            OAuth2Config oauth2 = 9;
            BasicAuth basic_auth = 4;
            ApiKeyAuthConfig api_key_auth = 5;
            AuthPlugin plugin_auth = 6;
            OpaAuthConfig opa_auth = 7;
            Ldap ldap = 8 [deprecated = true];
            // Used for LDAP configurations that need service account credentials saved in a secret.
            LdapConfig ldap_internal = 14;
            // This is a "dummy" extauth service which can be used to support multiple auth mechanisms with JWT authentication.
            // If Jwt authentication is to be used in the [boolean expression](https://docs.solo.io/gloo-edge/latest/reference/api/github.com/solo-io/gloo/projects/gloo/api/v1/enterprise/options/extauth/v1/extauth.proto.sk/#authconfig) in an AuthConfig, you can use this auth config type to include Jwt as an Auth config.
            // In addition, `allow_missing_or_failed_jwt` must be set on the Virtual Host or Route that uses JWT auth or else the JWT filter will short circuit this behaviour.
            google.protobuf.Empty jwt = 12;
            PassThroughAuth pass_through_auth = 13;
            HmacAuthConfig hmac_auth = 15;
        }
    }

    // List of auth configs to be checked for requests on a route referencing this auth config,
    // By default, every config must be authorized for the entire request to be authorized. This
    // behavior can be changed by defining names for each config and defining `boolean_expr` below.
    //
    // State is shared between successful requests on the chain, i.e., the headers returned from each
    // successful auth service get appended into the final auth response.
    repeated Config configs = 8;

    // How to handle processing of named configs within an auth config chain.
    // An example config might be: `( basic1 || basic2 || (oidc1 && !oidc2) )`
    // The boolean expression is evaluated left to right but honors parenthesis and short-circuiting.
    // Defaults to an empty string, which is interpreted as `and`-ing the configs.
    google.protobuf.StringValue boolean_expr = 10;

    // How the service should handle a redirect response from an OIDC issuer. In the default false mode,
    // the redirect will be considered a successful response, and the client will receive a 302 with a location header.
    // If this is set to true, the client will instead receive a 401 unauthorized response. This is useful in cases where
    // API calls are being made or other such occurrences where the client cannot handle the redirect.
    bool fail_on_redirect = 11;
}

/*
@solo-kit:resource.xds-enabled
*/
service ExtAuthDiscoveryService {
    rpc StreamExtAuthConfig (stream envoy.api.v2.DiscoveryRequest) returns (stream envoy.api.v2.DiscoveryResponse) {
    }

    rpc DeltaExtAuthConfig (stream envoy.api.v2.DeltaDiscoveryRequest) returns (stream envoy.api.v2.DeltaDiscoveryResponse) {
    }

    rpc FetchExtAuthConfig (envoy.api.v2.DiscoveryRequest) returns (envoy.api.v2.DiscoveryResponse) {
        option (google.api.http) = {
      post : "/v2/discovery:extauthconfig"
      body : "*"
    };
    }
}

message ApiKeyCreateRequest {
    repeated ApiKey api_keys = 1;
    repeated string raw_api_keys = 2;
}
message ApiKeyCreateResponse {
    repeated ApiKey api_keys = 1;
}
message ApiKeyReadRequest {
    repeated string raw_api_keys = 1;
    repeated string labels = 2;
}
message ApiKeyReadResponse {
    repeated ApiKey api_keys = 1;
}
message ApiKeyUpdateRequest {
    bool upsert = 1;
    repeated ApiKey api_keys = 2;
    repeated string raw_api_keys = 3;
}
message ApiKeyUpdateResponse {
    repeated ApiKey api_keys = 1;
}
message ApiKeyDeleteRequest {
    repeated string raw_api_keys = 1;
    repeated string labels = 2;
}
message ApiKeyDeleteResponse {}
service ApiKeyService {
    rpc Create (ApiKeyCreateRequest) returns (ApiKeyCreateResponse) {}
    rpc Read (ApiKeyReadRequest) returns (ApiKeyReadResponse) {}
    rpc Update (ApiKeyUpdateRequest) returns (ApiKeyUpdateResponse) {}
    rpc Delete (ApiKeyDeleteRequest) returns (ApiKeyDeleteResponse) {}
}
