syntax = "proto3";
package enterprise.gloo.solo.io;

option go_package = "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/extauth/v1";

import "github.com/solo-io/solo-kit/api/v1/ref.proto";

import "extproto/ext.proto";
option (extproto.equal_all) = true;
option (extproto.hash_all) = true;
option (extproto.clone_all) = true;

import "github.com/solo-io/solo-kit/api/v1/metadata.proto";
import "github.com/solo-io/solo-kit/api/v1/status.proto";
import "github.com/solo-io/solo-kit/api/v1/solo-kit.proto";
import "github.com/solo-io/solo-kit/api/external/envoy/api/v2/discovery.proto";
import "github.com/solo-io/gloo/projects/gloo/api/v1/enterprise/options/extauth/v1/extauth.proto";
import "google/api/annotations.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/wrappers.proto";
import "google/protobuf/empty.proto";
/*
@solo-kit:xds-service=ExtAuthDiscoveryService
@solo-kit:resource.no_references

This is an internal API used to share configuration between gloo-ee and extauth. Although this API is only used in gloo-ee,
rules about breaking changes still apply to ensure we do not get errors during upgrade and downgrade.
 */
message ExtAuthConfig {
    // For apps in Microsoft Azure, configure Microsoft Entra ID as the OpenID Connect (OIDC) provider.
    // This way, you can enable distributed claims and caching for when users are members of more than 200 groups.
    message Azure {
        // The client ID for the ExtAuthService app that is registered in MS Entra,
        // to access the Microsoft Graph API to retrieve distributed claims.
        // This app is NOT the app that you want to configure external auth for.
        string client_id = 1;

        // The tenant ID represents the MS Entra organization ID where the ExtAuthService app is registered.
        // This tenant ID may or may not be the same as in the top level `OidcAuthorizationCodeConfig`,
        // depending on how your Azure account is provisioned.
        string tenant_id = 2;

        // The client secret of the ExtAuthService app that is registered with MS Entra to communicate with the MS Graph API.
        string client_secret = 3 [(extproto.sensitive) = true];

        // Redis connection details to cache MS Entera claims.
        // This way, you avoid performance issues of accessing the Microsoft Graph API too many times.
        // Note that this setting does NOT turn on Redis caching for the user session.
        // To turn on Redis user session caching, use the `userSessionConfig` field.
        RedisOptions claims_caching_options = 4;
    }

      // Map a single claim from an OAuth2 or OIDC token to a header in the request to the upstream destination.
    message ClaimToHeader {
        // The claim name from the token, such as `sub`.
        string claim = 1;

        // The header to copy the claim to, such as `x-sub`.
        string header = 2;

        // If the header exists, append the claim value to the header (true), or overwrite any existing value (false). The default behavior is to overwrite any existing value (false).
        bool append = 3;
    }

    // @solo-kit:resource.name
    // This is the identifier of the AuthConfig resource that this configuration is associated with.
    // Any request to the external auth server includes an identifier that is matched against this field to determine
    // which AuthConfig should be applied to it.
    string auth_config_ref_name = 1;

    // Message to store Basic Auth Configuration.
    // "Internal" refers to this format allowing for selection of the hashing algorithm and user source.
    // If only the legacy "apr" field is defined, the existing public BasicAuth configuration will continue be used.
    message BasicAuthInternal {
        // Realm to use in the Basic Auth challenge.
        string realm = 1;

        // Selection of hashing algorithms to use for password hashing.
        message EncryptionType {
            message Sha1 {}
            message Apr {}
            oneof algorithm {
                Apr apr = 1;
                Sha1 sha1 = 2;
            }
        }

        // Hashing algorithm to use for password hashing.
        EncryptionType encryption = 2;

        // To authenticate a user we need the salt and hashed password. The username is expected to be the key in a map of Users.
        message User {
            string salt = 1;
            string hashed_password = 2;
        }

        // Map of valid usernames to stored credentials
        message UserList {
            map<string, User> users= 1;
        }

        // Source of user credential data.
        oneof user_source {
            UserList user_list = 3;
        }
    }


    // Deprecated, prefer OAuth2Config
    message OAuthConfig {
        // your client id as registered with the issuer
        string client_id = 1 [deprecated = true];

        // your client secret as registered with the issuer
        string client_secret = 2 [deprecated = true, (extproto.sensitive) = true];

        // The url of the issuer. We will look for OIDC information in issuerUrl+
        // ".well-known/openid-configuration"
        string issuer_url = 3 [deprecated = true];

        // extra query parameters to apply to the Ext-Auth service's authorization request to the identity provider.
        map<string, string> auth_endpoint_query_params = 7 [deprecated = true];

        // we to redirect after successful auth, if we can't determine the original
        // url this should be your publicly available app url.
        string app_url = 4 [deprecated = true];

        // a callback path relative to app url that will be used for OIDC callbacks.
        // needs to not be used by the application
        string callback_path = 5 [deprecated = true];

        // scopes to request in addition to the openid scope.
        repeated string scopes = 6 [deprecated = true];

    }

    message UserSessionConfig {
        // should we fail auth flow when failing to get a session from redis, or allow it to continue,
        // potentially starting a new auth flow and setting a new session.
        bool fail_on_fetch_failure = 1;
        // Set-Cookie options
        UserSession.CookieOptions cookie_options = 2;
        oneof session {
            // Set the tokens in the cookie itself. No need for server side state.
            UserSession.InternalSession cookie = 3;
            // Use redis to store the tokens and just store a random id in the cookie.
            UserSession.RedisSession redis = 4;
        }
        message CipherConfig {
            // to enable the cipher encryption, the key has to be present.
            // Note that the key has to be found and 32 bytes in length for the authconfig to not be rejected.
            string key = 1 [(extproto.sensitive) = true];
        }
        // the cipher config enables the symmetric key encryption of the cookie values of the user session.
        CipherConfig cipher_config = 5;
    }

    message OidcAuthorizationCodeConfig {
        // your client id as registered with the issuer
        string client_id = 1;

        // your client secret as registered with the issuer.
        // Only one of client_secret or pk_jwt_client_authentication_config should be set. pk_jwt_client_authentication_config takes precedence.
        string client_secret = 2 [(extproto.sensitive) = true];

        // The url of the issuer. We will look for OIDC information in issuerUrl+
        // ".well-known/openid-configuration"
        string issuer_url = 3;

        // extra query parameters to apply to the Ext-Auth service's authorization request to the identity provider.
        // this can be useful for flows such as PKCE (https://www.oauth.com/oauth2-servers/pkce/authorization-request/)
        // to set the `code_challenge` and `code_challenge_method`.
        map<string, string> auth_endpoint_query_params = 4;

        // extra query parameters to apply to the Ext-Auth service's token request to the identity provider.
        // this can be useful for flows such as PKCE (https://www.oauth.com/oauth2-servers/pkce/authorization-request/)
        // to set the `code_verifier`.
        map<string, string> token_endpoint_query_params = 14;

        // we to redirect after successful auth, if we can't determine the original
        // url this should be your publicly available app url.
        string app_url = 5;

        // a callback path relative to app url that will be used for OIDC callbacks.
        // needs to not be used by the application
        string callback_path = 6;

        // a path relative to app url that will be used for logging out from an OIDC session.
        // should not be used by the application.
        // If not provided, logout functionality will be disabled.
        string logout_path = 9;

        // url to redirect to after logout.
        // This should be a publicly available URL. If not provided, will default to the `app_url`.
        string after_logout_url = 15;

        // scopes to request in addition to the openid scope.
        repeated string scopes = 7;

        // DEPRECATED: use userSessionConfig [userSession]
        UserSession session = 8 [deprecated = true];

        // Configures headers added to requests.
        HeaderConfiguration headers = 10;

        // OIDC configuration is discovered at <issuerUrl>/.well-known/openid-configuration
        // The configuration override defines any properties that should override this discovery configuration
        // For example, the following AuthConfig CRD could be defined as:
        //    ```yaml
        //    apiVersion: enterprise.gloo.solo.io/v1
        //    kind: AuthConfig
        //    metadata:
        //      name: google-oidc
        //      namespace: gloo-system
        //    spec:
        //      configs:
        //      - oauth:
        //          app_url: http://localhost:8080
        //          callback_path: /callback
        //          client_id: $CLIENT_ID
        //          client_secret_ref:
        //            name: google
        //            namespace: gloo-system
        //          issuer_url: https://accounts.google.com
        //          discovery_override:
        //            token_endpoint: "https://token.url/gettoken"
        //    ```
        //
        // And this will ensure that regardless of what value is discovered at
        // <issuerUrl>/.well-known/openid-configuration, "https://token.url/gettoken" will be used as the token endpoint
        DiscoveryOverride discovery_override = 11;

        // The interval at which OIDC configuration is discovered at <issuerUrl>/.well-known/openid-configuration
        // If not specified, the default value is 30 minutes.
        google.protobuf.Duration discovery_poll_interval = 12;

        // If a user executes a request with a key that is not found in the JWKS, it could be
        // that the keys have rotated on the remote source, and not yet in the local cache.
        // This policy lets you define the behavior for how to refresh the local cache during a request
        // where an invalid key is provided
        JwksOnDemandCacheRefreshPolicy jwks_cache_refresh_policy = 13;

        // in the future we may implement this:
        // add optional configuration for validation of the access token received during the OIDC flow
        // AccessTokenValidation access_token_validation = 8;

        // If set, the randomly generated session id will be sent to the token endpoint as part of the code exchange
        // The session id is used as the key for sessions in Redis
        string session_id_header_name = 16;

        // If set, CallbackPath will be evaluated as a regular expression
        bool parse_callback_path_as_regex = 17;

        // If specified, authEndpointQueryParams and tokenEndpointQueryParams will be populated using dynamic metadata values.
        // By default parameters will be extracted from the solo_authconfig_oidc namespace
        // this behavior can be overridden by explicitly specifying a namespace
        AutoMapFromMetadata auto_map_from_metadata = 18;

        // If specified, these are properties defined for the end session endpoint
        // specifications. Noted [here](https://openid.net/specs/openid-connect-rpinitiated-1_0.html)
        // in the OIDC documentation.
        EndSessionProperties end_session_properties = 19;

        // Configuration related to the user session.
        UserSessionConfig user_session = 20;

        // Fields for private key JWT Client Authentication.
        message PkJwtClientAuthenticationConfig{
            // Signing key for the JWT used for client authentication
            string signing_key = 1 [(extproto.sensitive) = true];
            // Amount of time for which the JWT is valid. No maximum is enforced, but different IDPs may impose limits on how far in
            // the future the expiration time is allowed to be. Defaults in 5s in front end, but expected to be set explicitly here
            google.protobuf.Duration valid_for = 2;
        }

        // Configuration for private key JWT client authentication.
        // Only one of client_secret or pk_jwt_client_authentication_config should be set. pk_jwt_client_authentication_config takes precedence.
        PkJwtClientAuthenticationConfig pk_jwt_client_authentication_config = 21;

        // Optional: Configuration specific to the OAuth2 access token received and processed by the ext-auth-service.
        AccessToken access_token = 22;

        // Optional: Configuration specific to the OIDC identity token received and processed by the ext-auth-service.
        IdentityToken identity_token = 23;

        // Optional: Map a single claim from an OAuth2 access token to a header in the request to the upstream destination.
        message AccessToken {
            // A list of claims to be mapped from the JWT token received by ext-auth-service to an upstream destination
            repeated ClaimToHeader claims_to_headers = 1;
        }

        // Optional: Map a single claim from an OIDC identity token to a header in the request to the upstream destination.
        message IdentityToken {
            // A list of claims to be mapped from the JWT token received by ext-auth-service to an upstream destination
            repeated ClaimToHeader claims_to_headers = 1;
        }

        oneof Provider {
            Default default = 26;
            Azure azure = 27;
        }

        // No-op, represents default OIDC behavior
        message Default {}

       // For the moment this is just path, but we may want to configure things like iss/sid validation
        message FrontChannelLogout {
            // Path to use for front channel logout. Should not be the same as logout or callback paths.
            string path=1;
        }

        // Configuration for front channel logout. This is used to log out the user from multiple apps/clients associated with one OpenId Provider (OP).
        // The path is registered with the OP and is called for each app/client that the user is logged into when the logout endpoint is called.
        FrontChannelLogout front_channel_logout = 28;


        // Map of metadata key to claim. Ie:
        // dynamic_metadata_from_claims:
        //   issuer: iss
        //   email: email
        // When specified, the matching claims from the ID token will be emitted as dynamic metadata.
        // Note that metadata keys must be unique, and the claim names must be alphanumeric and use `-` or `_` as separators.
        // The metadata will live in a namespace specified by the canonical name of the ext auth filter (in our case `envoy.filters.http.ext_authz`),
        // and the structure of the claim value will be preserved in the metadata struct.
        map<string, string> dynamic_metadata_from_claims = 29;
    }

    message AccessTokenValidationConfig {
        // Defines how JSON Web Token (JWT) access tokens are validated.
        //
        // Tokens are validated using a JSON Web Key Set (as defined in
        // [Section 5 of RFC7517](https://datatracker.ietf.org/doc/html/rfc7517#section-5)),
        // which can be either inlined in the configuration or fetched from a remote location via HTTP.
        // Any keys in the JWKS that are not intended for signature verification (i.e. whose
        // ["use" parameter](https://datatracker.ietf.org/doc/html/rfc7517#section-4.2) is not "sig")
        // will be ignored by the system, as will keys that do not specify a
        // ["kid" (Key ID) parameter](https://datatracker.ietf.org/doc/html/rfc7517#section-4.2).
        //
        // The JWT to be validated must define non-empty "kid" and "alg" headers. The "kid" header
        // determines which key in the JWKS will be used to verify the signature of the token;
        // if no matching key is found, the token will be rejected.
        //
        // If present, the server will verify the "exp", "iat", and "nbf" standard JWT claims.
        // Validation of the "iss" claim and of token scopes can be configured as well.
        // If the JWT has been successfully validated, its set of claims will be added to the
        // `AuthorizationRequest` state under the "jwtAccessToken" key.
        message JwtValidation {

            // Specifies how to fetch JWKS from remote and how to cache it.
            message RemoteJwks {
                // The HTTP URI to fetch the JWKS.
                string url = 1;

                // The frequency at which the JWKS should be refreshed.
                // If not specified, the default value is 5 minutes.
                google.protobuf.Duration refresh_interval = 2;
            }

            // Represents a locally available JWKS.
            message LocalJwks {
                // JWKS is embedded as a string.
                string inline_string = 1;
            }

            oneof jwks_source_specifier {
                // Fetches the JWKS from a remote location.
                RemoteJwks remote_jwks = 1;
                // Loads the JWKS from a local data source.
                LocalJwks local_jwks = 2;
            }

            // Allow only tokens that have been issued by this principal (i.e. whose "iss" claim matches this value).
            // If empty, issuer validation will be skipped.
            string issuer = 3;
        }

        // Defines how (opaque) access tokens, received from the oauth authorization endpoint, are validated
        // [OAuth2.0 Token Introspection](https://datatracker.ietf.org/doc/html/rfc7662)
        //
        // If the token introspection url requires client authentication, both the client_id and client_secret
        // are required. If only one is provided, the config will be rejected.
        // These values will be encoded in a basic auth header in order to authenticate the client.
        message IntrospectionValidation {
            // The URL for the [OAuth2.0 Token Introspection](https://datatracker.ietf.org/doc/html/rfc7662) endpoint.
            // If provided, the (opaque) access token provided or received from the oauth authorization endpoint
            // will be validated against this endpoint, or locally cached responses for this access token.
            string introspection_url = 1;

            // Your client id as registered with the issuer.
            // Optional: Use if the token introspection url requires client authentication.
            string client_id = 2;

            // Your client secret as registered with the issuer.
            // Optional: Use if the token introspection url requires client authentication.
            string client_secret = 3 [(extproto.sensitive) = true];

            // The name of the [introspection response](https://datatracker.ietf.org/doc/html/rfc7662#section-2.2)
            // attribute that contains the ID of the resource owner (e.g. `sub`, `username`).
            // If specified, the external auth server will use the value of the attribute as the identifier of the
            // authenticated user and add it to the request headers and/or dynamic metadata (depending on how the
            // server is configured); if the field is set and the attribute cannot be found, the request will be denied.
            // This field is optional and by default the server will not try to derive the user ID.
            string user_id_attribute_name = 4;

        }

        oneof validation_type {
            // The URL for the [OAuth2.0 Token Introspection](https://datatracker.ietf.org/doc/html/rfc7662) endpoint.
            // If provided, the (opaque) access token provided or received from the oauth authorization endpoint
            // will be validated against this endpoint, or locally cached responses for this access token.
            // This field is deprecated as it does not support authenticated introspection requests
            string introspection_url = 1 [deprecated = true];

            // Validate access tokens that conform to the
            // [JSON Web Token (JWT)](https://datatracker.ietf.org/doc/rfc7662/) specification.
            JwtValidation jwt = 2;

            // Defines how (opaque) access tokens, received from the oauth authorization endpoint, are validated
            // [OAuth2.0 Token Introspection](https://datatracker.ietf.org/doc/html/rfc7662) specification.
            IntrospectionValidation introspection = 3;

            // In the future we may implement HMAC validation
        }

        // The URL for the OIDC userinfo endpoint.
        // If provided, the (opaque) access token provided or received from the oauth endpoint
        // will be queried and the userinfo response (or cached response) will be added to the
        // `AuthorizationRequest` state under the "introspection" key.
        // This can be useful to leverage the userinfo response in, for example, an external auth server plugin.
        string userinfo_url = 4;

        // How long the token introspection and userinfo endpoint response for a specific access token should be kept
        // in the in-memory cache. The result will be invalidated at this timeout, or at "exp" time from the introspection
        // result, whichever comes sooner. If omitted, defaults to 10 minutes. If zero, then no caching will be done.
        google.protobuf.Duration cache_timeout = 5;

        // Optional criteria for validating the scopes of a token.
        oneof scope_validation {
            // Require access token to have all of the scopes in the given list.
            // This configuration applies to both opaque and JWT tokens. In the case of opaque tokens,
            // this will check the scopes returned in the "scope" member of introspection response
            // (as described in [Section 2.2 of RFC7662](https://datatracker.ietf.org/doc/html/rfc7662#section-2.2).
            // In case of JWTs the scopes to be validated are expected to be contained in the "scope" claim of the
            // token in the form of a space-separated string.
            // Omitting this field means that scope validation will be skipped.
            ScopeList required_scopes = 6;

            // in the future we may add other types of scope validation (e.g. predicate matching)
        }

        message ScopeList {
            repeated string scope = 1;
        }

        // Map of metadata key to claim. Ie:
        // dynamic_metadata_from_claims:
        //   issuer: iss
        //   email: email
        // When specified, the matching claims from the access token will be emitted as dynamic metadata.
        // Note that metadata keys must be unique, and the claim names must be alphanumeric and use `-` or `_` as separators.
        // Works when the access token is a JWT or when the access token is opaque, in which case the claims will refer to field in the response from the token introspection endpoint.
        // The metadata will live in a namespace specified by the canonical name of the ext auth filter (in our case `envoy.filters.http.ext_authz`),
        // and the structure of the claim value will be preserved in the metadata struct.
        map<string, string> dynamic_metadata_from_claims = 7;

        repeated ClaimToHeader claims_to_headers = 8;

        oneof Provider {
            Default default = 26;
            Azure azure = 27;
        }

        // No-op, represents default OIDC behavior
        message Default {}
    }

    message PlainOAuth2Config {
        // Your client ID as registered with the issuer
        string client_id = 1;

        // Your client secret as registered with the issuer
        string client_secret = 2 [(extproto.sensitive) = true];

        // Extra query parameters to apply to the Ext-Auth service's authorization request to the identity provider.
        // These parameters can be useful for flows such as [PKCE](https://www.oauth.com/oauth2-servers/pkce/authorization-request/)
        // to set the `code_challenge` and `code_challenge_method`.
        map<string, string> auth_endpoint_query_params = 3;

        // Where to redirect after successful auth, if Gloo can't determine the original URL.
        // Set this field to your publicly available app URL.
        string app_url = 4;

        // A callback path relative to the app URL to be used for OAuth2 callbacks.
        // Do not use this path in the application itself.
        string callback_path = 5;

        // Scopes to request for.
        repeated string scopes = 6;

        // DEPRECATED: use userSessionConfig [userSession]
        UserSession session = 7 [deprecated = true];

        // A path relative to the app URL to use for logging out from an OAuth2 session.
        // Do not use this path in the application itself.
        // If not provided, logout functionality is disabled.
        string logout_path = 8;

        // Extra query parameters to apply to the Ext-Auth service's token request to the identity provider.
        // These parameters can be useful for flows such as [PKCE](https://www.oauth.com/oauth2-servers/pkce/authorization-request/)
        // to set the `code_verifier`.
        map<string, string> token_endpoint_query_params = 9;

        // URL to redirect to after logout.
        // Set this field to a publicly available URL. If not provided, this value defaults to the `app_url` value.
        string after_logout_url = 10;

        // The URL of the provider authorization endpoint.
        string auth_endpoint = 11;

        // The URL of the provider token endpoint.
        string token_endpoint = 12;

        // The URL of the provider token revocation endpoint.
        // For more information, refer to https://www.rfc-editor.org/rfc/rfc7009.
        string revocation_endpoint = 13;

        // Configuration related to the user session.
        UserSessionConfig user_session = 14;
    }

    message OAuth2Config {
        reserved 2;

        oneof oauth_type {
            // provide issuer location and let gloo handle OIDC flow for you.
            // requests authorized by validating the contents of ID token.
            // can also authorize the access token if configured.
            OidcAuthorizationCodeConfig oidc_authorization_code = 1;

            // provide the access token on the request and let gloo handle authorization.
            //
            // according to https://datatracker.ietf.org/doc/html/rfc6750 you can pass tokens through:
            // - form-encoded body parameter. recommended, more likely to appear. e.g.: Authorization: Bearer mytoken123
            // - URI query parameter e.g. access_token=mytoken123
            // - and (preferably) secure cookies
            AccessTokenValidationConfig access_token_validation_config = 3;

            // Enterprise-Only: THIS FEATURE IS IN TECH PREVIEW. APIs are versioned as alpha and subject to change.
            // provide issuer location and let Gloo handle Oauth2 flow for you.
            // requests authorized by validating the contents of access token.
            // Prefer to use OIDC for better security.
            PlainOAuth2Config oauth2_config = 4;
        }
    }

    // **NOTE: This configuration is not user-facing and will be auto generated**
    message ApiKeyAuthConfig {

        message KeyMetadata {
            // The user is mapped as the name of `Secret` which contains the `ApiKey`
            string username = 1;
            // The metadata present on the `ApiKey`.
            map<string, string> metadata = 2;
        }

        // A mapping of valid API keys to their associated metadata.
        // This map is automatically populated with the information from the relevant `ApiKey`s.
        // Currently this is only configured when using the k8s Secret storage backend
        map<string, KeyMetadata> valid_api_keys = 1 [(extproto.sensitive) = true];

        // (Optional) When receiving a request, the Gloo Edge Enterprise external auth server will look for an API key
        // in a header with this name. This field is optional; if not provided it defaults to `api-key`.
        string header_name = 2;

        // Determines the key metadata that will be included as headers on the upstream request.
        // Each entry represents a header to add: the key is the name of the header, and the
        // value is the key that will be used to look up the data entry in the key metadata.
        map<string, string> headers_from_key_metadata = 3;

        oneof storage_backend {
            K8sSecretApiKeyStorage k8s_secret_apikey_storage = 4;
            AerospikeApiKeyStorage aerospike_apikey_storage = 5;
            ServerDefaultApiKeyStorage server_default_apikey_storage = 7;
        }

        // API key metadata may contain data is is invalid for a header, such as a newline. By default, this data will be validated
        // in the data plane and mitigated in a way that provides a consistent experience for the user and visibility for the operator.
        // This validation comes with a performance cost, and can be disabled by setting this field to `true`.
        bool skip_metadata_validation = 6;
    }

    message OpaAuthConfig {
        // An optional modules (filename, module content) maps containing modules assist in the resolution of `query`.
        map<string, string> modules = 1;

        // The query that determines the auth decision. The result of this query
        // must be either a boolean or an array with boolean as the first element. A boolean `true` value means that
        // the request will be authorized. Any other value, or error, means that the request will be denied.
        string query = 2;

        // Additional Options for Opa Auth configuration.
        OpaAuthOptions options = 3;
    }

    // Configure the Gloo external auth server to use your own Open Policy Agent (OPA) server.
    // This way, you can use extra capabilities such as bundling or caching.
    message OpaServerAuthConfig {
        
        // The package from your Rego policy bundle used to query the OPA data API.
        string package = 1;

        // The rule in your Rego policy bundle used to query the OPA data API. Supports querying subfields with a `/`.
        // For more information, see the [OPA docs for the Data API](https://www.openpolicyagent.org/docs/latest/rest-api/#data-api).
        string rule_name = 2;

        // The address of the OPA server to query, in the format `ADDRESS:PORT`.
        // For OPA servers within the cluster, the address is the pod’s service address,
        // such as `opa-svc.default.svc.cluster.local:8181`. 
        // For OPA servers outside the cluster, the server must be accessible to the cluster,
        // such as through an ExternalService. 
        // If you do not have your own OPA server instance, omit this field. 
        // When the external auth service has the OPA server sidecar enabled, 
        // the OPA server sidecar will be used instead, with an address such as `http://localhost:8181`.
        string server_addr = 3;

        // Additional options for OPA Auth configuration.
        OpaAuthOptions options = 4;
    }

    message LdapConfig {

        // Address of the LDAP server to query. Should be in the form ADDRESS:PORT, e.g. `ldap.default.svc.cluster.local:389`.
        string address = 1;

        // Template to build user entry distinguished names (DN). This must contains a single occurrence of the "%s" placeholder.
        // When processing a request, Gloo will substitute the name of the user (extracted from the auth header) for the
        // placeholder and issue a search request with the resulting DN as baseDN (and 'base' search scope).
        // E.g. "uid=%s,ou=people,dc=solo,dc=io"
        string userDnTemplate = 2;

        // Case-insensitive name of the attribute that contains the names of the groups an entry is member of. Gloo will look
        // for attributes with the given name to determine which groups the user entry belongs to. Defaults to 'memberOf' if not provided.
        string membershipAttributeName = 3;

        // In order for the request to be authenticated, the membership attribute (e.g. *memberOf*) on the user entry must
        // contain at least of one of the group DNs specified via this option.
        // E.g. []string{ "cn=managers,ou=groups,dc=solo,dc=io", "cn=developers,ou=groups,dc=solo,dc=io" }
        repeated string allowedGroups = 4;

        // Use this property to tune the pool of connections to the LDAP server that Gloo maintains.
        Ldap.ConnectionPool pool = 5;

        // Use to set a custom filter when searching a member. Defaults to "(uid=*)".
        string searchFilter = 6;

        // Disables group checking, regardless of the value for allowedGroups,
        // and disables validation for the membership attribute of the user entry.
        // Group checking is enabled by default.
        bool disable_group_checking = 7;

        // Settings for using a separate service account for looking up group membership
        // To use this, you also need to configure credentials
        LdapServiceAccountConfig group_lookup_settings = 8;
    }
    message LdapServiceAccountConfig {
        // username and password are taken from the secret during gloo-ee translation
        string username = 1 [(extproto.sensitive) = true];
        string password = 2 [(extproto.sensitive) = true];
        // If true, Gloo will use the service account to check group membership
        bool check_groups_with_service_account = 3;
    }
    message HmacAuthConfig {
        oneof secret_storage {
            InMemorySecretList secret_list = 1;
        }
        // Algorithm to use to turn the request into a hashable string
        oneof implementation_type{
            HmacParametersInHeaders parameters_in_headers = 2;
        }

    }
    // This API is only supported for Gloo Gateway Portal.
    message PortalAuthConfig {
        // The portal web server url used to validate credentials generated by the portal for the backing service(s).
        string url = 1;
        // The api key header name used to find the api key in the request headers.
        // If provided will not authorize requests without the api key in the request headers.
        // If not provided, will authorize requests with a Bearer token but must be chained with an AccessTokenValidation AuthConfig which will validate the token.

        string api_key_header = 2;
        // Options to connect to redis. If not provided, data will be cached in memory.
        RedisOptions redis_options = 3;
        // The frequency at which the validated credential data should be refreshed by quering the portal web server. Defaults to 60s
        google.protobuf.Duration cache_duration = 4;
        // Timeout for the portal web server to respond. Defaults to 200ms
        google.protobuf.Duration request_timeout = 5;
    }
    message InMemorySecretList {
        // list of username/password pairs taken from secrets during gloo-ee translation
        map<string, string> secret_list = 1 [(extproto.sensitive) = true];
    }
    message Config {

        reserved 1, 2;

        // optional: used when defining complex boolean logic, if `boolean_expr` is defined below. Also used
        // in logging. If omitted, an automatically generated name will be used (e.g. config_0, of the
        // pattern 'config_$INDEX_IN_CHAIN'). In the case of plugin auth, this field is ignored in favor of
        // the name assigned on the plugin config itself.
        google.protobuf.StringValue name = 11;

        oneof auth_config {
            OAuthConfig oauth = 3 [deprecated = true];
            OAuth2Config oauth2 = 9;
            BasicAuth basic_auth = 4;
            BasicAuthInternal basic_auth_internal = 17;
            ApiKeyAuthConfig api_key_auth = 5;
            AuthPlugin plugin_auth = 6 [deprecated = true];
            OpaAuthConfig opa_auth = 7;
            Ldap ldap = 8 [deprecated = true];
            // Used for LDAP configurations that need service account credentials saved in a secret.
            LdapConfig ldap_internal = 14;
            // This is a "dummy" extauth service which can be used to support multiple auth mechanisms with JWT authentication.
            // If Jwt authentication is to be used in the [boolean expression](https://docs.solo.io/gloo-edge/latest/reference/api/github.com/solo-io/gloo/projects/gloo/api/v1/enterprise/options/extauth/v1/extauth.proto.sk/#authconfig) in an AuthConfig, you can use this auth config type to include Jwt as an Auth config.
            // In addition, `allow_missing_or_failed_jwt` must be set on the Virtual Host or Route that uses JWT auth or else the JWT filter will short circuit this behaviour.
            google.protobuf.Empty jwt = 12;
            PassThroughAuth pass_through_auth = 13;
            HmacAuthConfig hmac_auth = 15;
            OpaServerAuthConfig opa_server_auth = 16;
            PortalAuthConfig portal_auth = 18;
        }
    }

    // List of auth configs to be checked for requests on a route referencing this auth config,
    // By default, every config must be authorized for the entire request to be authorized. This
    // behavior can be changed by defining names for each config and defining `boolean_expr` below.
    //
    // State is shared between successful requests on the chain, i.e., the headers returned from each
    // successful auth service get appended into the final auth response.
    repeated Config configs = 8;

    // How to handle processing of named configs within an auth config chain.
    // An example config might be: `( basic1 || basic2 || (oidc1 && !oidc2) )`
    // The boolean expression is evaluated left to right but honors parenthesis and short-circuiting.
    // Defaults to an empty string, which is interpreted as `and`-ing the configs.
    google.protobuf.StringValue boolean_expr = 10;

    // How the service should handle a redirect response from an OIDC issuer. In the default false mode,
    // the redirect will be considered a successful response, and the client will receive a 302 with a location header.
    // If this is set to true, the client will instead receive a 401 unauthorized response. This is useful in cases where
    // API calls are being made or other such occurrences where the client cannot handle the redirect.
    bool fail_on_redirect = 11;
}

/*
@solo-kit:resource.xds-enabled
*/
service ExtAuthDiscoveryService {
    rpc StreamExtAuthConfig (stream envoy.api.v2.DiscoveryRequest) returns (stream envoy.api.v2.DiscoveryResponse) {
    }

    rpc DeltaExtAuthConfig (stream envoy.api.v2.DeltaDiscoveryRequest) returns (stream envoy.api.v2.DeltaDiscoveryResponse) {
    }

    rpc FetchExtAuthConfig (envoy.api.v2.DiscoveryRequest) returns (envoy.api.v2.DiscoveryResponse) {
        option (google.api.http) = {
      post : "/v2/discovery:extauthconfig"
      body : "*"
    };
    }
}

message ApiKeyCreateRequest {
    repeated ApiKey api_keys = 1;
    repeated string raw_api_keys = 2;
}
message ApiKeyCreateResponse {
    repeated ApiKey api_keys = 1;
}
message ApiKeyReadRequest {
    repeated string raw_api_keys = 1;
    repeated string labels = 2;
}
message ApiKeyReadResponse {
    repeated ApiKey api_keys = 1;
}
message ApiKeyUpdateRequest {
    bool upsert = 1;
    repeated ApiKey api_keys = 2;
    repeated string raw_api_keys = 3;
}
message ApiKeyUpdateResponse {
    repeated ApiKey api_keys = 1;
}
message ApiKeyDeleteRequest {
    repeated string raw_api_keys = 1;
    repeated string labels = 2;
}
message ApiKeyDeleteResponse {}
service ApiKeyService {
    rpc Create (ApiKeyCreateRequest) returns (ApiKeyCreateResponse) {}
    rpc Read (ApiKeyReadRequest) returns (ApiKeyReadResponse) {}
    rpc Update (ApiKeyUpdateRequest) returns (ApiKeyUpdateResponse) {}
    rpc Delete (ApiKeyDeleteRequest) returns (ApiKeyDeleteResponse) {}
}
