// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./sets.go -destination mocks/sets.go

package v2sets

import (
	resilience_policy_gloo_solo_io_v2 "github.com/solo-io/gloo/projects/gloo/cli/pkg/cmd/gatewayapi/envoy/gloo-mesh-client-go/resilience.policy.gloo.solo.io/v2"

	"github.com/rotisserie/eris"
	sksets "github.com/solo-io/skv2/contrib/pkg/sets"
	"github.com/solo-io/skv2/pkg/ezkube"
	"k8s.io/apimachinery/pkg/util/sets"
)

type GraphQLPersistedQueryCachePolicySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) bool) []*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) bool) []*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy
	// Return the Set as a map of key to resource.
	Map() map[string]*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy
	// Insert a resource into the set.
	Insert(graphQLPersistedQueryCachePolicy ...*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(graphQLPersistedQueryCachePolicySet GraphQLPersistedQueryCachePolicySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(graphQLPersistedQueryCachePolicy ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(graphQLPersistedQueryCachePolicy ezkube.ResourceId)
	// Return the union with the provided set
	Union(set GraphQLPersistedQueryCachePolicySet) GraphQLPersistedQueryCachePolicySet
	// Return the difference with the provided set
	Difference(set GraphQLPersistedQueryCachePolicySet) GraphQLPersistedQueryCachePolicySet
	// Return the intersection with the provided set
	Intersection(set GraphQLPersistedQueryCachePolicySet) GraphQLPersistedQueryCachePolicySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another GraphQLPersistedQueryCachePolicySet
	Delta(newSet GraphQLPersistedQueryCachePolicySet) sksets.ResourceDelta
	// Create a deep copy of the current GraphQLPersistedQueryCachePolicySet
	Clone() GraphQLPersistedQueryCachePolicySet
}

func makeGenericGraphQLPersistedQueryCachePolicySet(graphQLPersistedQueryCachePolicyList []*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range graphQLPersistedQueryCachePolicyList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type graphQLPersistedQueryCachePolicySet struct {
	set sksets.ResourceSet
}

func NewGraphQLPersistedQueryCachePolicySet(graphQLPersistedQueryCachePolicyList ...*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) GraphQLPersistedQueryCachePolicySet {
	return &graphQLPersistedQueryCachePolicySet{set: makeGenericGraphQLPersistedQueryCachePolicySet(graphQLPersistedQueryCachePolicyList)}
}

func NewGraphQLPersistedQueryCachePolicySetFromList(graphQLPersistedQueryCachePolicyList *resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicyList) GraphQLPersistedQueryCachePolicySet {
	list := make([]*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy, 0, len(graphQLPersistedQueryCachePolicyList.Items))
	for idx := range graphQLPersistedQueryCachePolicyList.Items {
		list = append(list, &graphQLPersistedQueryCachePolicyList.Items[idx])
	}
	return &graphQLPersistedQueryCachePolicySet{set: makeGenericGraphQLPersistedQueryCachePolicySet(list)}
}

func (s *graphQLPersistedQueryCachePolicySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *graphQLPersistedQueryCachePolicySet) List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) bool) []*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy))
		})
	}

	objs := s.Generic().List(genericFilters...)
	graphQLPersistedQueryCachePolicyList := make([]*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy, 0, len(objs))
	for _, obj := range objs {
		graphQLPersistedQueryCachePolicyList = append(graphQLPersistedQueryCachePolicyList, obj.(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy))
	}
	return graphQLPersistedQueryCachePolicyList
}

func (s *graphQLPersistedQueryCachePolicySet) UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) bool) []*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy))
		})
	}

	var graphQLPersistedQueryCachePolicyList []*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		graphQLPersistedQueryCachePolicyList = append(graphQLPersistedQueryCachePolicyList, obj.(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy))
	}
	return graphQLPersistedQueryCachePolicyList
}

func (s *graphQLPersistedQueryCachePolicySet) Map() map[string]*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy {
	if s == nil {
		return nil
	}

	newMap := map[string]*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy)
	}
	return newMap
}

func (s *graphQLPersistedQueryCachePolicySet) Insert(
	graphQLPersistedQueryCachePolicyList ...*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range graphQLPersistedQueryCachePolicyList {
		s.Generic().Insert(obj)
	}
}

func (s *graphQLPersistedQueryCachePolicySet) Has(graphQLPersistedQueryCachePolicy ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(graphQLPersistedQueryCachePolicy)
}

func (s *graphQLPersistedQueryCachePolicySet) Equal(
	graphQLPersistedQueryCachePolicySet GraphQLPersistedQueryCachePolicySet,
) bool {
	if s == nil {
		return graphQLPersistedQueryCachePolicySet == nil
	}
	return s.Generic().Equal(graphQLPersistedQueryCachePolicySet.Generic())
}

func (s *graphQLPersistedQueryCachePolicySet) Delete(GraphQLPersistedQueryCachePolicy ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(GraphQLPersistedQueryCachePolicy)
}

func (s *graphQLPersistedQueryCachePolicySet) Union(set GraphQLPersistedQueryCachePolicySet) GraphQLPersistedQueryCachePolicySet {
	if s == nil {
		return set
	}
	return NewGraphQLPersistedQueryCachePolicySet(append(s.List(), set.List()...)...)
}

func (s *graphQLPersistedQueryCachePolicySet) Difference(set GraphQLPersistedQueryCachePolicySet) GraphQLPersistedQueryCachePolicySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &graphQLPersistedQueryCachePolicySet{set: newSet}
}

func (s *graphQLPersistedQueryCachePolicySet) Intersection(set GraphQLPersistedQueryCachePolicySet) GraphQLPersistedQueryCachePolicySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var graphQLPersistedQueryCachePolicyList []*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy
	for _, obj := range newSet.List() {
		graphQLPersistedQueryCachePolicyList = append(graphQLPersistedQueryCachePolicyList, obj.(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy))
	}
	return NewGraphQLPersistedQueryCachePolicySet(graphQLPersistedQueryCachePolicyList...)
}

func (s *graphQLPersistedQueryCachePolicySet) Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find GraphQLPersistedQueryCachePolicy %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy), nil
}

func (s *graphQLPersistedQueryCachePolicySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *graphQLPersistedQueryCachePolicySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *graphQLPersistedQueryCachePolicySet) Delta(newSet GraphQLPersistedQueryCachePolicySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *graphQLPersistedQueryCachePolicySet) Clone() GraphQLPersistedQueryCachePolicySet {
	if s == nil {
		return nil
	}
	return &graphQLPersistedQueryCachePolicySet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type FailoverPolicySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.FailoverPolicy) bool) []*resilience_policy_gloo_solo_io_v2.FailoverPolicy
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.FailoverPolicy) bool) []*resilience_policy_gloo_solo_io_v2.FailoverPolicy
	// Return the Set as a map of key to resource.
	Map() map[string]*resilience_policy_gloo_solo_io_v2.FailoverPolicy
	// Insert a resource into the set.
	Insert(failoverPolicy ...*resilience_policy_gloo_solo_io_v2.FailoverPolicy)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(failoverPolicySet FailoverPolicySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(failoverPolicy ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(failoverPolicy ezkube.ResourceId)
	// Return the union with the provided set
	Union(set FailoverPolicySet) FailoverPolicySet
	// Return the difference with the provided set
	Difference(set FailoverPolicySet) FailoverPolicySet
	// Return the intersection with the provided set
	Intersection(set FailoverPolicySet) FailoverPolicySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.FailoverPolicy, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another FailoverPolicySet
	Delta(newSet FailoverPolicySet) sksets.ResourceDelta
	// Create a deep copy of the current FailoverPolicySet
	Clone() FailoverPolicySet
}

func makeGenericFailoverPolicySet(failoverPolicyList []*resilience_policy_gloo_solo_io_v2.FailoverPolicy) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range failoverPolicyList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type failoverPolicySet struct {
	set sksets.ResourceSet
}

func NewFailoverPolicySet(failoverPolicyList ...*resilience_policy_gloo_solo_io_v2.FailoverPolicy) FailoverPolicySet {
	return &failoverPolicySet{set: makeGenericFailoverPolicySet(failoverPolicyList)}
}

func NewFailoverPolicySetFromList(failoverPolicyList *resilience_policy_gloo_solo_io_v2.FailoverPolicyList) FailoverPolicySet {
	list := make([]*resilience_policy_gloo_solo_io_v2.FailoverPolicy, 0, len(failoverPolicyList.Items))
	for idx := range failoverPolicyList.Items {
		list = append(list, &failoverPolicyList.Items[idx])
	}
	return &failoverPolicySet{set: makeGenericFailoverPolicySet(list)}
}

func (s *failoverPolicySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *failoverPolicySet) List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.FailoverPolicy) bool) []*resilience_policy_gloo_solo_io_v2.FailoverPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.FailoverPolicy))
		})
	}

	objs := s.Generic().List(genericFilters...)
	failoverPolicyList := make([]*resilience_policy_gloo_solo_io_v2.FailoverPolicy, 0, len(objs))
	for _, obj := range objs {
		failoverPolicyList = append(failoverPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.FailoverPolicy))
	}
	return failoverPolicyList
}

func (s *failoverPolicySet) UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.FailoverPolicy) bool) []*resilience_policy_gloo_solo_io_v2.FailoverPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.FailoverPolicy))
		})
	}

	var failoverPolicyList []*resilience_policy_gloo_solo_io_v2.FailoverPolicy
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		failoverPolicyList = append(failoverPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.FailoverPolicy))
	}
	return failoverPolicyList
}

func (s *failoverPolicySet) Map() map[string]*resilience_policy_gloo_solo_io_v2.FailoverPolicy {
	if s == nil {
		return nil
	}

	newMap := map[string]*resilience_policy_gloo_solo_io_v2.FailoverPolicy{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*resilience_policy_gloo_solo_io_v2.FailoverPolicy)
	}
	return newMap
}

func (s *failoverPolicySet) Insert(
	failoverPolicyList ...*resilience_policy_gloo_solo_io_v2.FailoverPolicy,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range failoverPolicyList {
		s.Generic().Insert(obj)
	}
}

func (s *failoverPolicySet) Has(failoverPolicy ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(failoverPolicy)
}

func (s *failoverPolicySet) Equal(
	failoverPolicySet FailoverPolicySet,
) bool {
	if s == nil {
		return failoverPolicySet == nil
	}
	return s.Generic().Equal(failoverPolicySet.Generic())
}

func (s *failoverPolicySet) Delete(FailoverPolicy ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(FailoverPolicy)
}

func (s *failoverPolicySet) Union(set FailoverPolicySet) FailoverPolicySet {
	if s == nil {
		return set
	}
	return NewFailoverPolicySet(append(s.List(), set.List()...)...)
}

func (s *failoverPolicySet) Difference(set FailoverPolicySet) FailoverPolicySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &failoverPolicySet{set: newSet}
}

func (s *failoverPolicySet) Intersection(set FailoverPolicySet) FailoverPolicySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var failoverPolicyList []*resilience_policy_gloo_solo_io_v2.FailoverPolicy
	for _, obj := range newSet.List() {
		failoverPolicyList = append(failoverPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.FailoverPolicy))
	}
	return NewFailoverPolicySet(failoverPolicyList...)
}

func (s *failoverPolicySet) Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.FailoverPolicy, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find FailoverPolicy %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&resilience_policy_gloo_solo_io_v2.FailoverPolicy{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*resilience_policy_gloo_solo_io_v2.FailoverPolicy), nil
}

func (s *failoverPolicySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *failoverPolicySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *failoverPolicySet) Delta(newSet FailoverPolicySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *failoverPolicySet) Clone() FailoverPolicySet {
	if s == nil {
		return nil
	}
	return &failoverPolicySet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type OutlierDetectionPolicySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy
	// Return the Set as a map of key to resource.
	Map() map[string]*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy
	// Insert a resource into the set.
	Insert(outlierDetectionPolicy ...*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(outlierDetectionPolicySet OutlierDetectionPolicySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(outlierDetectionPolicy ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(outlierDetectionPolicy ezkube.ResourceId)
	// Return the union with the provided set
	Union(set OutlierDetectionPolicySet) OutlierDetectionPolicySet
	// Return the difference with the provided set
	Difference(set OutlierDetectionPolicySet) OutlierDetectionPolicySet
	// Return the intersection with the provided set
	Intersection(set OutlierDetectionPolicySet) OutlierDetectionPolicySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another OutlierDetectionPolicySet
	Delta(newSet OutlierDetectionPolicySet) sksets.ResourceDelta
	// Create a deep copy of the current OutlierDetectionPolicySet
	Clone() OutlierDetectionPolicySet
}

func makeGenericOutlierDetectionPolicySet(outlierDetectionPolicyList []*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range outlierDetectionPolicyList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type outlierDetectionPolicySet struct {
	set sksets.ResourceSet
}

func NewOutlierDetectionPolicySet(outlierDetectionPolicyList ...*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) OutlierDetectionPolicySet {
	return &outlierDetectionPolicySet{set: makeGenericOutlierDetectionPolicySet(outlierDetectionPolicyList)}
}

func NewOutlierDetectionPolicySetFromList(outlierDetectionPolicyList *resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicyList) OutlierDetectionPolicySet {
	list := make([]*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy, 0, len(outlierDetectionPolicyList.Items))
	for idx := range outlierDetectionPolicyList.Items {
		list = append(list, &outlierDetectionPolicyList.Items[idx])
	}
	return &outlierDetectionPolicySet{set: makeGenericOutlierDetectionPolicySet(list)}
}

func (s *outlierDetectionPolicySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *outlierDetectionPolicySet) List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy))
		})
	}

	objs := s.Generic().List(genericFilters...)
	outlierDetectionPolicyList := make([]*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy, 0, len(objs))
	for _, obj := range objs {
		outlierDetectionPolicyList = append(outlierDetectionPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy))
	}
	return outlierDetectionPolicyList
}

func (s *outlierDetectionPolicySet) UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy))
		})
	}

	var outlierDetectionPolicyList []*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		outlierDetectionPolicyList = append(outlierDetectionPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy))
	}
	return outlierDetectionPolicyList
}

func (s *outlierDetectionPolicySet) Map() map[string]*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy {
	if s == nil {
		return nil
	}

	newMap := map[string]*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy)
	}
	return newMap
}

func (s *outlierDetectionPolicySet) Insert(
	outlierDetectionPolicyList ...*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range outlierDetectionPolicyList {
		s.Generic().Insert(obj)
	}
}

func (s *outlierDetectionPolicySet) Has(outlierDetectionPolicy ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(outlierDetectionPolicy)
}

func (s *outlierDetectionPolicySet) Equal(
	outlierDetectionPolicySet OutlierDetectionPolicySet,
) bool {
	if s == nil {
		return outlierDetectionPolicySet == nil
	}
	return s.Generic().Equal(outlierDetectionPolicySet.Generic())
}

func (s *outlierDetectionPolicySet) Delete(OutlierDetectionPolicy ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(OutlierDetectionPolicy)
}

func (s *outlierDetectionPolicySet) Union(set OutlierDetectionPolicySet) OutlierDetectionPolicySet {
	if s == nil {
		return set
	}
	return NewOutlierDetectionPolicySet(append(s.List(), set.List()...)...)
}

func (s *outlierDetectionPolicySet) Difference(set OutlierDetectionPolicySet) OutlierDetectionPolicySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &outlierDetectionPolicySet{set: newSet}
}

func (s *outlierDetectionPolicySet) Intersection(set OutlierDetectionPolicySet) OutlierDetectionPolicySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var outlierDetectionPolicyList []*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy
	for _, obj := range newSet.List() {
		outlierDetectionPolicyList = append(outlierDetectionPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy))
	}
	return NewOutlierDetectionPolicySet(outlierDetectionPolicyList...)
}

func (s *outlierDetectionPolicySet) Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find OutlierDetectionPolicy %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy), nil
}

func (s *outlierDetectionPolicySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *outlierDetectionPolicySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *outlierDetectionPolicySet) Delta(newSet OutlierDetectionPolicySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *outlierDetectionPolicySet) Clone() OutlierDetectionPolicySet {
	if s == nil {
		return nil
	}
	return &outlierDetectionPolicySet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type AdaptiveRequestConcurrencyPolicySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy) bool) []*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy) bool) []*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy
	// Return the Set as a map of key to resource.
	Map() map[string]*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy
	// Insert a resource into the set.
	Insert(adaptiveRequestConcurrencyPolicy ...*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(adaptiveRequestConcurrencyPolicySet AdaptiveRequestConcurrencyPolicySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(adaptiveRequestConcurrencyPolicy ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(adaptiveRequestConcurrencyPolicy ezkube.ResourceId)
	// Return the union with the provided set
	Union(set AdaptiveRequestConcurrencyPolicySet) AdaptiveRequestConcurrencyPolicySet
	// Return the difference with the provided set
	Difference(set AdaptiveRequestConcurrencyPolicySet) AdaptiveRequestConcurrencyPolicySet
	// Return the intersection with the provided set
	Intersection(set AdaptiveRequestConcurrencyPolicySet) AdaptiveRequestConcurrencyPolicySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another AdaptiveRequestConcurrencyPolicySet
	Delta(newSet AdaptiveRequestConcurrencyPolicySet) sksets.ResourceDelta
	// Create a deep copy of the current AdaptiveRequestConcurrencyPolicySet
	Clone() AdaptiveRequestConcurrencyPolicySet
}

func makeGenericAdaptiveRequestConcurrencyPolicySet(adaptiveRequestConcurrencyPolicyList []*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range adaptiveRequestConcurrencyPolicyList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type adaptiveRequestConcurrencyPolicySet struct {
	set sksets.ResourceSet
}

func NewAdaptiveRequestConcurrencyPolicySet(adaptiveRequestConcurrencyPolicyList ...*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy) AdaptiveRequestConcurrencyPolicySet {
	return &adaptiveRequestConcurrencyPolicySet{set: makeGenericAdaptiveRequestConcurrencyPolicySet(adaptiveRequestConcurrencyPolicyList)}
}

func NewAdaptiveRequestConcurrencyPolicySetFromList(adaptiveRequestConcurrencyPolicyList *resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicyList) AdaptiveRequestConcurrencyPolicySet {
	list := make([]*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy, 0, len(adaptiveRequestConcurrencyPolicyList.Items))
	for idx := range adaptiveRequestConcurrencyPolicyList.Items {
		list = append(list, &adaptiveRequestConcurrencyPolicyList.Items[idx])
	}
	return &adaptiveRequestConcurrencyPolicySet{set: makeGenericAdaptiveRequestConcurrencyPolicySet(list)}
}

func (s *adaptiveRequestConcurrencyPolicySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *adaptiveRequestConcurrencyPolicySet) List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy) bool) []*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy))
		})
	}

	objs := s.Generic().List(genericFilters...)
	adaptiveRequestConcurrencyPolicyList := make([]*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy, 0, len(objs))
	for _, obj := range objs {
		adaptiveRequestConcurrencyPolicyList = append(adaptiveRequestConcurrencyPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy))
	}
	return adaptiveRequestConcurrencyPolicyList
}

func (s *adaptiveRequestConcurrencyPolicySet) UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy) bool) []*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy))
		})
	}

	var adaptiveRequestConcurrencyPolicyList []*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		adaptiveRequestConcurrencyPolicyList = append(adaptiveRequestConcurrencyPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy))
	}
	return adaptiveRequestConcurrencyPolicyList
}

func (s *adaptiveRequestConcurrencyPolicySet) Map() map[string]*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy {
	if s == nil {
		return nil
	}

	newMap := map[string]*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy)
	}
	return newMap
}

func (s *adaptiveRequestConcurrencyPolicySet) Insert(
	adaptiveRequestConcurrencyPolicyList ...*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range adaptiveRequestConcurrencyPolicyList {
		s.Generic().Insert(obj)
	}
}

func (s *adaptiveRequestConcurrencyPolicySet) Has(adaptiveRequestConcurrencyPolicy ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(adaptiveRequestConcurrencyPolicy)
}

func (s *adaptiveRequestConcurrencyPolicySet) Equal(
	adaptiveRequestConcurrencyPolicySet AdaptiveRequestConcurrencyPolicySet,
) bool {
	if s == nil {
		return adaptiveRequestConcurrencyPolicySet == nil
	}
	return s.Generic().Equal(adaptiveRequestConcurrencyPolicySet.Generic())
}

func (s *adaptiveRequestConcurrencyPolicySet) Delete(AdaptiveRequestConcurrencyPolicy ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(AdaptiveRequestConcurrencyPolicy)
}

func (s *adaptiveRequestConcurrencyPolicySet) Union(set AdaptiveRequestConcurrencyPolicySet) AdaptiveRequestConcurrencyPolicySet {
	if s == nil {
		return set
	}
	return NewAdaptiveRequestConcurrencyPolicySet(append(s.List(), set.List()...)...)
}

func (s *adaptiveRequestConcurrencyPolicySet) Difference(set AdaptiveRequestConcurrencyPolicySet) AdaptiveRequestConcurrencyPolicySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &adaptiveRequestConcurrencyPolicySet{set: newSet}
}

func (s *adaptiveRequestConcurrencyPolicySet) Intersection(set AdaptiveRequestConcurrencyPolicySet) AdaptiveRequestConcurrencyPolicySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var adaptiveRequestConcurrencyPolicyList []*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy
	for _, obj := range newSet.List() {
		adaptiveRequestConcurrencyPolicyList = append(adaptiveRequestConcurrencyPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy))
	}
	return NewAdaptiveRequestConcurrencyPolicySet(adaptiveRequestConcurrencyPolicyList...)
}

func (s *adaptiveRequestConcurrencyPolicySet) Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find AdaptiveRequestConcurrencyPolicy %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy), nil
}

func (s *adaptiveRequestConcurrencyPolicySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *adaptiveRequestConcurrencyPolicySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *adaptiveRequestConcurrencyPolicySet) Delta(newSet AdaptiveRequestConcurrencyPolicySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *adaptiveRequestConcurrencyPolicySet) Clone() AdaptiveRequestConcurrencyPolicySet {
	if s == nil {
		return nil
	}
	return &adaptiveRequestConcurrencyPolicySet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type FaultInjectionPolicySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy
	// Return the Set as a map of key to resource.
	Map() map[string]*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy
	// Insert a resource into the set.
	Insert(faultInjectionPolicy ...*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(faultInjectionPolicySet FaultInjectionPolicySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(faultInjectionPolicy ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(faultInjectionPolicy ezkube.ResourceId)
	// Return the union with the provided set
	Union(set FaultInjectionPolicySet) FaultInjectionPolicySet
	// Return the difference with the provided set
	Difference(set FaultInjectionPolicySet) FaultInjectionPolicySet
	// Return the intersection with the provided set
	Intersection(set FaultInjectionPolicySet) FaultInjectionPolicySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another FaultInjectionPolicySet
	Delta(newSet FaultInjectionPolicySet) sksets.ResourceDelta
	// Create a deep copy of the current FaultInjectionPolicySet
	Clone() FaultInjectionPolicySet
}

func makeGenericFaultInjectionPolicySet(faultInjectionPolicyList []*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range faultInjectionPolicyList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type faultInjectionPolicySet struct {
	set sksets.ResourceSet
}

func NewFaultInjectionPolicySet(faultInjectionPolicyList ...*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) FaultInjectionPolicySet {
	return &faultInjectionPolicySet{set: makeGenericFaultInjectionPolicySet(faultInjectionPolicyList)}
}

func NewFaultInjectionPolicySetFromList(faultInjectionPolicyList *resilience_policy_gloo_solo_io_v2.FaultInjectionPolicyList) FaultInjectionPolicySet {
	list := make([]*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy, 0, len(faultInjectionPolicyList.Items))
	for idx := range faultInjectionPolicyList.Items {
		list = append(list, &faultInjectionPolicyList.Items[idx])
	}
	return &faultInjectionPolicySet{set: makeGenericFaultInjectionPolicySet(list)}
}

func (s *faultInjectionPolicySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *faultInjectionPolicySet) List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy))
		})
	}

	objs := s.Generic().List(genericFilters...)
	faultInjectionPolicyList := make([]*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy, 0, len(objs))
	for _, obj := range objs {
		faultInjectionPolicyList = append(faultInjectionPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy))
	}
	return faultInjectionPolicyList
}

func (s *faultInjectionPolicySet) UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy))
		})
	}

	var faultInjectionPolicyList []*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		faultInjectionPolicyList = append(faultInjectionPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy))
	}
	return faultInjectionPolicyList
}

func (s *faultInjectionPolicySet) Map() map[string]*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy {
	if s == nil {
		return nil
	}

	newMap := map[string]*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy)
	}
	return newMap
}

func (s *faultInjectionPolicySet) Insert(
	faultInjectionPolicyList ...*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range faultInjectionPolicyList {
		s.Generic().Insert(obj)
	}
}

func (s *faultInjectionPolicySet) Has(faultInjectionPolicy ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(faultInjectionPolicy)
}

func (s *faultInjectionPolicySet) Equal(
	faultInjectionPolicySet FaultInjectionPolicySet,
) bool {
	if s == nil {
		return faultInjectionPolicySet == nil
	}
	return s.Generic().Equal(faultInjectionPolicySet.Generic())
}

func (s *faultInjectionPolicySet) Delete(FaultInjectionPolicy ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(FaultInjectionPolicy)
}

func (s *faultInjectionPolicySet) Union(set FaultInjectionPolicySet) FaultInjectionPolicySet {
	if s == nil {
		return set
	}
	return NewFaultInjectionPolicySet(append(s.List(), set.List()...)...)
}

func (s *faultInjectionPolicySet) Difference(set FaultInjectionPolicySet) FaultInjectionPolicySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &faultInjectionPolicySet{set: newSet}
}

func (s *faultInjectionPolicySet) Intersection(set FaultInjectionPolicySet) FaultInjectionPolicySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var faultInjectionPolicyList []*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy
	for _, obj := range newSet.List() {
		faultInjectionPolicyList = append(faultInjectionPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy))
	}
	return NewFaultInjectionPolicySet(faultInjectionPolicyList...)
}

func (s *faultInjectionPolicySet) Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find FaultInjectionPolicy %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy), nil
}

func (s *faultInjectionPolicySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *faultInjectionPolicySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *faultInjectionPolicySet) Delta(newSet FaultInjectionPolicySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *faultInjectionPolicySet) Clone() FaultInjectionPolicySet {
	if s == nil {
		return nil
	}
	return &faultInjectionPolicySet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type RetryTimeoutPolicySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) bool) []*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) bool) []*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy
	// Return the Set as a map of key to resource.
	Map() map[string]*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy
	// Insert a resource into the set.
	Insert(retryTimeoutPolicy ...*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(retryTimeoutPolicySet RetryTimeoutPolicySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(retryTimeoutPolicy ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(retryTimeoutPolicy ezkube.ResourceId)
	// Return the union with the provided set
	Union(set RetryTimeoutPolicySet) RetryTimeoutPolicySet
	// Return the difference with the provided set
	Difference(set RetryTimeoutPolicySet) RetryTimeoutPolicySet
	// Return the intersection with the provided set
	Intersection(set RetryTimeoutPolicySet) RetryTimeoutPolicySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another RetryTimeoutPolicySet
	Delta(newSet RetryTimeoutPolicySet) sksets.ResourceDelta
	// Create a deep copy of the current RetryTimeoutPolicySet
	Clone() RetryTimeoutPolicySet
}

func makeGenericRetryTimeoutPolicySet(retryTimeoutPolicyList []*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range retryTimeoutPolicyList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type retryTimeoutPolicySet struct {
	set sksets.ResourceSet
}

func NewRetryTimeoutPolicySet(retryTimeoutPolicyList ...*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) RetryTimeoutPolicySet {
	return &retryTimeoutPolicySet{set: makeGenericRetryTimeoutPolicySet(retryTimeoutPolicyList)}
}

func NewRetryTimeoutPolicySetFromList(retryTimeoutPolicyList *resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicyList) RetryTimeoutPolicySet {
	list := make([]*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy, 0, len(retryTimeoutPolicyList.Items))
	for idx := range retryTimeoutPolicyList.Items {
		list = append(list, &retryTimeoutPolicyList.Items[idx])
	}
	return &retryTimeoutPolicySet{set: makeGenericRetryTimeoutPolicySet(list)}
}

func (s *retryTimeoutPolicySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *retryTimeoutPolicySet) List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) bool) []*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy))
		})
	}

	objs := s.Generic().List(genericFilters...)
	retryTimeoutPolicyList := make([]*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy, 0, len(objs))
	for _, obj := range objs {
		retryTimeoutPolicyList = append(retryTimeoutPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy))
	}
	return retryTimeoutPolicyList
}

func (s *retryTimeoutPolicySet) UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) bool) []*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy))
		})
	}

	var retryTimeoutPolicyList []*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		retryTimeoutPolicyList = append(retryTimeoutPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy))
	}
	return retryTimeoutPolicyList
}

func (s *retryTimeoutPolicySet) Map() map[string]*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy {
	if s == nil {
		return nil
	}

	newMap := map[string]*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy)
	}
	return newMap
}

func (s *retryTimeoutPolicySet) Insert(
	retryTimeoutPolicyList ...*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range retryTimeoutPolicyList {
		s.Generic().Insert(obj)
	}
}

func (s *retryTimeoutPolicySet) Has(retryTimeoutPolicy ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(retryTimeoutPolicy)
}

func (s *retryTimeoutPolicySet) Equal(
	retryTimeoutPolicySet RetryTimeoutPolicySet,
) bool {
	if s == nil {
		return retryTimeoutPolicySet == nil
	}
	return s.Generic().Equal(retryTimeoutPolicySet.Generic())
}

func (s *retryTimeoutPolicySet) Delete(RetryTimeoutPolicy ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(RetryTimeoutPolicy)
}

func (s *retryTimeoutPolicySet) Union(set RetryTimeoutPolicySet) RetryTimeoutPolicySet {
	if s == nil {
		return set
	}
	return NewRetryTimeoutPolicySet(append(s.List(), set.List()...)...)
}

func (s *retryTimeoutPolicySet) Difference(set RetryTimeoutPolicySet) RetryTimeoutPolicySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &retryTimeoutPolicySet{set: newSet}
}

func (s *retryTimeoutPolicySet) Intersection(set RetryTimeoutPolicySet) RetryTimeoutPolicySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var retryTimeoutPolicyList []*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy
	for _, obj := range newSet.List() {
		retryTimeoutPolicyList = append(retryTimeoutPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy))
	}
	return NewRetryTimeoutPolicySet(retryTimeoutPolicyList...)
}

func (s *retryTimeoutPolicySet) Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find RetryTimeoutPolicy %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy), nil
}

func (s *retryTimeoutPolicySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *retryTimeoutPolicySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *retryTimeoutPolicySet) Delta(newSet RetryTimeoutPolicySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *retryTimeoutPolicySet) Clone() RetryTimeoutPolicySet {
	if s == nil {
		return nil
	}
	return &retryTimeoutPolicySet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type ConnectionPolicySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.ConnectionPolicy
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.ConnectionPolicy
	// Return the Set as a map of key to resource.
	Map() map[string]*resilience_policy_gloo_solo_io_v2.ConnectionPolicy
	// Insert a resource into the set.
	Insert(connectionPolicy ...*resilience_policy_gloo_solo_io_v2.ConnectionPolicy)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(connectionPolicySet ConnectionPolicySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(connectionPolicy ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(connectionPolicy ezkube.ResourceId)
	// Return the union with the provided set
	Union(set ConnectionPolicySet) ConnectionPolicySet
	// Return the difference with the provided set
	Difference(set ConnectionPolicySet) ConnectionPolicySet
	// Return the intersection with the provided set
	Intersection(set ConnectionPolicySet) ConnectionPolicySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.ConnectionPolicy, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another ConnectionPolicySet
	Delta(newSet ConnectionPolicySet) sksets.ResourceDelta
	// Create a deep copy of the current ConnectionPolicySet
	Clone() ConnectionPolicySet
}

func makeGenericConnectionPolicySet(connectionPolicyList []*resilience_policy_gloo_solo_io_v2.ConnectionPolicy) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range connectionPolicyList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type connectionPolicySet struct {
	set sksets.ResourceSet
}

func NewConnectionPolicySet(connectionPolicyList ...*resilience_policy_gloo_solo_io_v2.ConnectionPolicy) ConnectionPolicySet {
	return &connectionPolicySet{set: makeGenericConnectionPolicySet(connectionPolicyList)}
}

func NewConnectionPolicySetFromList(connectionPolicyList *resilience_policy_gloo_solo_io_v2.ConnectionPolicyList) ConnectionPolicySet {
	list := make([]*resilience_policy_gloo_solo_io_v2.ConnectionPolicy, 0, len(connectionPolicyList.Items))
	for idx := range connectionPolicyList.Items {
		list = append(list, &connectionPolicyList.Items[idx])
	}
	return &connectionPolicySet{set: makeGenericConnectionPolicySet(list)}
}

func (s *connectionPolicySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *connectionPolicySet) List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.ConnectionPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy))
		})
	}

	objs := s.Generic().List(genericFilters...)
	connectionPolicyList := make([]*resilience_policy_gloo_solo_io_v2.ConnectionPolicy, 0, len(objs))
	for _, obj := range objs {
		connectionPolicyList = append(connectionPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy))
	}
	return connectionPolicyList
}

func (s *connectionPolicySet) UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.ConnectionPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy))
		})
	}

	var connectionPolicyList []*resilience_policy_gloo_solo_io_v2.ConnectionPolicy
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		connectionPolicyList = append(connectionPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy))
	}
	return connectionPolicyList
}

func (s *connectionPolicySet) Map() map[string]*resilience_policy_gloo_solo_io_v2.ConnectionPolicy {
	if s == nil {
		return nil
	}

	newMap := map[string]*resilience_policy_gloo_solo_io_v2.ConnectionPolicy{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy)
	}
	return newMap
}

func (s *connectionPolicySet) Insert(
	connectionPolicyList ...*resilience_policy_gloo_solo_io_v2.ConnectionPolicy,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range connectionPolicyList {
		s.Generic().Insert(obj)
	}
}

func (s *connectionPolicySet) Has(connectionPolicy ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(connectionPolicy)
}

func (s *connectionPolicySet) Equal(
	connectionPolicySet ConnectionPolicySet,
) bool {
	if s == nil {
		return connectionPolicySet == nil
	}
	return s.Generic().Equal(connectionPolicySet.Generic())
}

func (s *connectionPolicySet) Delete(ConnectionPolicy ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(ConnectionPolicy)
}

func (s *connectionPolicySet) Union(set ConnectionPolicySet) ConnectionPolicySet {
	if s == nil {
		return set
	}
	return NewConnectionPolicySet(append(s.List(), set.List()...)...)
}

func (s *connectionPolicySet) Difference(set ConnectionPolicySet) ConnectionPolicySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &connectionPolicySet{set: newSet}
}

func (s *connectionPolicySet) Intersection(set ConnectionPolicySet) ConnectionPolicySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var connectionPolicyList []*resilience_policy_gloo_solo_io_v2.ConnectionPolicy
	for _, obj := range newSet.List() {
		connectionPolicyList = append(connectionPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy))
	}
	return NewConnectionPolicySet(connectionPolicyList...)
}

func (s *connectionPolicySet) Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.ConnectionPolicy, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find ConnectionPolicy %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&resilience_policy_gloo_solo_io_v2.ConnectionPolicy{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy), nil
}

func (s *connectionPolicySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *connectionPolicySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *connectionPolicySet) Delta(newSet ConnectionPolicySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *connectionPolicySet) Clone() ConnectionPolicySet {
	if s == nil {
		return nil
	}
	return &connectionPolicySet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type TrimProxyConfigPolicySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy) bool) []*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy) bool) []*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy
	// Return the Set as a map of key to resource.
	Map() map[string]*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy
	// Insert a resource into the set.
	Insert(trimProxyConfigPolicy ...*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(trimProxyConfigPolicySet TrimProxyConfigPolicySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(trimProxyConfigPolicy ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(trimProxyConfigPolicy ezkube.ResourceId)
	// Return the union with the provided set
	Union(set TrimProxyConfigPolicySet) TrimProxyConfigPolicySet
	// Return the difference with the provided set
	Difference(set TrimProxyConfigPolicySet) TrimProxyConfigPolicySet
	// Return the intersection with the provided set
	Intersection(set TrimProxyConfigPolicySet) TrimProxyConfigPolicySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another TrimProxyConfigPolicySet
	Delta(newSet TrimProxyConfigPolicySet) sksets.ResourceDelta
	// Create a deep copy of the current TrimProxyConfigPolicySet
	Clone() TrimProxyConfigPolicySet
}

func makeGenericTrimProxyConfigPolicySet(trimProxyConfigPolicyList []*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range trimProxyConfigPolicyList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type trimProxyConfigPolicySet struct {
	set sksets.ResourceSet
}

func NewTrimProxyConfigPolicySet(trimProxyConfigPolicyList ...*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy) TrimProxyConfigPolicySet {
	return &trimProxyConfigPolicySet{set: makeGenericTrimProxyConfigPolicySet(trimProxyConfigPolicyList)}
}

func NewTrimProxyConfigPolicySetFromList(trimProxyConfigPolicyList *resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicyList) TrimProxyConfigPolicySet {
	list := make([]*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy, 0, len(trimProxyConfigPolicyList.Items))
	for idx := range trimProxyConfigPolicyList.Items {
		list = append(list, &trimProxyConfigPolicyList.Items[idx])
	}
	return &trimProxyConfigPolicySet{set: makeGenericTrimProxyConfigPolicySet(list)}
}

func (s *trimProxyConfigPolicySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *trimProxyConfigPolicySet) List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy) bool) []*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy))
		})
	}

	objs := s.Generic().List(genericFilters...)
	trimProxyConfigPolicyList := make([]*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy, 0, len(objs))
	for _, obj := range objs {
		trimProxyConfigPolicyList = append(trimProxyConfigPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy))
	}
	return trimProxyConfigPolicyList
}

func (s *trimProxyConfigPolicySet) UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy) bool) []*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy))
		})
	}

	var trimProxyConfigPolicyList []*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		trimProxyConfigPolicyList = append(trimProxyConfigPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy))
	}
	return trimProxyConfigPolicyList
}

func (s *trimProxyConfigPolicySet) Map() map[string]*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy {
	if s == nil {
		return nil
	}

	newMap := map[string]*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy)
	}
	return newMap
}

func (s *trimProxyConfigPolicySet) Insert(
	trimProxyConfigPolicyList ...*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range trimProxyConfigPolicyList {
		s.Generic().Insert(obj)
	}
}

func (s *trimProxyConfigPolicySet) Has(trimProxyConfigPolicy ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(trimProxyConfigPolicy)
}

func (s *trimProxyConfigPolicySet) Equal(
	trimProxyConfigPolicySet TrimProxyConfigPolicySet,
) bool {
	if s == nil {
		return trimProxyConfigPolicySet == nil
	}
	return s.Generic().Equal(trimProxyConfigPolicySet.Generic())
}

func (s *trimProxyConfigPolicySet) Delete(TrimProxyConfigPolicy ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(TrimProxyConfigPolicy)
}

func (s *trimProxyConfigPolicySet) Union(set TrimProxyConfigPolicySet) TrimProxyConfigPolicySet {
	if s == nil {
		return set
	}
	return NewTrimProxyConfigPolicySet(append(s.List(), set.List()...)...)
}

func (s *trimProxyConfigPolicySet) Difference(set TrimProxyConfigPolicySet) TrimProxyConfigPolicySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &trimProxyConfigPolicySet{set: newSet}
}

func (s *trimProxyConfigPolicySet) Intersection(set TrimProxyConfigPolicySet) TrimProxyConfigPolicySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var trimProxyConfigPolicyList []*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy
	for _, obj := range newSet.List() {
		trimProxyConfigPolicyList = append(trimProxyConfigPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy))
	}
	return NewTrimProxyConfigPolicySet(trimProxyConfigPolicyList...)
}

func (s *trimProxyConfigPolicySet) Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find TrimProxyConfigPolicy %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy), nil
}

func (s *trimProxyConfigPolicySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *trimProxyConfigPolicySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *trimProxyConfigPolicySet) Delta(newSet TrimProxyConfigPolicySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *trimProxyConfigPolicySet) Clone() TrimProxyConfigPolicySet {
	if s == nil {
		return nil
	}
	return &trimProxyConfigPolicySet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type ActiveHealthCheckPolicySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy) bool) []*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy) bool) []*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy
	// Return the Set as a map of key to resource.
	Map() map[string]*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy
	// Insert a resource into the set.
	Insert(activeHealthCheckPolicy ...*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(activeHealthCheckPolicySet ActiveHealthCheckPolicySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(activeHealthCheckPolicy ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(activeHealthCheckPolicy ezkube.ResourceId)
	// Return the union with the provided set
	Union(set ActiveHealthCheckPolicySet) ActiveHealthCheckPolicySet
	// Return the difference with the provided set
	Difference(set ActiveHealthCheckPolicySet) ActiveHealthCheckPolicySet
	// Return the intersection with the provided set
	Intersection(set ActiveHealthCheckPolicySet) ActiveHealthCheckPolicySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another ActiveHealthCheckPolicySet
	Delta(newSet ActiveHealthCheckPolicySet) sksets.ResourceDelta
	// Create a deep copy of the current ActiveHealthCheckPolicySet
	Clone() ActiveHealthCheckPolicySet
}

func makeGenericActiveHealthCheckPolicySet(activeHealthCheckPolicyList []*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range activeHealthCheckPolicyList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type activeHealthCheckPolicySet struct {
	set sksets.ResourceSet
}

func NewActiveHealthCheckPolicySet(activeHealthCheckPolicyList ...*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy) ActiveHealthCheckPolicySet {
	return &activeHealthCheckPolicySet{set: makeGenericActiveHealthCheckPolicySet(activeHealthCheckPolicyList)}
}

func NewActiveHealthCheckPolicySetFromList(activeHealthCheckPolicyList *resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicyList) ActiveHealthCheckPolicySet {
	list := make([]*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy, 0, len(activeHealthCheckPolicyList.Items))
	for idx := range activeHealthCheckPolicyList.Items {
		list = append(list, &activeHealthCheckPolicyList.Items[idx])
	}
	return &activeHealthCheckPolicySet{set: makeGenericActiveHealthCheckPolicySet(list)}
}

func (s *activeHealthCheckPolicySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *activeHealthCheckPolicySet) List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy) bool) []*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy))
		})
	}

	objs := s.Generic().List(genericFilters...)
	activeHealthCheckPolicyList := make([]*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy, 0, len(objs))
	for _, obj := range objs {
		activeHealthCheckPolicyList = append(activeHealthCheckPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy))
	}
	return activeHealthCheckPolicyList
}

func (s *activeHealthCheckPolicySet) UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy) bool) []*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy))
		})
	}

	var activeHealthCheckPolicyList []*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		activeHealthCheckPolicyList = append(activeHealthCheckPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy))
	}
	return activeHealthCheckPolicyList
}

func (s *activeHealthCheckPolicySet) Map() map[string]*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy {
	if s == nil {
		return nil
	}

	newMap := map[string]*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy)
	}
	return newMap
}

func (s *activeHealthCheckPolicySet) Insert(
	activeHealthCheckPolicyList ...*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range activeHealthCheckPolicyList {
		s.Generic().Insert(obj)
	}
}

func (s *activeHealthCheckPolicySet) Has(activeHealthCheckPolicy ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(activeHealthCheckPolicy)
}

func (s *activeHealthCheckPolicySet) Equal(
	activeHealthCheckPolicySet ActiveHealthCheckPolicySet,
) bool {
	if s == nil {
		return activeHealthCheckPolicySet == nil
	}
	return s.Generic().Equal(activeHealthCheckPolicySet.Generic())
}

func (s *activeHealthCheckPolicySet) Delete(ActiveHealthCheckPolicy ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(ActiveHealthCheckPolicy)
}

func (s *activeHealthCheckPolicySet) Union(set ActiveHealthCheckPolicySet) ActiveHealthCheckPolicySet {
	if s == nil {
		return set
	}
	return NewActiveHealthCheckPolicySet(append(s.List(), set.List()...)...)
}

func (s *activeHealthCheckPolicySet) Difference(set ActiveHealthCheckPolicySet) ActiveHealthCheckPolicySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &activeHealthCheckPolicySet{set: newSet}
}

func (s *activeHealthCheckPolicySet) Intersection(set ActiveHealthCheckPolicySet) ActiveHealthCheckPolicySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var activeHealthCheckPolicyList []*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy
	for _, obj := range newSet.List() {
		activeHealthCheckPolicyList = append(activeHealthCheckPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy))
	}
	return NewActiveHealthCheckPolicySet(activeHealthCheckPolicyList...)
}

func (s *activeHealthCheckPolicySet) Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find ActiveHealthCheckPolicy %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy), nil
}

func (s *activeHealthCheckPolicySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *activeHealthCheckPolicySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *activeHealthCheckPolicySet) Delta(newSet ActiveHealthCheckPolicySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *activeHealthCheckPolicySet) Clone() ActiveHealthCheckPolicySet {
	if s == nil {
		return nil
	}
	return &activeHealthCheckPolicySet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type ListenerConnectionPolicySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy
	// Return the Set as a map of key to resource.
	Map() map[string]*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy
	// Insert a resource into the set.
	Insert(listenerConnectionPolicy ...*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(listenerConnectionPolicySet ListenerConnectionPolicySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(listenerConnectionPolicy ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(listenerConnectionPolicy ezkube.ResourceId)
	// Return the union with the provided set
	Union(set ListenerConnectionPolicySet) ListenerConnectionPolicySet
	// Return the difference with the provided set
	Difference(set ListenerConnectionPolicySet) ListenerConnectionPolicySet
	// Return the intersection with the provided set
	Intersection(set ListenerConnectionPolicySet) ListenerConnectionPolicySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another ListenerConnectionPolicySet
	Delta(newSet ListenerConnectionPolicySet) sksets.ResourceDelta
	// Create a deep copy of the current ListenerConnectionPolicySet
	Clone() ListenerConnectionPolicySet
}

func makeGenericListenerConnectionPolicySet(listenerConnectionPolicyList []*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range listenerConnectionPolicyList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type listenerConnectionPolicySet struct {
	set sksets.ResourceSet
}

func NewListenerConnectionPolicySet(listenerConnectionPolicyList ...*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy) ListenerConnectionPolicySet {
	return &listenerConnectionPolicySet{set: makeGenericListenerConnectionPolicySet(listenerConnectionPolicyList)}
}

func NewListenerConnectionPolicySetFromList(listenerConnectionPolicyList *resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicyList) ListenerConnectionPolicySet {
	list := make([]*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy, 0, len(listenerConnectionPolicyList.Items))
	for idx := range listenerConnectionPolicyList.Items {
		list = append(list, &listenerConnectionPolicyList.Items[idx])
	}
	return &listenerConnectionPolicySet{set: makeGenericListenerConnectionPolicySet(list)}
}

func (s *listenerConnectionPolicySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *listenerConnectionPolicySet) List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy))
		})
	}

	objs := s.Generic().List(genericFilters...)
	listenerConnectionPolicyList := make([]*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy, 0, len(objs))
	for _, obj := range objs {
		listenerConnectionPolicyList = append(listenerConnectionPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy))
	}
	return listenerConnectionPolicyList
}

func (s *listenerConnectionPolicySet) UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy))
		})
	}

	var listenerConnectionPolicyList []*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		listenerConnectionPolicyList = append(listenerConnectionPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy))
	}
	return listenerConnectionPolicyList
}

func (s *listenerConnectionPolicySet) Map() map[string]*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy {
	if s == nil {
		return nil
	}

	newMap := map[string]*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy)
	}
	return newMap
}

func (s *listenerConnectionPolicySet) Insert(
	listenerConnectionPolicyList ...*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range listenerConnectionPolicyList {
		s.Generic().Insert(obj)
	}
}

func (s *listenerConnectionPolicySet) Has(listenerConnectionPolicy ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(listenerConnectionPolicy)
}

func (s *listenerConnectionPolicySet) Equal(
	listenerConnectionPolicySet ListenerConnectionPolicySet,
) bool {
	if s == nil {
		return listenerConnectionPolicySet == nil
	}
	return s.Generic().Equal(listenerConnectionPolicySet.Generic())
}

func (s *listenerConnectionPolicySet) Delete(ListenerConnectionPolicy ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(ListenerConnectionPolicy)
}

func (s *listenerConnectionPolicySet) Union(set ListenerConnectionPolicySet) ListenerConnectionPolicySet {
	if s == nil {
		return set
	}
	return NewListenerConnectionPolicySet(append(s.List(), set.List()...)...)
}

func (s *listenerConnectionPolicySet) Difference(set ListenerConnectionPolicySet) ListenerConnectionPolicySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &listenerConnectionPolicySet{set: newSet}
}

func (s *listenerConnectionPolicySet) Intersection(set ListenerConnectionPolicySet) ListenerConnectionPolicySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var listenerConnectionPolicyList []*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy
	for _, obj := range newSet.List() {
		listenerConnectionPolicyList = append(listenerConnectionPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy))
	}
	return NewListenerConnectionPolicySet(listenerConnectionPolicyList...)
}

func (s *listenerConnectionPolicySet) Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find ListenerConnectionPolicy %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy), nil
}

func (s *listenerConnectionPolicySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *listenerConnectionPolicySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *listenerConnectionPolicySet) Delta(newSet ListenerConnectionPolicySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *listenerConnectionPolicySet) Clone() ListenerConnectionPolicySet {
	if s == nil {
		return nil
	}
	return &listenerConnectionPolicySet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}
