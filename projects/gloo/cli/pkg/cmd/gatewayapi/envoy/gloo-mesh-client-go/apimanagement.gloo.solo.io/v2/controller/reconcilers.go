// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./reconcilers.go -destination mocks/reconcilers.go

// Definitions for the Kubernetes Controllers
package controller

import (
	"context"

	apimanagement_gloo_solo_io_v2 "github.com/solo-io/gloo/projects/gloo/cli/pkg/cmd/gatewayapi/envoy/gloo-mesh-client-go/apimanagement.gloo.solo.io/v2"

	"github.com/pkg/errors"
	"github.com/solo-io/skv2/pkg/ezkube"
	"github.com/solo-io/skv2/pkg/reconcile"
	"sigs.k8s.io/controller-runtime/pkg/manager"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
)

// Reconcile Upsert events for the GraphQLStitchedSchema Resource.
// implemented by the user
type GraphQLStitchedSchemaReconciler interface {
	ReconcileGraphQLStitchedSchema(obj *apimanagement_gloo_solo_io_v2.GraphQLStitchedSchema) (reconcile.Result, error)
}

// Reconcile deletion events for the GraphQLStitchedSchema Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type GraphQLStitchedSchemaDeletionReconciler interface {
	ReconcileGraphQLStitchedSchemaDeletion(req reconcile.Request) error
}

type GraphQLStitchedSchemaReconcilerFuncs struct {
	OnReconcileGraphQLStitchedSchema         func(obj *apimanagement_gloo_solo_io_v2.GraphQLStitchedSchema) (reconcile.Result, error)
	OnReconcileGraphQLStitchedSchemaDeletion func(req reconcile.Request) error
}

func (f *GraphQLStitchedSchemaReconcilerFuncs) ReconcileGraphQLStitchedSchema(obj *apimanagement_gloo_solo_io_v2.GraphQLStitchedSchema) (reconcile.Result, error) {
	if f.OnReconcileGraphQLStitchedSchema == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileGraphQLStitchedSchema(obj)
}

func (f *GraphQLStitchedSchemaReconcilerFuncs) ReconcileGraphQLStitchedSchemaDeletion(req reconcile.Request) error {
	if f.OnReconcileGraphQLStitchedSchemaDeletion == nil {
		return nil
	}
	return f.OnReconcileGraphQLStitchedSchemaDeletion(req)
}

// Reconcile and finalize the GraphQLStitchedSchema Resource
// implemented by the user
type GraphQLStitchedSchemaFinalizer interface {
	GraphQLStitchedSchemaReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	GraphQLStitchedSchemaFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeGraphQLStitchedSchema(obj *apimanagement_gloo_solo_io_v2.GraphQLStitchedSchema) error
}

type GraphQLStitchedSchemaReconcileLoop interface {
	RunGraphQLStitchedSchemaReconciler(ctx context.Context, rec GraphQLStitchedSchemaReconciler, predicates ...predicate.Predicate) error
}

type graphQLStitchedSchemaReconcileLoop struct {
	loop reconcile.Loop
}

func NewGraphQLStitchedSchemaReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) GraphQLStitchedSchemaReconcileLoop {
	return &graphQLStitchedSchemaReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &apimanagement_gloo_solo_io_v2.GraphQLStitchedSchema{}, options),
	}
}

func (c *graphQLStitchedSchemaReconcileLoop) RunGraphQLStitchedSchemaReconciler(ctx context.Context, reconciler GraphQLStitchedSchemaReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericGraphQLStitchedSchemaReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(GraphQLStitchedSchemaFinalizer); ok {
		reconcilerWrapper = genericGraphQLStitchedSchemaFinalizer{
			genericGraphQLStitchedSchemaReconciler: genericReconciler,
			finalizingReconciler:                   finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericGraphQLStitchedSchemaHandler implements a generic reconcile.Reconciler
type genericGraphQLStitchedSchemaReconciler struct {
	reconciler GraphQLStitchedSchemaReconciler
}

func (r genericGraphQLStitchedSchemaReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.GraphQLStitchedSchema)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: GraphQLStitchedSchema handler received event for %T", object)
	}
	return r.reconciler.ReconcileGraphQLStitchedSchema(obj)
}

func (r genericGraphQLStitchedSchemaReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(GraphQLStitchedSchemaDeletionReconciler); ok {
		return deletionReconciler.ReconcileGraphQLStitchedSchemaDeletion(request)
	}
	return nil
}

// genericGraphQLStitchedSchemaFinalizer implements a generic reconcile.FinalizingReconciler
type genericGraphQLStitchedSchemaFinalizer struct {
	genericGraphQLStitchedSchemaReconciler
	finalizingReconciler GraphQLStitchedSchemaFinalizer
}

func (r genericGraphQLStitchedSchemaFinalizer) FinalizerName() string {
	return r.finalizingReconciler.GraphQLStitchedSchemaFinalizerName()
}

func (r genericGraphQLStitchedSchemaFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.GraphQLStitchedSchema)
	if !ok {
		return errors.Errorf("internal error: GraphQLStitchedSchema handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeGraphQLStitchedSchema(obj)
}

// Reconcile Upsert events for the GraphQLResolverMap Resource.
// implemented by the user
type GraphQLResolverMapReconciler interface {
	ReconcileGraphQLResolverMap(obj *apimanagement_gloo_solo_io_v2.GraphQLResolverMap) (reconcile.Result, error)
}

// Reconcile deletion events for the GraphQLResolverMap Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type GraphQLResolverMapDeletionReconciler interface {
	ReconcileGraphQLResolverMapDeletion(req reconcile.Request) error
}

type GraphQLResolverMapReconcilerFuncs struct {
	OnReconcileGraphQLResolverMap         func(obj *apimanagement_gloo_solo_io_v2.GraphQLResolverMap) (reconcile.Result, error)
	OnReconcileGraphQLResolverMapDeletion func(req reconcile.Request) error
}

func (f *GraphQLResolverMapReconcilerFuncs) ReconcileGraphQLResolverMap(obj *apimanagement_gloo_solo_io_v2.GraphQLResolverMap) (reconcile.Result, error) {
	if f.OnReconcileGraphQLResolverMap == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileGraphQLResolverMap(obj)
}

func (f *GraphQLResolverMapReconcilerFuncs) ReconcileGraphQLResolverMapDeletion(req reconcile.Request) error {
	if f.OnReconcileGraphQLResolverMapDeletion == nil {
		return nil
	}
	return f.OnReconcileGraphQLResolverMapDeletion(req)
}

// Reconcile and finalize the GraphQLResolverMap Resource
// implemented by the user
type GraphQLResolverMapFinalizer interface {
	GraphQLResolverMapReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	GraphQLResolverMapFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeGraphQLResolverMap(obj *apimanagement_gloo_solo_io_v2.GraphQLResolverMap) error
}

type GraphQLResolverMapReconcileLoop interface {
	RunGraphQLResolverMapReconciler(ctx context.Context, rec GraphQLResolverMapReconciler, predicates ...predicate.Predicate) error
}

type graphQLResolverMapReconcileLoop struct {
	loop reconcile.Loop
}

func NewGraphQLResolverMapReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) GraphQLResolverMapReconcileLoop {
	return &graphQLResolverMapReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &apimanagement_gloo_solo_io_v2.GraphQLResolverMap{}, options),
	}
}

func (c *graphQLResolverMapReconcileLoop) RunGraphQLResolverMapReconciler(ctx context.Context, reconciler GraphQLResolverMapReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericGraphQLResolverMapReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(GraphQLResolverMapFinalizer); ok {
		reconcilerWrapper = genericGraphQLResolverMapFinalizer{
			genericGraphQLResolverMapReconciler: genericReconciler,
			finalizingReconciler:                finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericGraphQLResolverMapHandler implements a generic reconcile.Reconciler
type genericGraphQLResolverMapReconciler struct {
	reconciler GraphQLResolverMapReconciler
}

func (r genericGraphQLResolverMapReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.GraphQLResolverMap)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: GraphQLResolverMap handler received event for %T", object)
	}
	return r.reconciler.ReconcileGraphQLResolverMap(obj)
}

func (r genericGraphQLResolverMapReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(GraphQLResolverMapDeletionReconciler); ok {
		return deletionReconciler.ReconcileGraphQLResolverMapDeletion(request)
	}
	return nil
}

// genericGraphQLResolverMapFinalizer implements a generic reconcile.FinalizingReconciler
type genericGraphQLResolverMapFinalizer struct {
	genericGraphQLResolverMapReconciler
	finalizingReconciler GraphQLResolverMapFinalizer
}

func (r genericGraphQLResolverMapFinalizer) FinalizerName() string {
	return r.finalizingReconciler.GraphQLResolverMapFinalizerName()
}

func (r genericGraphQLResolverMapFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.GraphQLResolverMap)
	if !ok {
		return errors.Errorf("internal error: GraphQLResolverMap handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeGraphQLResolverMap(obj)
}

// Reconcile Upsert events for the GraphQLSchema Resource.
// implemented by the user
type GraphQLSchemaReconciler interface {
	ReconcileGraphQLSchema(obj *apimanagement_gloo_solo_io_v2.GraphQLSchema) (reconcile.Result, error)
}

// Reconcile deletion events for the GraphQLSchema Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type GraphQLSchemaDeletionReconciler interface {
	ReconcileGraphQLSchemaDeletion(req reconcile.Request) error
}

type GraphQLSchemaReconcilerFuncs struct {
	OnReconcileGraphQLSchema         func(obj *apimanagement_gloo_solo_io_v2.GraphQLSchema) (reconcile.Result, error)
	OnReconcileGraphQLSchemaDeletion func(req reconcile.Request) error
}

func (f *GraphQLSchemaReconcilerFuncs) ReconcileGraphQLSchema(obj *apimanagement_gloo_solo_io_v2.GraphQLSchema) (reconcile.Result, error) {
	if f.OnReconcileGraphQLSchema == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileGraphQLSchema(obj)
}

func (f *GraphQLSchemaReconcilerFuncs) ReconcileGraphQLSchemaDeletion(req reconcile.Request) error {
	if f.OnReconcileGraphQLSchemaDeletion == nil {
		return nil
	}
	return f.OnReconcileGraphQLSchemaDeletion(req)
}

// Reconcile and finalize the GraphQLSchema Resource
// implemented by the user
type GraphQLSchemaFinalizer interface {
	GraphQLSchemaReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	GraphQLSchemaFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeGraphQLSchema(obj *apimanagement_gloo_solo_io_v2.GraphQLSchema) error
}

type GraphQLSchemaReconcileLoop interface {
	RunGraphQLSchemaReconciler(ctx context.Context, rec GraphQLSchemaReconciler, predicates ...predicate.Predicate) error
}

type graphQLSchemaReconcileLoop struct {
	loop reconcile.Loop
}

func NewGraphQLSchemaReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) GraphQLSchemaReconcileLoop {
	return &graphQLSchemaReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &apimanagement_gloo_solo_io_v2.GraphQLSchema{}, options),
	}
}

func (c *graphQLSchemaReconcileLoop) RunGraphQLSchemaReconciler(ctx context.Context, reconciler GraphQLSchemaReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericGraphQLSchemaReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(GraphQLSchemaFinalizer); ok {
		reconcilerWrapper = genericGraphQLSchemaFinalizer{
			genericGraphQLSchemaReconciler: genericReconciler,
			finalizingReconciler:           finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericGraphQLSchemaHandler implements a generic reconcile.Reconciler
type genericGraphQLSchemaReconciler struct {
	reconciler GraphQLSchemaReconciler
}

func (r genericGraphQLSchemaReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.GraphQLSchema)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: GraphQLSchema handler received event for %T", object)
	}
	return r.reconciler.ReconcileGraphQLSchema(obj)
}

func (r genericGraphQLSchemaReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(GraphQLSchemaDeletionReconciler); ok {
		return deletionReconciler.ReconcileGraphQLSchemaDeletion(request)
	}
	return nil
}

// genericGraphQLSchemaFinalizer implements a generic reconcile.FinalizingReconciler
type genericGraphQLSchemaFinalizer struct {
	genericGraphQLSchemaReconciler
	finalizingReconciler GraphQLSchemaFinalizer
}

func (r genericGraphQLSchemaFinalizer) FinalizerName() string {
	return r.finalizingReconciler.GraphQLSchemaFinalizerName()
}

func (r genericGraphQLSchemaFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.GraphQLSchema)
	if !ok {
		return errors.Errorf("internal error: GraphQLSchema handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeGraphQLSchema(obj)
}

// Reconcile Upsert events for the ApiDoc Resource.
// implemented by the user
type ApiDocReconciler interface {
	ReconcileApiDoc(obj *apimanagement_gloo_solo_io_v2.ApiDoc) (reconcile.Result, error)
}

// Reconcile deletion events for the ApiDoc Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type ApiDocDeletionReconciler interface {
	ReconcileApiDocDeletion(req reconcile.Request) error
}

type ApiDocReconcilerFuncs struct {
	OnReconcileApiDoc         func(obj *apimanagement_gloo_solo_io_v2.ApiDoc) (reconcile.Result, error)
	OnReconcileApiDocDeletion func(req reconcile.Request) error
}

func (f *ApiDocReconcilerFuncs) ReconcileApiDoc(obj *apimanagement_gloo_solo_io_v2.ApiDoc) (reconcile.Result, error) {
	if f.OnReconcileApiDoc == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileApiDoc(obj)
}

func (f *ApiDocReconcilerFuncs) ReconcileApiDocDeletion(req reconcile.Request) error {
	if f.OnReconcileApiDocDeletion == nil {
		return nil
	}
	return f.OnReconcileApiDocDeletion(req)
}

// Reconcile and finalize the ApiDoc Resource
// implemented by the user
type ApiDocFinalizer interface {
	ApiDocReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	ApiDocFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeApiDoc(obj *apimanagement_gloo_solo_io_v2.ApiDoc) error
}

type ApiDocReconcileLoop interface {
	RunApiDocReconciler(ctx context.Context, rec ApiDocReconciler, predicates ...predicate.Predicate) error
}

type apiDocReconcileLoop struct {
	loop reconcile.Loop
}

func NewApiDocReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) ApiDocReconcileLoop {
	return &apiDocReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &apimanagement_gloo_solo_io_v2.ApiDoc{}, options),
	}
}

func (c *apiDocReconcileLoop) RunApiDocReconciler(ctx context.Context, reconciler ApiDocReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericApiDocReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(ApiDocFinalizer); ok {
		reconcilerWrapper = genericApiDocFinalizer{
			genericApiDocReconciler: genericReconciler,
			finalizingReconciler:    finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericApiDocHandler implements a generic reconcile.Reconciler
type genericApiDocReconciler struct {
	reconciler ApiDocReconciler
}

func (r genericApiDocReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.ApiDoc)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: ApiDoc handler received event for %T", object)
	}
	return r.reconciler.ReconcileApiDoc(obj)
}

func (r genericApiDocReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(ApiDocDeletionReconciler); ok {
		return deletionReconciler.ReconcileApiDocDeletion(request)
	}
	return nil
}

// genericApiDocFinalizer implements a generic reconcile.FinalizingReconciler
type genericApiDocFinalizer struct {
	genericApiDocReconciler
	finalizingReconciler ApiDocFinalizer
}

func (r genericApiDocFinalizer) FinalizerName() string {
	return r.finalizingReconciler.ApiDocFinalizerName()
}

func (r genericApiDocFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.ApiDoc)
	if !ok {
		return errors.Errorf("internal error: ApiDoc handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeApiDoc(obj)
}

// Reconcile Upsert events for the Portal Resource.
// implemented by the user
type PortalReconciler interface {
	ReconcilePortal(obj *apimanagement_gloo_solo_io_v2.Portal) (reconcile.Result, error)
}

// Reconcile deletion events for the Portal Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type PortalDeletionReconciler interface {
	ReconcilePortalDeletion(req reconcile.Request) error
}

type PortalReconcilerFuncs struct {
	OnReconcilePortal         func(obj *apimanagement_gloo_solo_io_v2.Portal) (reconcile.Result, error)
	OnReconcilePortalDeletion func(req reconcile.Request) error
}

func (f *PortalReconcilerFuncs) ReconcilePortal(obj *apimanagement_gloo_solo_io_v2.Portal) (reconcile.Result, error) {
	if f.OnReconcilePortal == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcilePortal(obj)
}

func (f *PortalReconcilerFuncs) ReconcilePortalDeletion(req reconcile.Request) error {
	if f.OnReconcilePortalDeletion == nil {
		return nil
	}
	return f.OnReconcilePortalDeletion(req)
}

// Reconcile and finalize the Portal Resource
// implemented by the user
type PortalFinalizer interface {
	PortalReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	PortalFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizePortal(obj *apimanagement_gloo_solo_io_v2.Portal) error
}

type PortalReconcileLoop interface {
	RunPortalReconciler(ctx context.Context, rec PortalReconciler, predicates ...predicate.Predicate) error
}

type portalReconcileLoop struct {
	loop reconcile.Loop
}

func NewPortalReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) PortalReconcileLoop {
	return &portalReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &apimanagement_gloo_solo_io_v2.Portal{}, options),
	}
}

func (c *portalReconcileLoop) RunPortalReconciler(ctx context.Context, reconciler PortalReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericPortalReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(PortalFinalizer); ok {
		reconcilerWrapper = genericPortalFinalizer{
			genericPortalReconciler: genericReconciler,
			finalizingReconciler:    finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericPortalHandler implements a generic reconcile.Reconciler
type genericPortalReconciler struct {
	reconciler PortalReconciler
}

func (r genericPortalReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.Portal)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: Portal handler received event for %T", object)
	}
	return r.reconciler.ReconcilePortal(obj)
}

func (r genericPortalReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(PortalDeletionReconciler); ok {
		return deletionReconciler.ReconcilePortalDeletion(request)
	}
	return nil
}

// genericPortalFinalizer implements a generic reconcile.FinalizingReconciler
type genericPortalFinalizer struct {
	genericPortalReconciler
	finalizingReconciler PortalFinalizer
}

func (r genericPortalFinalizer) FinalizerName() string {
	return r.finalizingReconciler.PortalFinalizerName()
}

func (r genericPortalFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.Portal)
	if !ok {
		return errors.Errorf("internal error: Portal handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizePortal(obj)
}

// Reconcile Upsert events for the ApiProduct Resource.
// implemented by the user
type ApiProductReconciler interface {
	ReconcileApiProduct(obj *apimanagement_gloo_solo_io_v2.ApiProduct) (reconcile.Result, error)
}

// Reconcile deletion events for the ApiProduct Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type ApiProductDeletionReconciler interface {
	ReconcileApiProductDeletion(req reconcile.Request) error
}

type ApiProductReconcilerFuncs struct {
	OnReconcileApiProduct         func(obj *apimanagement_gloo_solo_io_v2.ApiProduct) (reconcile.Result, error)
	OnReconcileApiProductDeletion func(req reconcile.Request) error
}

func (f *ApiProductReconcilerFuncs) ReconcileApiProduct(obj *apimanagement_gloo_solo_io_v2.ApiProduct) (reconcile.Result, error) {
	if f.OnReconcileApiProduct == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileApiProduct(obj)
}

func (f *ApiProductReconcilerFuncs) ReconcileApiProductDeletion(req reconcile.Request) error {
	if f.OnReconcileApiProductDeletion == nil {
		return nil
	}
	return f.OnReconcileApiProductDeletion(req)
}

// Reconcile and finalize the ApiProduct Resource
// implemented by the user
type ApiProductFinalizer interface {
	ApiProductReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	ApiProductFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeApiProduct(obj *apimanagement_gloo_solo_io_v2.ApiProduct) error
}

type ApiProductReconcileLoop interface {
	RunApiProductReconciler(ctx context.Context, rec ApiProductReconciler, predicates ...predicate.Predicate) error
}

type apiProductReconcileLoop struct {
	loop reconcile.Loop
}

func NewApiProductReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) ApiProductReconcileLoop {
	return &apiProductReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &apimanagement_gloo_solo_io_v2.ApiProduct{}, options),
	}
}

func (c *apiProductReconcileLoop) RunApiProductReconciler(ctx context.Context, reconciler ApiProductReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericApiProductReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(ApiProductFinalizer); ok {
		reconcilerWrapper = genericApiProductFinalizer{
			genericApiProductReconciler: genericReconciler,
			finalizingReconciler:        finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericApiProductHandler implements a generic reconcile.Reconciler
type genericApiProductReconciler struct {
	reconciler ApiProductReconciler
}

func (r genericApiProductReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.ApiProduct)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: ApiProduct handler received event for %T", object)
	}
	return r.reconciler.ReconcileApiProduct(obj)
}

func (r genericApiProductReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(ApiProductDeletionReconciler); ok {
		return deletionReconciler.ReconcileApiProductDeletion(request)
	}
	return nil
}

// genericApiProductFinalizer implements a generic reconcile.FinalizingReconciler
type genericApiProductFinalizer struct {
	genericApiProductReconciler
	finalizingReconciler ApiProductFinalizer
}

func (r genericApiProductFinalizer) FinalizerName() string {
	return r.finalizingReconciler.ApiProductFinalizerName()
}

func (r genericApiProductFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.ApiProduct)
	if !ok {
		return errors.Errorf("internal error: ApiProduct handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeApiProduct(obj)
}

// Reconcile Upsert events for the PortalGroup Resource.
// implemented by the user
type PortalGroupReconciler interface {
	ReconcilePortalGroup(obj *apimanagement_gloo_solo_io_v2.PortalGroup) (reconcile.Result, error)
}

// Reconcile deletion events for the PortalGroup Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type PortalGroupDeletionReconciler interface {
	ReconcilePortalGroupDeletion(req reconcile.Request) error
}

type PortalGroupReconcilerFuncs struct {
	OnReconcilePortalGroup         func(obj *apimanagement_gloo_solo_io_v2.PortalGroup) (reconcile.Result, error)
	OnReconcilePortalGroupDeletion func(req reconcile.Request) error
}

func (f *PortalGroupReconcilerFuncs) ReconcilePortalGroup(obj *apimanagement_gloo_solo_io_v2.PortalGroup) (reconcile.Result, error) {
	if f.OnReconcilePortalGroup == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcilePortalGroup(obj)
}

func (f *PortalGroupReconcilerFuncs) ReconcilePortalGroupDeletion(req reconcile.Request) error {
	if f.OnReconcilePortalGroupDeletion == nil {
		return nil
	}
	return f.OnReconcilePortalGroupDeletion(req)
}

// Reconcile and finalize the PortalGroup Resource
// implemented by the user
type PortalGroupFinalizer interface {
	PortalGroupReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	PortalGroupFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizePortalGroup(obj *apimanagement_gloo_solo_io_v2.PortalGroup) error
}

type PortalGroupReconcileLoop interface {
	RunPortalGroupReconciler(ctx context.Context, rec PortalGroupReconciler, predicates ...predicate.Predicate) error
}

type portalGroupReconcileLoop struct {
	loop reconcile.Loop
}

func NewPortalGroupReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) PortalGroupReconcileLoop {
	return &portalGroupReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &apimanagement_gloo_solo_io_v2.PortalGroup{}, options),
	}
}

func (c *portalGroupReconcileLoop) RunPortalGroupReconciler(ctx context.Context, reconciler PortalGroupReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericPortalGroupReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(PortalGroupFinalizer); ok {
		reconcilerWrapper = genericPortalGroupFinalizer{
			genericPortalGroupReconciler: genericReconciler,
			finalizingReconciler:         finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericPortalGroupHandler implements a generic reconcile.Reconciler
type genericPortalGroupReconciler struct {
	reconciler PortalGroupReconciler
}

func (r genericPortalGroupReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.PortalGroup)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: PortalGroup handler received event for %T", object)
	}
	return r.reconciler.ReconcilePortalGroup(obj)
}

func (r genericPortalGroupReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(PortalGroupDeletionReconciler); ok {
		return deletionReconciler.ReconcilePortalGroupDeletion(request)
	}
	return nil
}

// genericPortalGroupFinalizer implements a generic reconcile.FinalizingReconciler
type genericPortalGroupFinalizer struct {
	genericPortalGroupReconciler
	finalizingReconciler PortalGroupFinalizer
}

func (r genericPortalGroupFinalizer) FinalizerName() string {
	return r.finalizingReconciler.PortalGroupFinalizerName()
}

func (r genericPortalGroupFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.PortalGroup)
	if !ok {
		return errors.Errorf("internal error: PortalGroup handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizePortalGroup(obj)
}

// Reconcile Upsert events for the ApiSchemaDiscovery Resource.
// implemented by the user
type ApiSchemaDiscoveryReconciler interface {
	ReconcileApiSchemaDiscovery(obj *apimanagement_gloo_solo_io_v2.ApiSchemaDiscovery) (reconcile.Result, error)
}

// Reconcile deletion events for the ApiSchemaDiscovery Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type ApiSchemaDiscoveryDeletionReconciler interface {
	ReconcileApiSchemaDiscoveryDeletion(req reconcile.Request) error
}

type ApiSchemaDiscoveryReconcilerFuncs struct {
	OnReconcileApiSchemaDiscovery         func(obj *apimanagement_gloo_solo_io_v2.ApiSchemaDiscovery) (reconcile.Result, error)
	OnReconcileApiSchemaDiscoveryDeletion func(req reconcile.Request) error
}

func (f *ApiSchemaDiscoveryReconcilerFuncs) ReconcileApiSchemaDiscovery(obj *apimanagement_gloo_solo_io_v2.ApiSchemaDiscovery) (reconcile.Result, error) {
	if f.OnReconcileApiSchemaDiscovery == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileApiSchemaDiscovery(obj)
}

func (f *ApiSchemaDiscoveryReconcilerFuncs) ReconcileApiSchemaDiscoveryDeletion(req reconcile.Request) error {
	if f.OnReconcileApiSchemaDiscoveryDeletion == nil {
		return nil
	}
	return f.OnReconcileApiSchemaDiscoveryDeletion(req)
}

// Reconcile and finalize the ApiSchemaDiscovery Resource
// implemented by the user
type ApiSchemaDiscoveryFinalizer interface {
	ApiSchemaDiscoveryReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	ApiSchemaDiscoveryFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeApiSchemaDiscovery(obj *apimanagement_gloo_solo_io_v2.ApiSchemaDiscovery) error
}

type ApiSchemaDiscoveryReconcileLoop interface {
	RunApiSchemaDiscoveryReconciler(ctx context.Context, rec ApiSchemaDiscoveryReconciler, predicates ...predicate.Predicate) error
}

type apiSchemaDiscoveryReconcileLoop struct {
	loop reconcile.Loop
}

func NewApiSchemaDiscoveryReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) ApiSchemaDiscoveryReconcileLoop {
	return &apiSchemaDiscoveryReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &apimanagement_gloo_solo_io_v2.ApiSchemaDiscovery{}, options),
	}
}

func (c *apiSchemaDiscoveryReconcileLoop) RunApiSchemaDiscoveryReconciler(ctx context.Context, reconciler ApiSchemaDiscoveryReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericApiSchemaDiscoveryReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(ApiSchemaDiscoveryFinalizer); ok {
		reconcilerWrapper = genericApiSchemaDiscoveryFinalizer{
			genericApiSchemaDiscoveryReconciler: genericReconciler,
			finalizingReconciler:                finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericApiSchemaDiscoveryHandler implements a generic reconcile.Reconciler
type genericApiSchemaDiscoveryReconciler struct {
	reconciler ApiSchemaDiscoveryReconciler
}

func (r genericApiSchemaDiscoveryReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.ApiSchemaDiscovery)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: ApiSchemaDiscovery handler received event for %T", object)
	}
	return r.reconciler.ReconcileApiSchemaDiscovery(obj)
}

func (r genericApiSchemaDiscoveryReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(ApiSchemaDiscoveryDeletionReconciler); ok {
		return deletionReconciler.ReconcileApiSchemaDiscoveryDeletion(request)
	}
	return nil
}

// genericApiSchemaDiscoveryFinalizer implements a generic reconcile.FinalizingReconciler
type genericApiSchemaDiscoveryFinalizer struct {
	genericApiSchemaDiscoveryReconciler
	finalizingReconciler ApiSchemaDiscoveryFinalizer
}

func (r genericApiSchemaDiscoveryFinalizer) FinalizerName() string {
	return r.finalizingReconciler.ApiSchemaDiscoveryFinalizerName()
}

func (r genericApiSchemaDiscoveryFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.ApiSchemaDiscovery)
	if !ok {
		return errors.Errorf("internal error: ApiSchemaDiscovery handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeApiSchemaDiscovery(obj)
}
