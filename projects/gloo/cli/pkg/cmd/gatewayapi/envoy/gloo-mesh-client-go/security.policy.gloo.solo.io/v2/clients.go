// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./clients.go -destination mocks/clients.go

package v2

import (
	"context"

	"github.com/solo-io/skv2/pkg/controllerutils"
	"github.com/solo-io/skv2/pkg/multicluster"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// MulticlusterClientset for the security.policy.gloo.solo.io/v2 APIs
type MulticlusterClientset interface {
	// Cluster returns a Clientset for the given cluster
	Cluster(cluster string) (Clientset, error)
}

type multiclusterClientset struct {
	client multicluster.Client
}

func NewMulticlusterClientset(client multicluster.Client) MulticlusterClientset {
	return &multiclusterClientset{client: client}
}

func (m *multiclusterClientset) Cluster(cluster string) (Clientset, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewClientset(client), nil
}

// clienset for the security.policy.gloo.solo.io/v2 APIs
type Clientset interface {
	// clienset for the security.policy.gloo.solo.io/v2/v2 APIs
	AccessPolicies() AccessPolicyClient
	// clienset for the security.policy.gloo.solo.io/v2/v2 APIs
	CORSPolicies() CORSPolicyClient
	// clienset for the security.policy.gloo.solo.io/v2/v2 APIs
	CSRFPolicies() CSRFPolicyClient
	// clienset for the security.policy.gloo.solo.io/v2/v2 APIs
	ExtAuthPolicies() ExtAuthPolicyClient
	// clienset for the security.policy.gloo.solo.io/v2/v2 APIs
	WAFPolicies() WAFPolicyClient
	// clienset for the security.policy.gloo.solo.io/v2/v2 APIs
	JWTPolicies() JWTPolicyClient
	// clienset for the security.policy.gloo.solo.io/v2/v2 APIs
	ClientTLSPolicies() ClientTLSPolicyClient
	// clienset for the security.policy.gloo.solo.io/v2/v2 APIs
	GraphQLAllowedQueryPolicies() GraphQLAllowedQueryPolicyClient
	// clienset for the security.policy.gloo.solo.io/v2/v2 APIs
	DLPPolicies() DLPPolicyClient
}

type clientSet struct {
	client client.Client
}

func NewClientsetFromConfig(cfg *rest.Config) (Clientset, error) {
	scheme := scheme.Scheme
	if err := SchemeBuilder.AddToScheme(scheme); err != nil {
		return nil, err
	}
	client, err := client.New(cfg, client.Options{
		Scheme: scheme,
	})
	if err != nil {
		return nil, err
	}
	return NewClientset(client), nil
}

func NewClientset(client client.Client) Clientset {
	return &clientSet{client: client}
}

// clienset for the security.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) AccessPolicies() AccessPolicyClient {
	return NewAccessPolicyClient(c.client)
}

// clienset for the security.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) CORSPolicies() CORSPolicyClient {
	return NewCORSPolicyClient(c.client)
}

// clienset for the security.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) CSRFPolicies() CSRFPolicyClient {
	return NewCSRFPolicyClient(c.client)
}

// clienset for the security.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) ExtAuthPolicies() ExtAuthPolicyClient {
	return NewExtAuthPolicyClient(c.client)
}

// clienset for the security.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) WAFPolicies() WAFPolicyClient {
	return NewWAFPolicyClient(c.client)
}

// clienset for the security.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) JWTPolicies() JWTPolicyClient {
	return NewJWTPolicyClient(c.client)
}

// clienset for the security.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) ClientTLSPolicies() ClientTLSPolicyClient {
	return NewClientTLSPolicyClient(c.client)
}

// clienset for the security.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) GraphQLAllowedQueryPolicies() GraphQLAllowedQueryPolicyClient {
	return NewGraphQLAllowedQueryPolicyClient(c.client)
}

// clienset for the security.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) DLPPolicies() DLPPolicyClient {
	return NewDLPPolicyClient(c.client)
}

// Reader knows how to read and list AccessPolicys.
type AccessPolicyReader interface {
	// Get retrieves a AccessPolicy for the given object key
	GetAccessPolicy(ctx context.Context, key client.ObjectKey) (*AccessPolicy, error)

	// List retrieves list of AccessPolicys for a given namespace and list options.
	ListAccessPolicy(ctx context.Context, opts ...client.ListOption) (*AccessPolicyList, error)
}

// AccessPolicyTransitionFunction instructs the AccessPolicyWriter how to transition between an existing
// AccessPolicy object and a desired on an Upsert
type AccessPolicyTransitionFunction func(existing, desired *AccessPolicy) error

// Writer knows how to create, delete, and update AccessPolicys.
type AccessPolicyWriter interface {
	// Create saves the AccessPolicy object.
	CreateAccessPolicy(ctx context.Context, obj *AccessPolicy, opts ...client.CreateOption) error

	// Delete deletes the AccessPolicy object.
	DeleteAccessPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given AccessPolicy object.
	UpdateAccessPolicy(ctx context.Context, obj *AccessPolicy, opts ...client.UpdateOption) error

	// Patch patches the given AccessPolicy object.
	PatchAccessPolicy(ctx context.Context, obj *AccessPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all AccessPolicy objects matching the given options.
	DeleteAllOfAccessPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the AccessPolicy object.
	UpsertAccessPolicy(ctx context.Context, obj *AccessPolicy, transitionFuncs ...AccessPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a AccessPolicy object.
type AccessPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given AccessPolicy object.
	UpdateAccessPolicyStatus(ctx context.Context, obj *AccessPolicy, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given AccessPolicy object's subresource.
	PatchAccessPolicyStatus(ctx context.Context, obj *AccessPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on AccessPolicys.
type AccessPolicyClient interface {
	AccessPolicyReader
	AccessPolicyWriter
	AccessPolicyStatusWriter
}

type accessPolicyClient struct {
	client client.Client
}

func NewAccessPolicyClient(client client.Client) *accessPolicyClient {
	return &accessPolicyClient{client: client}
}

func (c *accessPolicyClient) GetAccessPolicy(ctx context.Context, key client.ObjectKey) (*AccessPolicy, error) {
	obj := &AccessPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *accessPolicyClient) ListAccessPolicy(ctx context.Context, opts ...client.ListOption) (*AccessPolicyList, error) {
	list := &AccessPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *accessPolicyClient) CreateAccessPolicy(ctx context.Context, obj *AccessPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *accessPolicyClient) DeleteAccessPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &AccessPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *accessPolicyClient) UpdateAccessPolicy(ctx context.Context, obj *AccessPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *accessPolicyClient) PatchAccessPolicy(ctx context.Context, obj *AccessPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *accessPolicyClient) DeleteAllOfAccessPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &AccessPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *accessPolicyClient) UpsertAccessPolicy(ctx context.Context, obj *AccessPolicy, transitionFuncs ...AccessPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*AccessPolicy), desired.(*AccessPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *accessPolicyClient) UpdateAccessPolicyStatus(ctx context.Context, obj *AccessPolicy, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *accessPolicyClient) PatchAccessPolicyStatus(ctx context.Context, obj *AccessPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides AccessPolicyClients for multiple clusters.
type MulticlusterAccessPolicyClient interface {
	// Cluster returns a AccessPolicyClient for the given cluster
	Cluster(cluster string) (AccessPolicyClient, error)
}

type multiclusterAccessPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterAccessPolicyClient(client multicluster.Client) MulticlusterAccessPolicyClient {
	return &multiclusterAccessPolicyClient{client: client}
}

func (m *multiclusterAccessPolicyClient) Cluster(cluster string) (AccessPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewAccessPolicyClient(client), nil
}

// Reader knows how to read and list CORSPolicys.
type CORSPolicyReader interface {
	// Get retrieves a CORSPolicy for the given object key
	GetCORSPolicy(ctx context.Context, key client.ObjectKey) (*CORSPolicy, error)

	// List retrieves list of CORSPolicys for a given namespace and list options.
	ListCORSPolicy(ctx context.Context, opts ...client.ListOption) (*CORSPolicyList, error)
}

// CORSPolicyTransitionFunction instructs the CORSPolicyWriter how to transition between an existing
// CORSPolicy object and a desired on an Upsert
type CORSPolicyTransitionFunction func(existing, desired *CORSPolicy) error

// Writer knows how to create, delete, and update CORSPolicys.
type CORSPolicyWriter interface {
	// Create saves the CORSPolicy object.
	CreateCORSPolicy(ctx context.Context, obj *CORSPolicy, opts ...client.CreateOption) error

	// Delete deletes the CORSPolicy object.
	DeleteCORSPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given CORSPolicy object.
	UpdateCORSPolicy(ctx context.Context, obj *CORSPolicy, opts ...client.UpdateOption) error

	// Patch patches the given CORSPolicy object.
	PatchCORSPolicy(ctx context.Context, obj *CORSPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all CORSPolicy objects matching the given options.
	DeleteAllOfCORSPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the CORSPolicy object.
	UpsertCORSPolicy(ctx context.Context, obj *CORSPolicy, transitionFuncs ...CORSPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a CORSPolicy object.
type CORSPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given CORSPolicy object.
	UpdateCORSPolicyStatus(ctx context.Context, obj *CORSPolicy, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given CORSPolicy object's subresource.
	PatchCORSPolicyStatus(ctx context.Context, obj *CORSPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on CORSPolicys.
type CORSPolicyClient interface {
	CORSPolicyReader
	CORSPolicyWriter
	CORSPolicyStatusWriter
}

type cORSPolicyClient struct {
	client client.Client
}

func NewCORSPolicyClient(client client.Client) *cORSPolicyClient {
	return &cORSPolicyClient{client: client}
}

func (c *cORSPolicyClient) GetCORSPolicy(ctx context.Context, key client.ObjectKey) (*CORSPolicy, error) {
	obj := &CORSPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *cORSPolicyClient) ListCORSPolicy(ctx context.Context, opts ...client.ListOption) (*CORSPolicyList, error) {
	list := &CORSPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *cORSPolicyClient) CreateCORSPolicy(ctx context.Context, obj *CORSPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *cORSPolicyClient) DeleteCORSPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &CORSPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *cORSPolicyClient) UpdateCORSPolicy(ctx context.Context, obj *CORSPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *cORSPolicyClient) PatchCORSPolicy(ctx context.Context, obj *CORSPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *cORSPolicyClient) DeleteAllOfCORSPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &CORSPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *cORSPolicyClient) UpsertCORSPolicy(ctx context.Context, obj *CORSPolicy, transitionFuncs ...CORSPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*CORSPolicy), desired.(*CORSPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *cORSPolicyClient) UpdateCORSPolicyStatus(ctx context.Context, obj *CORSPolicy, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *cORSPolicyClient) PatchCORSPolicyStatus(ctx context.Context, obj *CORSPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides CORSPolicyClients for multiple clusters.
type MulticlusterCORSPolicyClient interface {
	// Cluster returns a CORSPolicyClient for the given cluster
	Cluster(cluster string) (CORSPolicyClient, error)
}

type multiclusterCORSPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterCORSPolicyClient(client multicluster.Client) MulticlusterCORSPolicyClient {
	return &multiclusterCORSPolicyClient{client: client}
}

func (m *multiclusterCORSPolicyClient) Cluster(cluster string) (CORSPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewCORSPolicyClient(client), nil
}

// Reader knows how to read and list CSRFPolicys.
type CSRFPolicyReader interface {
	// Get retrieves a CSRFPolicy for the given object key
	GetCSRFPolicy(ctx context.Context, key client.ObjectKey) (*CSRFPolicy, error)

	// List retrieves list of CSRFPolicys for a given namespace and list options.
	ListCSRFPolicy(ctx context.Context, opts ...client.ListOption) (*CSRFPolicyList, error)
}

// CSRFPolicyTransitionFunction instructs the CSRFPolicyWriter how to transition between an existing
// CSRFPolicy object and a desired on an Upsert
type CSRFPolicyTransitionFunction func(existing, desired *CSRFPolicy) error

// Writer knows how to create, delete, and update CSRFPolicys.
type CSRFPolicyWriter interface {
	// Create saves the CSRFPolicy object.
	CreateCSRFPolicy(ctx context.Context, obj *CSRFPolicy, opts ...client.CreateOption) error

	// Delete deletes the CSRFPolicy object.
	DeleteCSRFPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given CSRFPolicy object.
	UpdateCSRFPolicy(ctx context.Context, obj *CSRFPolicy, opts ...client.UpdateOption) error

	// Patch patches the given CSRFPolicy object.
	PatchCSRFPolicy(ctx context.Context, obj *CSRFPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all CSRFPolicy objects matching the given options.
	DeleteAllOfCSRFPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the CSRFPolicy object.
	UpsertCSRFPolicy(ctx context.Context, obj *CSRFPolicy, transitionFuncs ...CSRFPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a CSRFPolicy object.
type CSRFPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given CSRFPolicy object.
	UpdateCSRFPolicyStatus(ctx context.Context, obj *CSRFPolicy, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given CSRFPolicy object's subresource.
	PatchCSRFPolicyStatus(ctx context.Context, obj *CSRFPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on CSRFPolicys.
type CSRFPolicyClient interface {
	CSRFPolicyReader
	CSRFPolicyWriter
	CSRFPolicyStatusWriter
}

type cSRFPolicyClient struct {
	client client.Client
}

func NewCSRFPolicyClient(client client.Client) *cSRFPolicyClient {
	return &cSRFPolicyClient{client: client}
}

func (c *cSRFPolicyClient) GetCSRFPolicy(ctx context.Context, key client.ObjectKey) (*CSRFPolicy, error) {
	obj := &CSRFPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *cSRFPolicyClient) ListCSRFPolicy(ctx context.Context, opts ...client.ListOption) (*CSRFPolicyList, error) {
	list := &CSRFPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *cSRFPolicyClient) CreateCSRFPolicy(ctx context.Context, obj *CSRFPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *cSRFPolicyClient) DeleteCSRFPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &CSRFPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *cSRFPolicyClient) UpdateCSRFPolicy(ctx context.Context, obj *CSRFPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *cSRFPolicyClient) PatchCSRFPolicy(ctx context.Context, obj *CSRFPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *cSRFPolicyClient) DeleteAllOfCSRFPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &CSRFPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *cSRFPolicyClient) UpsertCSRFPolicy(ctx context.Context, obj *CSRFPolicy, transitionFuncs ...CSRFPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*CSRFPolicy), desired.(*CSRFPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *cSRFPolicyClient) UpdateCSRFPolicyStatus(ctx context.Context, obj *CSRFPolicy, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *cSRFPolicyClient) PatchCSRFPolicyStatus(ctx context.Context, obj *CSRFPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides CSRFPolicyClients for multiple clusters.
type MulticlusterCSRFPolicyClient interface {
	// Cluster returns a CSRFPolicyClient for the given cluster
	Cluster(cluster string) (CSRFPolicyClient, error)
}

type multiclusterCSRFPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterCSRFPolicyClient(client multicluster.Client) MulticlusterCSRFPolicyClient {
	return &multiclusterCSRFPolicyClient{client: client}
}

func (m *multiclusterCSRFPolicyClient) Cluster(cluster string) (CSRFPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewCSRFPolicyClient(client), nil
}

// Reader knows how to read and list ExtAuthPolicys.
type ExtAuthPolicyReader interface {
	// Get retrieves a ExtAuthPolicy for the given object key
	GetExtAuthPolicy(ctx context.Context, key client.ObjectKey) (*ExtAuthPolicy, error)

	// List retrieves list of ExtAuthPolicys for a given namespace and list options.
	ListExtAuthPolicy(ctx context.Context, opts ...client.ListOption) (*ExtAuthPolicyList, error)
}

// ExtAuthPolicyTransitionFunction instructs the ExtAuthPolicyWriter how to transition between an existing
// ExtAuthPolicy object and a desired on an Upsert
type ExtAuthPolicyTransitionFunction func(existing, desired *ExtAuthPolicy) error

// Writer knows how to create, delete, and update ExtAuthPolicys.
type ExtAuthPolicyWriter interface {
	// Create saves the ExtAuthPolicy object.
	CreateExtAuthPolicy(ctx context.Context, obj *ExtAuthPolicy, opts ...client.CreateOption) error

	// Delete deletes the ExtAuthPolicy object.
	DeleteExtAuthPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given ExtAuthPolicy object.
	UpdateExtAuthPolicy(ctx context.Context, obj *ExtAuthPolicy, opts ...client.UpdateOption) error

	// Patch patches the given ExtAuthPolicy object.
	PatchExtAuthPolicy(ctx context.Context, obj *ExtAuthPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all ExtAuthPolicy objects matching the given options.
	DeleteAllOfExtAuthPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the ExtAuthPolicy object.
	UpsertExtAuthPolicy(ctx context.Context, obj *ExtAuthPolicy, transitionFuncs ...ExtAuthPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a ExtAuthPolicy object.
type ExtAuthPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given ExtAuthPolicy object.
	UpdateExtAuthPolicyStatus(ctx context.Context, obj *ExtAuthPolicy, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given ExtAuthPolicy object's subresource.
	PatchExtAuthPolicyStatus(ctx context.Context, obj *ExtAuthPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on ExtAuthPolicys.
type ExtAuthPolicyClient interface {
	ExtAuthPolicyReader
	ExtAuthPolicyWriter
	ExtAuthPolicyStatusWriter
}

type extAuthPolicyClient struct {
	client client.Client
}

func NewExtAuthPolicyClient(client client.Client) *extAuthPolicyClient {
	return &extAuthPolicyClient{client: client}
}

func (c *extAuthPolicyClient) GetExtAuthPolicy(ctx context.Context, key client.ObjectKey) (*ExtAuthPolicy, error) {
	obj := &ExtAuthPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *extAuthPolicyClient) ListExtAuthPolicy(ctx context.Context, opts ...client.ListOption) (*ExtAuthPolicyList, error) {
	list := &ExtAuthPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *extAuthPolicyClient) CreateExtAuthPolicy(ctx context.Context, obj *ExtAuthPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *extAuthPolicyClient) DeleteExtAuthPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &ExtAuthPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *extAuthPolicyClient) UpdateExtAuthPolicy(ctx context.Context, obj *ExtAuthPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *extAuthPolicyClient) PatchExtAuthPolicy(ctx context.Context, obj *ExtAuthPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *extAuthPolicyClient) DeleteAllOfExtAuthPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &ExtAuthPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *extAuthPolicyClient) UpsertExtAuthPolicy(ctx context.Context, obj *ExtAuthPolicy, transitionFuncs ...ExtAuthPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*ExtAuthPolicy), desired.(*ExtAuthPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *extAuthPolicyClient) UpdateExtAuthPolicyStatus(ctx context.Context, obj *ExtAuthPolicy, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *extAuthPolicyClient) PatchExtAuthPolicyStatus(ctx context.Context, obj *ExtAuthPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides ExtAuthPolicyClients for multiple clusters.
type MulticlusterExtAuthPolicyClient interface {
	// Cluster returns a ExtAuthPolicyClient for the given cluster
	Cluster(cluster string) (ExtAuthPolicyClient, error)
}

type multiclusterExtAuthPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterExtAuthPolicyClient(client multicluster.Client) MulticlusterExtAuthPolicyClient {
	return &multiclusterExtAuthPolicyClient{client: client}
}

func (m *multiclusterExtAuthPolicyClient) Cluster(cluster string) (ExtAuthPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewExtAuthPolicyClient(client), nil
}

// Reader knows how to read and list WAFPolicys.
type WAFPolicyReader interface {
	// Get retrieves a WAFPolicy for the given object key
	GetWAFPolicy(ctx context.Context, key client.ObjectKey) (*WAFPolicy, error)

	// List retrieves list of WAFPolicys for a given namespace and list options.
	ListWAFPolicy(ctx context.Context, opts ...client.ListOption) (*WAFPolicyList, error)
}

// WAFPolicyTransitionFunction instructs the WAFPolicyWriter how to transition between an existing
// WAFPolicy object and a desired on an Upsert
type WAFPolicyTransitionFunction func(existing, desired *WAFPolicy) error

// Writer knows how to create, delete, and update WAFPolicys.
type WAFPolicyWriter interface {
	// Create saves the WAFPolicy object.
	CreateWAFPolicy(ctx context.Context, obj *WAFPolicy, opts ...client.CreateOption) error

	// Delete deletes the WAFPolicy object.
	DeleteWAFPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given WAFPolicy object.
	UpdateWAFPolicy(ctx context.Context, obj *WAFPolicy, opts ...client.UpdateOption) error

	// Patch patches the given WAFPolicy object.
	PatchWAFPolicy(ctx context.Context, obj *WAFPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all WAFPolicy objects matching the given options.
	DeleteAllOfWAFPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the WAFPolicy object.
	UpsertWAFPolicy(ctx context.Context, obj *WAFPolicy, transitionFuncs ...WAFPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a WAFPolicy object.
type WAFPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given WAFPolicy object.
	UpdateWAFPolicyStatus(ctx context.Context, obj *WAFPolicy, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given WAFPolicy object's subresource.
	PatchWAFPolicyStatus(ctx context.Context, obj *WAFPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on WAFPolicys.
type WAFPolicyClient interface {
	WAFPolicyReader
	WAFPolicyWriter
	WAFPolicyStatusWriter
}

type wAFPolicyClient struct {
	client client.Client
}

func NewWAFPolicyClient(client client.Client) *wAFPolicyClient {
	return &wAFPolicyClient{client: client}
}

func (c *wAFPolicyClient) GetWAFPolicy(ctx context.Context, key client.ObjectKey) (*WAFPolicy, error) {
	obj := &WAFPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *wAFPolicyClient) ListWAFPolicy(ctx context.Context, opts ...client.ListOption) (*WAFPolicyList, error) {
	list := &WAFPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *wAFPolicyClient) CreateWAFPolicy(ctx context.Context, obj *WAFPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *wAFPolicyClient) DeleteWAFPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &WAFPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *wAFPolicyClient) UpdateWAFPolicy(ctx context.Context, obj *WAFPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *wAFPolicyClient) PatchWAFPolicy(ctx context.Context, obj *WAFPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *wAFPolicyClient) DeleteAllOfWAFPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &WAFPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *wAFPolicyClient) UpsertWAFPolicy(ctx context.Context, obj *WAFPolicy, transitionFuncs ...WAFPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*WAFPolicy), desired.(*WAFPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *wAFPolicyClient) UpdateWAFPolicyStatus(ctx context.Context, obj *WAFPolicy, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *wAFPolicyClient) PatchWAFPolicyStatus(ctx context.Context, obj *WAFPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides WAFPolicyClients for multiple clusters.
type MulticlusterWAFPolicyClient interface {
	// Cluster returns a WAFPolicyClient for the given cluster
	Cluster(cluster string) (WAFPolicyClient, error)
}

type multiclusterWAFPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterWAFPolicyClient(client multicluster.Client) MulticlusterWAFPolicyClient {
	return &multiclusterWAFPolicyClient{client: client}
}

func (m *multiclusterWAFPolicyClient) Cluster(cluster string) (WAFPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewWAFPolicyClient(client), nil
}

// Reader knows how to read and list JWTPolicys.
type JWTPolicyReader interface {
	// Get retrieves a JWTPolicy for the given object key
	GetJWTPolicy(ctx context.Context, key client.ObjectKey) (*JWTPolicy, error)

	// List retrieves list of JWTPolicys for a given namespace and list options.
	ListJWTPolicy(ctx context.Context, opts ...client.ListOption) (*JWTPolicyList, error)
}

// JWTPolicyTransitionFunction instructs the JWTPolicyWriter how to transition between an existing
// JWTPolicy object and a desired on an Upsert
type JWTPolicyTransitionFunction func(existing, desired *JWTPolicy) error

// Writer knows how to create, delete, and update JWTPolicys.
type JWTPolicyWriter interface {
	// Create saves the JWTPolicy object.
	CreateJWTPolicy(ctx context.Context, obj *JWTPolicy, opts ...client.CreateOption) error

	// Delete deletes the JWTPolicy object.
	DeleteJWTPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given JWTPolicy object.
	UpdateJWTPolicy(ctx context.Context, obj *JWTPolicy, opts ...client.UpdateOption) error

	// Patch patches the given JWTPolicy object.
	PatchJWTPolicy(ctx context.Context, obj *JWTPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all JWTPolicy objects matching the given options.
	DeleteAllOfJWTPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the JWTPolicy object.
	UpsertJWTPolicy(ctx context.Context, obj *JWTPolicy, transitionFuncs ...JWTPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a JWTPolicy object.
type JWTPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given JWTPolicy object.
	UpdateJWTPolicyStatus(ctx context.Context, obj *JWTPolicy, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given JWTPolicy object's subresource.
	PatchJWTPolicyStatus(ctx context.Context, obj *JWTPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on JWTPolicys.
type JWTPolicyClient interface {
	JWTPolicyReader
	JWTPolicyWriter
	JWTPolicyStatusWriter
}

type jWTPolicyClient struct {
	client client.Client
}

func NewJWTPolicyClient(client client.Client) *jWTPolicyClient {
	return &jWTPolicyClient{client: client}
}

func (c *jWTPolicyClient) GetJWTPolicy(ctx context.Context, key client.ObjectKey) (*JWTPolicy, error) {
	obj := &JWTPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *jWTPolicyClient) ListJWTPolicy(ctx context.Context, opts ...client.ListOption) (*JWTPolicyList, error) {
	list := &JWTPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *jWTPolicyClient) CreateJWTPolicy(ctx context.Context, obj *JWTPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *jWTPolicyClient) DeleteJWTPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &JWTPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *jWTPolicyClient) UpdateJWTPolicy(ctx context.Context, obj *JWTPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *jWTPolicyClient) PatchJWTPolicy(ctx context.Context, obj *JWTPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *jWTPolicyClient) DeleteAllOfJWTPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &JWTPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *jWTPolicyClient) UpsertJWTPolicy(ctx context.Context, obj *JWTPolicy, transitionFuncs ...JWTPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*JWTPolicy), desired.(*JWTPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *jWTPolicyClient) UpdateJWTPolicyStatus(ctx context.Context, obj *JWTPolicy, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *jWTPolicyClient) PatchJWTPolicyStatus(ctx context.Context, obj *JWTPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides JWTPolicyClients for multiple clusters.
type MulticlusterJWTPolicyClient interface {
	// Cluster returns a JWTPolicyClient for the given cluster
	Cluster(cluster string) (JWTPolicyClient, error)
}

type multiclusterJWTPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterJWTPolicyClient(client multicluster.Client) MulticlusterJWTPolicyClient {
	return &multiclusterJWTPolicyClient{client: client}
}

func (m *multiclusterJWTPolicyClient) Cluster(cluster string) (JWTPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewJWTPolicyClient(client), nil
}

// Reader knows how to read and list ClientTLSPolicys.
type ClientTLSPolicyReader interface {
	// Get retrieves a ClientTLSPolicy for the given object key
	GetClientTLSPolicy(ctx context.Context, key client.ObjectKey) (*ClientTLSPolicy, error)

	// List retrieves list of ClientTLSPolicys for a given namespace and list options.
	ListClientTLSPolicy(ctx context.Context, opts ...client.ListOption) (*ClientTLSPolicyList, error)
}

// ClientTLSPolicyTransitionFunction instructs the ClientTLSPolicyWriter how to transition between an existing
// ClientTLSPolicy object and a desired on an Upsert
type ClientTLSPolicyTransitionFunction func(existing, desired *ClientTLSPolicy) error

// Writer knows how to create, delete, and update ClientTLSPolicys.
type ClientTLSPolicyWriter interface {
	// Create saves the ClientTLSPolicy object.
	CreateClientTLSPolicy(ctx context.Context, obj *ClientTLSPolicy, opts ...client.CreateOption) error

	// Delete deletes the ClientTLSPolicy object.
	DeleteClientTLSPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given ClientTLSPolicy object.
	UpdateClientTLSPolicy(ctx context.Context, obj *ClientTLSPolicy, opts ...client.UpdateOption) error

	// Patch patches the given ClientTLSPolicy object.
	PatchClientTLSPolicy(ctx context.Context, obj *ClientTLSPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all ClientTLSPolicy objects matching the given options.
	DeleteAllOfClientTLSPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the ClientTLSPolicy object.
	UpsertClientTLSPolicy(ctx context.Context, obj *ClientTLSPolicy, transitionFuncs ...ClientTLSPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a ClientTLSPolicy object.
type ClientTLSPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given ClientTLSPolicy object.
	UpdateClientTLSPolicyStatus(ctx context.Context, obj *ClientTLSPolicy, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given ClientTLSPolicy object's subresource.
	PatchClientTLSPolicyStatus(ctx context.Context, obj *ClientTLSPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on ClientTLSPolicys.
type ClientTLSPolicyClient interface {
	ClientTLSPolicyReader
	ClientTLSPolicyWriter
	ClientTLSPolicyStatusWriter
}

type clientTLSPolicyClient struct {
	client client.Client
}

func NewClientTLSPolicyClient(client client.Client) *clientTLSPolicyClient {
	return &clientTLSPolicyClient{client: client}
}

func (c *clientTLSPolicyClient) GetClientTLSPolicy(ctx context.Context, key client.ObjectKey) (*ClientTLSPolicy, error) {
	obj := &ClientTLSPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *clientTLSPolicyClient) ListClientTLSPolicy(ctx context.Context, opts ...client.ListOption) (*ClientTLSPolicyList, error) {
	list := &ClientTLSPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *clientTLSPolicyClient) CreateClientTLSPolicy(ctx context.Context, obj *ClientTLSPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *clientTLSPolicyClient) DeleteClientTLSPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &ClientTLSPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *clientTLSPolicyClient) UpdateClientTLSPolicy(ctx context.Context, obj *ClientTLSPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *clientTLSPolicyClient) PatchClientTLSPolicy(ctx context.Context, obj *ClientTLSPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *clientTLSPolicyClient) DeleteAllOfClientTLSPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &ClientTLSPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *clientTLSPolicyClient) UpsertClientTLSPolicy(ctx context.Context, obj *ClientTLSPolicy, transitionFuncs ...ClientTLSPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*ClientTLSPolicy), desired.(*ClientTLSPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *clientTLSPolicyClient) UpdateClientTLSPolicyStatus(ctx context.Context, obj *ClientTLSPolicy, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *clientTLSPolicyClient) PatchClientTLSPolicyStatus(ctx context.Context, obj *ClientTLSPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides ClientTLSPolicyClients for multiple clusters.
type MulticlusterClientTLSPolicyClient interface {
	// Cluster returns a ClientTLSPolicyClient for the given cluster
	Cluster(cluster string) (ClientTLSPolicyClient, error)
}

type multiclusterClientTLSPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterClientTLSPolicyClient(client multicluster.Client) MulticlusterClientTLSPolicyClient {
	return &multiclusterClientTLSPolicyClient{client: client}
}

func (m *multiclusterClientTLSPolicyClient) Cluster(cluster string) (ClientTLSPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewClientTLSPolicyClient(client), nil
}

// Reader knows how to read and list GraphQLAllowedQueryPolicys.
type GraphQLAllowedQueryPolicyReader interface {
	// Get retrieves a GraphQLAllowedQueryPolicy for the given object key
	GetGraphQLAllowedQueryPolicy(ctx context.Context, key client.ObjectKey) (*GraphQLAllowedQueryPolicy, error)

	// List retrieves list of GraphQLAllowedQueryPolicys for a given namespace and list options.
	ListGraphQLAllowedQueryPolicy(ctx context.Context, opts ...client.ListOption) (*GraphQLAllowedQueryPolicyList, error)
}

// GraphQLAllowedQueryPolicyTransitionFunction instructs the GraphQLAllowedQueryPolicyWriter how to transition between an existing
// GraphQLAllowedQueryPolicy object and a desired on an Upsert
type GraphQLAllowedQueryPolicyTransitionFunction func(existing, desired *GraphQLAllowedQueryPolicy) error

// Writer knows how to create, delete, and update GraphQLAllowedQueryPolicys.
type GraphQLAllowedQueryPolicyWriter interface {
	// Create saves the GraphQLAllowedQueryPolicy object.
	CreateGraphQLAllowedQueryPolicy(ctx context.Context, obj *GraphQLAllowedQueryPolicy, opts ...client.CreateOption) error

	// Delete deletes the GraphQLAllowedQueryPolicy object.
	DeleteGraphQLAllowedQueryPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given GraphQLAllowedQueryPolicy object.
	UpdateGraphQLAllowedQueryPolicy(ctx context.Context, obj *GraphQLAllowedQueryPolicy, opts ...client.UpdateOption) error

	// Patch patches the given GraphQLAllowedQueryPolicy object.
	PatchGraphQLAllowedQueryPolicy(ctx context.Context, obj *GraphQLAllowedQueryPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all GraphQLAllowedQueryPolicy objects matching the given options.
	DeleteAllOfGraphQLAllowedQueryPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the GraphQLAllowedQueryPolicy object.
	UpsertGraphQLAllowedQueryPolicy(ctx context.Context, obj *GraphQLAllowedQueryPolicy, transitionFuncs ...GraphQLAllowedQueryPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a GraphQLAllowedQueryPolicy object.
type GraphQLAllowedQueryPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given GraphQLAllowedQueryPolicy object.
	UpdateGraphQLAllowedQueryPolicyStatus(ctx context.Context, obj *GraphQLAllowedQueryPolicy, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given GraphQLAllowedQueryPolicy object's subresource.
	PatchGraphQLAllowedQueryPolicyStatus(ctx context.Context, obj *GraphQLAllowedQueryPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on GraphQLAllowedQueryPolicys.
type GraphQLAllowedQueryPolicyClient interface {
	GraphQLAllowedQueryPolicyReader
	GraphQLAllowedQueryPolicyWriter
	GraphQLAllowedQueryPolicyStatusWriter
}

type graphQLAllowedQueryPolicyClient struct {
	client client.Client
}

func NewGraphQLAllowedQueryPolicyClient(client client.Client) *graphQLAllowedQueryPolicyClient {
	return &graphQLAllowedQueryPolicyClient{client: client}
}

func (c *graphQLAllowedQueryPolicyClient) GetGraphQLAllowedQueryPolicy(ctx context.Context, key client.ObjectKey) (*GraphQLAllowedQueryPolicy, error) {
	obj := &GraphQLAllowedQueryPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *graphQLAllowedQueryPolicyClient) ListGraphQLAllowedQueryPolicy(ctx context.Context, opts ...client.ListOption) (*GraphQLAllowedQueryPolicyList, error) {
	list := &GraphQLAllowedQueryPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *graphQLAllowedQueryPolicyClient) CreateGraphQLAllowedQueryPolicy(ctx context.Context, obj *GraphQLAllowedQueryPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *graphQLAllowedQueryPolicyClient) DeleteGraphQLAllowedQueryPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &GraphQLAllowedQueryPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *graphQLAllowedQueryPolicyClient) UpdateGraphQLAllowedQueryPolicy(ctx context.Context, obj *GraphQLAllowedQueryPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *graphQLAllowedQueryPolicyClient) PatchGraphQLAllowedQueryPolicy(ctx context.Context, obj *GraphQLAllowedQueryPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *graphQLAllowedQueryPolicyClient) DeleteAllOfGraphQLAllowedQueryPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &GraphQLAllowedQueryPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *graphQLAllowedQueryPolicyClient) UpsertGraphQLAllowedQueryPolicy(ctx context.Context, obj *GraphQLAllowedQueryPolicy, transitionFuncs ...GraphQLAllowedQueryPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*GraphQLAllowedQueryPolicy), desired.(*GraphQLAllowedQueryPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *graphQLAllowedQueryPolicyClient) UpdateGraphQLAllowedQueryPolicyStatus(ctx context.Context, obj *GraphQLAllowedQueryPolicy, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *graphQLAllowedQueryPolicyClient) PatchGraphQLAllowedQueryPolicyStatus(ctx context.Context, obj *GraphQLAllowedQueryPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides GraphQLAllowedQueryPolicyClients for multiple clusters.
type MulticlusterGraphQLAllowedQueryPolicyClient interface {
	// Cluster returns a GraphQLAllowedQueryPolicyClient for the given cluster
	Cluster(cluster string) (GraphQLAllowedQueryPolicyClient, error)
}

type multiclusterGraphQLAllowedQueryPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterGraphQLAllowedQueryPolicyClient(client multicluster.Client) MulticlusterGraphQLAllowedQueryPolicyClient {
	return &multiclusterGraphQLAllowedQueryPolicyClient{client: client}
}

func (m *multiclusterGraphQLAllowedQueryPolicyClient) Cluster(cluster string) (GraphQLAllowedQueryPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewGraphQLAllowedQueryPolicyClient(client), nil
}

// Reader knows how to read and list DLPPolicys.
type DLPPolicyReader interface {
	// Get retrieves a DLPPolicy for the given object key
	GetDLPPolicy(ctx context.Context, key client.ObjectKey) (*DLPPolicy, error)

	// List retrieves list of DLPPolicys for a given namespace and list options.
	ListDLPPolicy(ctx context.Context, opts ...client.ListOption) (*DLPPolicyList, error)
}

// DLPPolicyTransitionFunction instructs the DLPPolicyWriter how to transition between an existing
// DLPPolicy object and a desired on an Upsert
type DLPPolicyTransitionFunction func(existing, desired *DLPPolicy) error

// Writer knows how to create, delete, and update DLPPolicys.
type DLPPolicyWriter interface {
	// Create saves the DLPPolicy object.
	CreateDLPPolicy(ctx context.Context, obj *DLPPolicy, opts ...client.CreateOption) error

	// Delete deletes the DLPPolicy object.
	DeleteDLPPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given DLPPolicy object.
	UpdateDLPPolicy(ctx context.Context, obj *DLPPolicy, opts ...client.UpdateOption) error

	// Patch patches the given DLPPolicy object.
	PatchDLPPolicy(ctx context.Context, obj *DLPPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all DLPPolicy objects matching the given options.
	DeleteAllOfDLPPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the DLPPolicy object.
	UpsertDLPPolicy(ctx context.Context, obj *DLPPolicy, transitionFuncs ...DLPPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a DLPPolicy object.
type DLPPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given DLPPolicy object.
	UpdateDLPPolicyStatus(ctx context.Context, obj *DLPPolicy, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given DLPPolicy object's subresource.
	PatchDLPPolicyStatus(ctx context.Context, obj *DLPPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on DLPPolicys.
type DLPPolicyClient interface {
	DLPPolicyReader
	DLPPolicyWriter
	DLPPolicyStatusWriter
}

type dLPPolicyClient struct {
	client client.Client
}

func NewDLPPolicyClient(client client.Client) *dLPPolicyClient {
	return &dLPPolicyClient{client: client}
}

func (c *dLPPolicyClient) GetDLPPolicy(ctx context.Context, key client.ObjectKey) (*DLPPolicy, error) {
	obj := &DLPPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *dLPPolicyClient) ListDLPPolicy(ctx context.Context, opts ...client.ListOption) (*DLPPolicyList, error) {
	list := &DLPPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *dLPPolicyClient) CreateDLPPolicy(ctx context.Context, obj *DLPPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *dLPPolicyClient) DeleteDLPPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &DLPPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *dLPPolicyClient) UpdateDLPPolicy(ctx context.Context, obj *DLPPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *dLPPolicyClient) PatchDLPPolicy(ctx context.Context, obj *DLPPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *dLPPolicyClient) DeleteAllOfDLPPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &DLPPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *dLPPolicyClient) UpsertDLPPolicy(ctx context.Context, obj *DLPPolicy, transitionFuncs ...DLPPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*DLPPolicy), desired.(*DLPPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *dLPPolicyClient) UpdateDLPPolicyStatus(ctx context.Context, obj *DLPPolicy, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *dLPPolicyClient) PatchDLPPolicyStatus(ctx context.Context, obj *DLPPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides DLPPolicyClients for multiple clusters.
type MulticlusterDLPPolicyClient interface {
	// Cluster returns a DLPPolicyClient for the given cluster
	Cluster(cluster string) (DLPPolicyClient, error)
}

type multiclusterDLPPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterDLPPolicyClient(client multicluster.Client) MulticlusterDLPPolicyClient {
	return &multiclusterDLPPolicyClient{client: client}
}

func (m *multiclusterDLPPolicyClient) Cluster(cluster string) (DLPPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewDLPPolicyClient(client), nil
}
