// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./reconcilers.go -destination mocks/reconcilers.go

// Definitions for the Kubernetes Controllers
package controller

import (
	"context"

	resilience_policy_gloo_solo_io_v2 "github.com/solo-io/gloo/projects/gloo/cli/pkg/cmd/gatewayapi/envoy/gloo-mesh-client-go/resilience.policy.gloo.solo.io/v2"

	"github.com/pkg/errors"
	"github.com/solo-io/skv2/pkg/ezkube"
	"github.com/solo-io/skv2/pkg/reconcile"
	"sigs.k8s.io/controller-runtime/pkg/manager"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
)

// Reconcile Upsert events for the GraphQLPersistedQueryCachePolicy Resource.
// implemented by the user
type GraphQLPersistedQueryCachePolicyReconciler interface {
	ReconcileGraphQLPersistedQueryCachePolicy(obj *resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the GraphQLPersistedQueryCachePolicy Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type GraphQLPersistedQueryCachePolicyDeletionReconciler interface {
	ReconcileGraphQLPersistedQueryCachePolicyDeletion(req reconcile.Request) error
}

type GraphQLPersistedQueryCachePolicyReconcilerFuncs struct {
	OnReconcileGraphQLPersistedQueryCachePolicy         func(obj *resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) (reconcile.Result, error)
	OnReconcileGraphQLPersistedQueryCachePolicyDeletion func(req reconcile.Request) error
}

func (f *GraphQLPersistedQueryCachePolicyReconcilerFuncs) ReconcileGraphQLPersistedQueryCachePolicy(obj *resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) (reconcile.Result, error) {
	if f.OnReconcileGraphQLPersistedQueryCachePolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileGraphQLPersistedQueryCachePolicy(obj)
}

func (f *GraphQLPersistedQueryCachePolicyReconcilerFuncs) ReconcileGraphQLPersistedQueryCachePolicyDeletion(req reconcile.Request) error {
	if f.OnReconcileGraphQLPersistedQueryCachePolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileGraphQLPersistedQueryCachePolicyDeletion(req)
}

// Reconcile and finalize the GraphQLPersistedQueryCachePolicy Resource
// implemented by the user
type GraphQLPersistedQueryCachePolicyFinalizer interface {
	GraphQLPersistedQueryCachePolicyReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	GraphQLPersistedQueryCachePolicyFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeGraphQLPersistedQueryCachePolicy(obj *resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) error
}

type GraphQLPersistedQueryCachePolicyReconcileLoop interface {
	RunGraphQLPersistedQueryCachePolicyReconciler(ctx context.Context, rec GraphQLPersistedQueryCachePolicyReconciler, predicates ...predicate.Predicate) error
}

type graphQLPersistedQueryCachePolicyReconcileLoop struct {
	loop reconcile.Loop
}

func NewGraphQLPersistedQueryCachePolicyReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) GraphQLPersistedQueryCachePolicyReconcileLoop {
	return &graphQLPersistedQueryCachePolicyReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy{}, options),
	}
}

func (c *graphQLPersistedQueryCachePolicyReconcileLoop) RunGraphQLPersistedQueryCachePolicyReconciler(ctx context.Context, reconciler GraphQLPersistedQueryCachePolicyReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericGraphQLPersistedQueryCachePolicyReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(GraphQLPersistedQueryCachePolicyFinalizer); ok {
		reconcilerWrapper = genericGraphQLPersistedQueryCachePolicyFinalizer{
			genericGraphQLPersistedQueryCachePolicyReconciler: genericReconciler,
			finalizingReconciler:                              finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericGraphQLPersistedQueryCachePolicyHandler implements a generic reconcile.Reconciler
type genericGraphQLPersistedQueryCachePolicyReconciler struct {
	reconciler GraphQLPersistedQueryCachePolicyReconciler
}

func (r genericGraphQLPersistedQueryCachePolicyReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: GraphQLPersistedQueryCachePolicy handler received event for %T", object)
	}
	return r.reconciler.ReconcileGraphQLPersistedQueryCachePolicy(obj)
}

func (r genericGraphQLPersistedQueryCachePolicyReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(GraphQLPersistedQueryCachePolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileGraphQLPersistedQueryCachePolicyDeletion(request)
	}
	return nil
}

// genericGraphQLPersistedQueryCachePolicyFinalizer implements a generic reconcile.FinalizingReconciler
type genericGraphQLPersistedQueryCachePolicyFinalizer struct {
	genericGraphQLPersistedQueryCachePolicyReconciler
	finalizingReconciler GraphQLPersistedQueryCachePolicyFinalizer
}

func (r genericGraphQLPersistedQueryCachePolicyFinalizer) FinalizerName() string {
	return r.finalizingReconciler.GraphQLPersistedQueryCachePolicyFinalizerName()
}

func (r genericGraphQLPersistedQueryCachePolicyFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy)
	if !ok {
		return errors.Errorf("internal error: GraphQLPersistedQueryCachePolicy handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeGraphQLPersistedQueryCachePolicy(obj)
}

// Reconcile Upsert events for the FailoverPolicy Resource.
// implemented by the user
type FailoverPolicyReconciler interface {
	ReconcileFailoverPolicy(obj *resilience_policy_gloo_solo_io_v2.FailoverPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the FailoverPolicy Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type FailoverPolicyDeletionReconciler interface {
	ReconcileFailoverPolicyDeletion(req reconcile.Request) error
}

type FailoverPolicyReconcilerFuncs struct {
	OnReconcileFailoverPolicy         func(obj *resilience_policy_gloo_solo_io_v2.FailoverPolicy) (reconcile.Result, error)
	OnReconcileFailoverPolicyDeletion func(req reconcile.Request) error
}

func (f *FailoverPolicyReconcilerFuncs) ReconcileFailoverPolicy(obj *resilience_policy_gloo_solo_io_v2.FailoverPolicy) (reconcile.Result, error) {
	if f.OnReconcileFailoverPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileFailoverPolicy(obj)
}

func (f *FailoverPolicyReconcilerFuncs) ReconcileFailoverPolicyDeletion(req reconcile.Request) error {
	if f.OnReconcileFailoverPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileFailoverPolicyDeletion(req)
}

// Reconcile and finalize the FailoverPolicy Resource
// implemented by the user
type FailoverPolicyFinalizer interface {
	FailoverPolicyReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	FailoverPolicyFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeFailoverPolicy(obj *resilience_policy_gloo_solo_io_v2.FailoverPolicy) error
}

type FailoverPolicyReconcileLoop interface {
	RunFailoverPolicyReconciler(ctx context.Context, rec FailoverPolicyReconciler, predicates ...predicate.Predicate) error
}

type failoverPolicyReconcileLoop struct {
	loop reconcile.Loop
}

func NewFailoverPolicyReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) FailoverPolicyReconcileLoop {
	return &failoverPolicyReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &resilience_policy_gloo_solo_io_v2.FailoverPolicy{}, options),
	}
}

func (c *failoverPolicyReconcileLoop) RunFailoverPolicyReconciler(ctx context.Context, reconciler FailoverPolicyReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericFailoverPolicyReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(FailoverPolicyFinalizer); ok {
		reconcilerWrapper = genericFailoverPolicyFinalizer{
			genericFailoverPolicyReconciler: genericReconciler,
			finalizingReconciler:            finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericFailoverPolicyHandler implements a generic reconcile.Reconciler
type genericFailoverPolicyReconciler struct {
	reconciler FailoverPolicyReconciler
}

func (r genericFailoverPolicyReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.FailoverPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: FailoverPolicy handler received event for %T", object)
	}
	return r.reconciler.ReconcileFailoverPolicy(obj)
}

func (r genericFailoverPolicyReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(FailoverPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileFailoverPolicyDeletion(request)
	}
	return nil
}

// genericFailoverPolicyFinalizer implements a generic reconcile.FinalizingReconciler
type genericFailoverPolicyFinalizer struct {
	genericFailoverPolicyReconciler
	finalizingReconciler FailoverPolicyFinalizer
}

func (r genericFailoverPolicyFinalizer) FinalizerName() string {
	return r.finalizingReconciler.FailoverPolicyFinalizerName()
}

func (r genericFailoverPolicyFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.FailoverPolicy)
	if !ok {
		return errors.Errorf("internal error: FailoverPolicy handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeFailoverPolicy(obj)
}

// Reconcile Upsert events for the OutlierDetectionPolicy Resource.
// implemented by the user
type OutlierDetectionPolicyReconciler interface {
	ReconcileOutlierDetectionPolicy(obj *resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the OutlierDetectionPolicy Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type OutlierDetectionPolicyDeletionReconciler interface {
	ReconcileOutlierDetectionPolicyDeletion(req reconcile.Request) error
}

type OutlierDetectionPolicyReconcilerFuncs struct {
	OnReconcileOutlierDetectionPolicy         func(obj *resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) (reconcile.Result, error)
	OnReconcileOutlierDetectionPolicyDeletion func(req reconcile.Request) error
}

func (f *OutlierDetectionPolicyReconcilerFuncs) ReconcileOutlierDetectionPolicy(obj *resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) (reconcile.Result, error) {
	if f.OnReconcileOutlierDetectionPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileOutlierDetectionPolicy(obj)
}

func (f *OutlierDetectionPolicyReconcilerFuncs) ReconcileOutlierDetectionPolicyDeletion(req reconcile.Request) error {
	if f.OnReconcileOutlierDetectionPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileOutlierDetectionPolicyDeletion(req)
}

// Reconcile and finalize the OutlierDetectionPolicy Resource
// implemented by the user
type OutlierDetectionPolicyFinalizer interface {
	OutlierDetectionPolicyReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	OutlierDetectionPolicyFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeOutlierDetectionPolicy(obj *resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) error
}

type OutlierDetectionPolicyReconcileLoop interface {
	RunOutlierDetectionPolicyReconciler(ctx context.Context, rec OutlierDetectionPolicyReconciler, predicates ...predicate.Predicate) error
}

type outlierDetectionPolicyReconcileLoop struct {
	loop reconcile.Loop
}

func NewOutlierDetectionPolicyReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) OutlierDetectionPolicyReconcileLoop {
	return &outlierDetectionPolicyReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy{}, options),
	}
}

func (c *outlierDetectionPolicyReconcileLoop) RunOutlierDetectionPolicyReconciler(ctx context.Context, reconciler OutlierDetectionPolicyReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericOutlierDetectionPolicyReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(OutlierDetectionPolicyFinalizer); ok {
		reconcilerWrapper = genericOutlierDetectionPolicyFinalizer{
			genericOutlierDetectionPolicyReconciler: genericReconciler,
			finalizingReconciler:                    finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericOutlierDetectionPolicyHandler implements a generic reconcile.Reconciler
type genericOutlierDetectionPolicyReconciler struct {
	reconciler OutlierDetectionPolicyReconciler
}

func (r genericOutlierDetectionPolicyReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: OutlierDetectionPolicy handler received event for %T", object)
	}
	return r.reconciler.ReconcileOutlierDetectionPolicy(obj)
}

func (r genericOutlierDetectionPolicyReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(OutlierDetectionPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileOutlierDetectionPolicyDeletion(request)
	}
	return nil
}

// genericOutlierDetectionPolicyFinalizer implements a generic reconcile.FinalizingReconciler
type genericOutlierDetectionPolicyFinalizer struct {
	genericOutlierDetectionPolicyReconciler
	finalizingReconciler OutlierDetectionPolicyFinalizer
}

func (r genericOutlierDetectionPolicyFinalizer) FinalizerName() string {
	return r.finalizingReconciler.OutlierDetectionPolicyFinalizerName()
}

func (r genericOutlierDetectionPolicyFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy)
	if !ok {
		return errors.Errorf("internal error: OutlierDetectionPolicy handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeOutlierDetectionPolicy(obj)
}

// Reconcile Upsert events for the AdaptiveRequestConcurrencyPolicy Resource.
// implemented by the user
type AdaptiveRequestConcurrencyPolicyReconciler interface {
	ReconcileAdaptiveRequestConcurrencyPolicy(obj *resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the AdaptiveRequestConcurrencyPolicy Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type AdaptiveRequestConcurrencyPolicyDeletionReconciler interface {
	ReconcileAdaptiveRequestConcurrencyPolicyDeletion(req reconcile.Request) error
}

type AdaptiveRequestConcurrencyPolicyReconcilerFuncs struct {
	OnReconcileAdaptiveRequestConcurrencyPolicy         func(obj *resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy) (reconcile.Result, error)
	OnReconcileAdaptiveRequestConcurrencyPolicyDeletion func(req reconcile.Request) error
}

func (f *AdaptiveRequestConcurrencyPolicyReconcilerFuncs) ReconcileAdaptiveRequestConcurrencyPolicy(obj *resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy) (reconcile.Result, error) {
	if f.OnReconcileAdaptiveRequestConcurrencyPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileAdaptiveRequestConcurrencyPolicy(obj)
}

func (f *AdaptiveRequestConcurrencyPolicyReconcilerFuncs) ReconcileAdaptiveRequestConcurrencyPolicyDeletion(req reconcile.Request) error {
	if f.OnReconcileAdaptiveRequestConcurrencyPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileAdaptiveRequestConcurrencyPolicyDeletion(req)
}

// Reconcile and finalize the AdaptiveRequestConcurrencyPolicy Resource
// implemented by the user
type AdaptiveRequestConcurrencyPolicyFinalizer interface {
	AdaptiveRequestConcurrencyPolicyReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	AdaptiveRequestConcurrencyPolicyFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeAdaptiveRequestConcurrencyPolicy(obj *resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy) error
}

type AdaptiveRequestConcurrencyPolicyReconcileLoop interface {
	RunAdaptiveRequestConcurrencyPolicyReconciler(ctx context.Context, rec AdaptiveRequestConcurrencyPolicyReconciler, predicates ...predicate.Predicate) error
}

type adaptiveRequestConcurrencyPolicyReconcileLoop struct {
	loop reconcile.Loop
}

func NewAdaptiveRequestConcurrencyPolicyReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) AdaptiveRequestConcurrencyPolicyReconcileLoop {
	return &adaptiveRequestConcurrencyPolicyReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy{}, options),
	}
}

func (c *adaptiveRequestConcurrencyPolicyReconcileLoop) RunAdaptiveRequestConcurrencyPolicyReconciler(ctx context.Context, reconciler AdaptiveRequestConcurrencyPolicyReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericAdaptiveRequestConcurrencyPolicyReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(AdaptiveRequestConcurrencyPolicyFinalizer); ok {
		reconcilerWrapper = genericAdaptiveRequestConcurrencyPolicyFinalizer{
			genericAdaptiveRequestConcurrencyPolicyReconciler: genericReconciler,
			finalizingReconciler:                              finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericAdaptiveRequestConcurrencyPolicyHandler implements a generic reconcile.Reconciler
type genericAdaptiveRequestConcurrencyPolicyReconciler struct {
	reconciler AdaptiveRequestConcurrencyPolicyReconciler
}

func (r genericAdaptiveRequestConcurrencyPolicyReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: AdaptiveRequestConcurrencyPolicy handler received event for %T", object)
	}
	return r.reconciler.ReconcileAdaptiveRequestConcurrencyPolicy(obj)
}

func (r genericAdaptiveRequestConcurrencyPolicyReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(AdaptiveRequestConcurrencyPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileAdaptiveRequestConcurrencyPolicyDeletion(request)
	}
	return nil
}

// genericAdaptiveRequestConcurrencyPolicyFinalizer implements a generic reconcile.FinalizingReconciler
type genericAdaptiveRequestConcurrencyPolicyFinalizer struct {
	genericAdaptiveRequestConcurrencyPolicyReconciler
	finalizingReconciler AdaptiveRequestConcurrencyPolicyFinalizer
}

func (r genericAdaptiveRequestConcurrencyPolicyFinalizer) FinalizerName() string {
	return r.finalizingReconciler.AdaptiveRequestConcurrencyPolicyFinalizerName()
}

func (r genericAdaptiveRequestConcurrencyPolicyFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy)
	if !ok {
		return errors.Errorf("internal error: AdaptiveRequestConcurrencyPolicy handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeAdaptiveRequestConcurrencyPolicy(obj)
}

// Reconcile Upsert events for the FaultInjectionPolicy Resource.
// implemented by the user
type FaultInjectionPolicyReconciler interface {
	ReconcileFaultInjectionPolicy(obj *resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the FaultInjectionPolicy Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type FaultInjectionPolicyDeletionReconciler interface {
	ReconcileFaultInjectionPolicyDeletion(req reconcile.Request) error
}

type FaultInjectionPolicyReconcilerFuncs struct {
	OnReconcileFaultInjectionPolicy         func(obj *resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) (reconcile.Result, error)
	OnReconcileFaultInjectionPolicyDeletion func(req reconcile.Request) error
}

func (f *FaultInjectionPolicyReconcilerFuncs) ReconcileFaultInjectionPolicy(obj *resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) (reconcile.Result, error) {
	if f.OnReconcileFaultInjectionPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileFaultInjectionPolicy(obj)
}

func (f *FaultInjectionPolicyReconcilerFuncs) ReconcileFaultInjectionPolicyDeletion(req reconcile.Request) error {
	if f.OnReconcileFaultInjectionPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileFaultInjectionPolicyDeletion(req)
}

// Reconcile and finalize the FaultInjectionPolicy Resource
// implemented by the user
type FaultInjectionPolicyFinalizer interface {
	FaultInjectionPolicyReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	FaultInjectionPolicyFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeFaultInjectionPolicy(obj *resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) error
}

type FaultInjectionPolicyReconcileLoop interface {
	RunFaultInjectionPolicyReconciler(ctx context.Context, rec FaultInjectionPolicyReconciler, predicates ...predicate.Predicate) error
}

type faultInjectionPolicyReconcileLoop struct {
	loop reconcile.Loop
}

func NewFaultInjectionPolicyReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) FaultInjectionPolicyReconcileLoop {
	return &faultInjectionPolicyReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy{}, options),
	}
}

func (c *faultInjectionPolicyReconcileLoop) RunFaultInjectionPolicyReconciler(ctx context.Context, reconciler FaultInjectionPolicyReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericFaultInjectionPolicyReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(FaultInjectionPolicyFinalizer); ok {
		reconcilerWrapper = genericFaultInjectionPolicyFinalizer{
			genericFaultInjectionPolicyReconciler: genericReconciler,
			finalizingReconciler:                  finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericFaultInjectionPolicyHandler implements a generic reconcile.Reconciler
type genericFaultInjectionPolicyReconciler struct {
	reconciler FaultInjectionPolicyReconciler
}

func (r genericFaultInjectionPolicyReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: FaultInjectionPolicy handler received event for %T", object)
	}
	return r.reconciler.ReconcileFaultInjectionPolicy(obj)
}

func (r genericFaultInjectionPolicyReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(FaultInjectionPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileFaultInjectionPolicyDeletion(request)
	}
	return nil
}

// genericFaultInjectionPolicyFinalizer implements a generic reconcile.FinalizingReconciler
type genericFaultInjectionPolicyFinalizer struct {
	genericFaultInjectionPolicyReconciler
	finalizingReconciler FaultInjectionPolicyFinalizer
}

func (r genericFaultInjectionPolicyFinalizer) FinalizerName() string {
	return r.finalizingReconciler.FaultInjectionPolicyFinalizerName()
}

func (r genericFaultInjectionPolicyFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy)
	if !ok {
		return errors.Errorf("internal error: FaultInjectionPolicy handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeFaultInjectionPolicy(obj)
}

// Reconcile Upsert events for the RetryTimeoutPolicy Resource.
// implemented by the user
type RetryTimeoutPolicyReconciler interface {
	ReconcileRetryTimeoutPolicy(obj *resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the RetryTimeoutPolicy Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type RetryTimeoutPolicyDeletionReconciler interface {
	ReconcileRetryTimeoutPolicyDeletion(req reconcile.Request) error
}

type RetryTimeoutPolicyReconcilerFuncs struct {
	OnReconcileRetryTimeoutPolicy         func(obj *resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) (reconcile.Result, error)
	OnReconcileRetryTimeoutPolicyDeletion func(req reconcile.Request) error
}

func (f *RetryTimeoutPolicyReconcilerFuncs) ReconcileRetryTimeoutPolicy(obj *resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) (reconcile.Result, error) {
	if f.OnReconcileRetryTimeoutPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileRetryTimeoutPolicy(obj)
}

func (f *RetryTimeoutPolicyReconcilerFuncs) ReconcileRetryTimeoutPolicyDeletion(req reconcile.Request) error {
	if f.OnReconcileRetryTimeoutPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileRetryTimeoutPolicyDeletion(req)
}

// Reconcile and finalize the RetryTimeoutPolicy Resource
// implemented by the user
type RetryTimeoutPolicyFinalizer interface {
	RetryTimeoutPolicyReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	RetryTimeoutPolicyFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeRetryTimeoutPolicy(obj *resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) error
}

type RetryTimeoutPolicyReconcileLoop interface {
	RunRetryTimeoutPolicyReconciler(ctx context.Context, rec RetryTimeoutPolicyReconciler, predicates ...predicate.Predicate) error
}

type retryTimeoutPolicyReconcileLoop struct {
	loop reconcile.Loop
}

func NewRetryTimeoutPolicyReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) RetryTimeoutPolicyReconcileLoop {
	return &retryTimeoutPolicyReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy{}, options),
	}
}

func (c *retryTimeoutPolicyReconcileLoop) RunRetryTimeoutPolicyReconciler(ctx context.Context, reconciler RetryTimeoutPolicyReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericRetryTimeoutPolicyReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(RetryTimeoutPolicyFinalizer); ok {
		reconcilerWrapper = genericRetryTimeoutPolicyFinalizer{
			genericRetryTimeoutPolicyReconciler: genericReconciler,
			finalizingReconciler:                finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericRetryTimeoutPolicyHandler implements a generic reconcile.Reconciler
type genericRetryTimeoutPolicyReconciler struct {
	reconciler RetryTimeoutPolicyReconciler
}

func (r genericRetryTimeoutPolicyReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: RetryTimeoutPolicy handler received event for %T", object)
	}
	return r.reconciler.ReconcileRetryTimeoutPolicy(obj)
}

func (r genericRetryTimeoutPolicyReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(RetryTimeoutPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileRetryTimeoutPolicyDeletion(request)
	}
	return nil
}

// genericRetryTimeoutPolicyFinalizer implements a generic reconcile.FinalizingReconciler
type genericRetryTimeoutPolicyFinalizer struct {
	genericRetryTimeoutPolicyReconciler
	finalizingReconciler RetryTimeoutPolicyFinalizer
}

func (r genericRetryTimeoutPolicyFinalizer) FinalizerName() string {
	return r.finalizingReconciler.RetryTimeoutPolicyFinalizerName()
}

func (r genericRetryTimeoutPolicyFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy)
	if !ok {
		return errors.Errorf("internal error: RetryTimeoutPolicy handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeRetryTimeoutPolicy(obj)
}

// Reconcile Upsert events for the ConnectionPolicy Resource.
// implemented by the user
type ConnectionPolicyReconciler interface {
	ReconcileConnectionPolicy(obj *resilience_policy_gloo_solo_io_v2.ConnectionPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the ConnectionPolicy Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type ConnectionPolicyDeletionReconciler interface {
	ReconcileConnectionPolicyDeletion(req reconcile.Request) error
}

type ConnectionPolicyReconcilerFuncs struct {
	OnReconcileConnectionPolicy         func(obj *resilience_policy_gloo_solo_io_v2.ConnectionPolicy) (reconcile.Result, error)
	OnReconcileConnectionPolicyDeletion func(req reconcile.Request) error
}

func (f *ConnectionPolicyReconcilerFuncs) ReconcileConnectionPolicy(obj *resilience_policy_gloo_solo_io_v2.ConnectionPolicy) (reconcile.Result, error) {
	if f.OnReconcileConnectionPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileConnectionPolicy(obj)
}

func (f *ConnectionPolicyReconcilerFuncs) ReconcileConnectionPolicyDeletion(req reconcile.Request) error {
	if f.OnReconcileConnectionPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileConnectionPolicyDeletion(req)
}

// Reconcile and finalize the ConnectionPolicy Resource
// implemented by the user
type ConnectionPolicyFinalizer interface {
	ConnectionPolicyReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	ConnectionPolicyFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeConnectionPolicy(obj *resilience_policy_gloo_solo_io_v2.ConnectionPolicy) error
}

type ConnectionPolicyReconcileLoop interface {
	RunConnectionPolicyReconciler(ctx context.Context, rec ConnectionPolicyReconciler, predicates ...predicate.Predicate) error
}

type connectionPolicyReconcileLoop struct {
	loop reconcile.Loop
}

func NewConnectionPolicyReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) ConnectionPolicyReconcileLoop {
	return &connectionPolicyReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &resilience_policy_gloo_solo_io_v2.ConnectionPolicy{}, options),
	}
}

func (c *connectionPolicyReconcileLoop) RunConnectionPolicyReconciler(ctx context.Context, reconciler ConnectionPolicyReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericConnectionPolicyReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(ConnectionPolicyFinalizer); ok {
		reconcilerWrapper = genericConnectionPolicyFinalizer{
			genericConnectionPolicyReconciler: genericReconciler,
			finalizingReconciler:              finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericConnectionPolicyHandler implements a generic reconcile.Reconciler
type genericConnectionPolicyReconciler struct {
	reconciler ConnectionPolicyReconciler
}

func (r genericConnectionPolicyReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: ConnectionPolicy handler received event for %T", object)
	}
	return r.reconciler.ReconcileConnectionPolicy(obj)
}

func (r genericConnectionPolicyReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(ConnectionPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileConnectionPolicyDeletion(request)
	}
	return nil
}

// genericConnectionPolicyFinalizer implements a generic reconcile.FinalizingReconciler
type genericConnectionPolicyFinalizer struct {
	genericConnectionPolicyReconciler
	finalizingReconciler ConnectionPolicyFinalizer
}

func (r genericConnectionPolicyFinalizer) FinalizerName() string {
	return r.finalizingReconciler.ConnectionPolicyFinalizerName()
}

func (r genericConnectionPolicyFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy)
	if !ok {
		return errors.Errorf("internal error: ConnectionPolicy handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeConnectionPolicy(obj)
}

// Reconcile Upsert events for the TrimProxyConfigPolicy Resource.
// implemented by the user
type TrimProxyConfigPolicyReconciler interface {
	ReconcileTrimProxyConfigPolicy(obj *resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the TrimProxyConfigPolicy Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type TrimProxyConfigPolicyDeletionReconciler interface {
	ReconcileTrimProxyConfigPolicyDeletion(req reconcile.Request) error
}

type TrimProxyConfigPolicyReconcilerFuncs struct {
	OnReconcileTrimProxyConfigPolicy         func(obj *resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy) (reconcile.Result, error)
	OnReconcileTrimProxyConfigPolicyDeletion func(req reconcile.Request) error
}

func (f *TrimProxyConfigPolicyReconcilerFuncs) ReconcileTrimProxyConfigPolicy(obj *resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy) (reconcile.Result, error) {
	if f.OnReconcileTrimProxyConfigPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileTrimProxyConfigPolicy(obj)
}

func (f *TrimProxyConfigPolicyReconcilerFuncs) ReconcileTrimProxyConfigPolicyDeletion(req reconcile.Request) error {
	if f.OnReconcileTrimProxyConfigPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileTrimProxyConfigPolicyDeletion(req)
}

// Reconcile and finalize the TrimProxyConfigPolicy Resource
// implemented by the user
type TrimProxyConfigPolicyFinalizer interface {
	TrimProxyConfigPolicyReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	TrimProxyConfigPolicyFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeTrimProxyConfigPolicy(obj *resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy) error
}

type TrimProxyConfigPolicyReconcileLoop interface {
	RunTrimProxyConfigPolicyReconciler(ctx context.Context, rec TrimProxyConfigPolicyReconciler, predicates ...predicate.Predicate) error
}

type trimProxyConfigPolicyReconcileLoop struct {
	loop reconcile.Loop
}

func NewTrimProxyConfigPolicyReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) TrimProxyConfigPolicyReconcileLoop {
	return &trimProxyConfigPolicyReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy{}, options),
	}
}

func (c *trimProxyConfigPolicyReconcileLoop) RunTrimProxyConfigPolicyReconciler(ctx context.Context, reconciler TrimProxyConfigPolicyReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericTrimProxyConfigPolicyReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(TrimProxyConfigPolicyFinalizer); ok {
		reconcilerWrapper = genericTrimProxyConfigPolicyFinalizer{
			genericTrimProxyConfigPolicyReconciler: genericReconciler,
			finalizingReconciler:                   finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericTrimProxyConfigPolicyHandler implements a generic reconcile.Reconciler
type genericTrimProxyConfigPolicyReconciler struct {
	reconciler TrimProxyConfigPolicyReconciler
}

func (r genericTrimProxyConfigPolicyReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: TrimProxyConfigPolicy handler received event for %T", object)
	}
	return r.reconciler.ReconcileTrimProxyConfigPolicy(obj)
}

func (r genericTrimProxyConfigPolicyReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(TrimProxyConfigPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileTrimProxyConfigPolicyDeletion(request)
	}
	return nil
}

// genericTrimProxyConfigPolicyFinalizer implements a generic reconcile.FinalizingReconciler
type genericTrimProxyConfigPolicyFinalizer struct {
	genericTrimProxyConfigPolicyReconciler
	finalizingReconciler TrimProxyConfigPolicyFinalizer
}

func (r genericTrimProxyConfigPolicyFinalizer) FinalizerName() string {
	return r.finalizingReconciler.TrimProxyConfigPolicyFinalizerName()
}

func (r genericTrimProxyConfigPolicyFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy)
	if !ok {
		return errors.Errorf("internal error: TrimProxyConfigPolicy handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeTrimProxyConfigPolicy(obj)
}

// Reconcile Upsert events for the ActiveHealthCheckPolicy Resource.
// implemented by the user
type ActiveHealthCheckPolicyReconciler interface {
	ReconcileActiveHealthCheckPolicy(obj *resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the ActiveHealthCheckPolicy Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type ActiveHealthCheckPolicyDeletionReconciler interface {
	ReconcileActiveHealthCheckPolicyDeletion(req reconcile.Request) error
}

type ActiveHealthCheckPolicyReconcilerFuncs struct {
	OnReconcileActiveHealthCheckPolicy         func(obj *resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy) (reconcile.Result, error)
	OnReconcileActiveHealthCheckPolicyDeletion func(req reconcile.Request) error
}

func (f *ActiveHealthCheckPolicyReconcilerFuncs) ReconcileActiveHealthCheckPolicy(obj *resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy) (reconcile.Result, error) {
	if f.OnReconcileActiveHealthCheckPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileActiveHealthCheckPolicy(obj)
}

func (f *ActiveHealthCheckPolicyReconcilerFuncs) ReconcileActiveHealthCheckPolicyDeletion(req reconcile.Request) error {
	if f.OnReconcileActiveHealthCheckPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileActiveHealthCheckPolicyDeletion(req)
}

// Reconcile and finalize the ActiveHealthCheckPolicy Resource
// implemented by the user
type ActiveHealthCheckPolicyFinalizer interface {
	ActiveHealthCheckPolicyReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	ActiveHealthCheckPolicyFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeActiveHealthCheckPolicy(obj *resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy) error
}

type ActiveHealthCheckPolicyReconcileLoop interface {
	RunActiveHealthCheckPolicyReconciler(ctx context.Context, rec ActiveHealthCheckPolicyReconciler, predicates ...predicate.Predicate) error
}

type activeHealthCheckPolicyReconcileLoop struct {
	loop reconcile.Loop
}

func NewActiveHealthCheckPolicyReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) ActiveHealthCheckPolicyReconcileLoop {
	return &activeHealthCheckPolicyReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy{}, options),
	}
}

func (c *activeHealthCheckPolicyReconcileLoop) RunActiveHealthCheckPolicyReconciler(ctx context.Context, reconciler ActiveHealthCheckPolicyReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericActiveHealthCheckPolicyReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(ActiveHealthCheckPolicyFinalizer); ok {
		reconcilerWrapper = genericActiveHealthCheckPolicyFinalizer{
			genericActiveHealthCheckPolicyReconciler: genericReconciler,
			finalizingReconciler:                     finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericActiveHealthCheckPolicyHandler implements a generic reconcile.Reconciler
type genericActiveHealthCheckPolicyReconciler struct {
	reconciler ActiveHealthCheckPolicyReconciler
}

func (r genericActiveHealthCheckPolicyReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: ActiveHealthCheckPolicy handler received event for %T", object)
	}
	return r.reconciler.ReconcileActiveHealthCheckPolicy(obj)
}

func (r genericActiveHealthCheckPolicyReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(ActiveHealthCheckPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileActiveHealthCheckPolicyDeletion(request)
	}
	return nil
}

// genericActiveHealthCheckPolicyFinalizer implements a generic reconcile.FinalizingReconciler
type genericActiveHealthCheckPolicyFinalizer struct {
	genericActiveHealthCheckPolicyReconciler
	finalizingReconciler ActiveHealthCheckPolicyFinalizer
}

func (r genericActiveHealthCheckPolicyFinalizer) FinalizerName() string {
	return r.finalizingReconciler.ActiveHealthCheckPolicyFinalizerName()
}

func (r genericActiveHealthCheckPolicyFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy)
	if !ok {
		return errors.Errorf("internal error: ActiveHealthCheckPolicy handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeActiveHealthCheckPolicy(obj)
}

// Reconcile Upsert events for the ListenerConnectionPolicy Resource.
// implemented by the user
type ListenerConnectionPolicyReconciler interface {
	ReconcileListenerConnectionPolicy(obj *resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the ListenerConnectionPolicy Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type ListenerConnectionPolicyDeletionReconciler interface {
	ReconcileListenerConnectionPolicyDeletion(req reconcile.Request) error
}

type ListenerConnectionPolicyReconcilerFuncs struct {
	OnReconcileListenerConnectionPolicy         func(obj *resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy) (reconcile.Result, error)
	OnReconcileListenerConnectionPolicyDeletion func(req reconcile.Request) error
}

func (f *ListenerConnectionPolicyReconcilerFuncs) ReconcileListenerConnectionPolicy(obj *resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy) (reconcile.Result, error) {
	if f.OnReconcileListenerConnectionPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileListenerConnectionPolicy(obj)
}

func (f *ListenerConnectionPolicyReconcilerFuncs) ReconcileListenerConnectionPolicyDeletion(req reconcile.Request) error {
	if f.OnReconcileListenerConnectionPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileListenerConnectionPolicyDeletion(req)
}

// Reconcile and finalize the ListenerConnectionPolicy Resource
// implemented by the user
type ListenerConnectionPolicyFinalizer interface {
	ListenerConnectionPolicyReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	ListenerConnectionPolicyFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeListenerConnectionPolicy(obj *resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy) error
}

type ListenerConnectionPolicyReconcileLoop interface {
	RunListenerConnectionPolicyReconciler(ctx context.Context, rec ListenerConnectionPolicyReconciler, predicates ...predicate.Predicate) error
}

type listenerConnectionPolicyReconcileLoop struct {
	loop reconcile.Loop
}

func NewListenerConnectionPolicyReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) ListenerConnectionPolicyReconcileLoop {
	return &listenerConnectionPolicyReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy{}, options),
	}
}

func (c *listenerConnectionPolicyReconcileLoop) RunListenerConnectionPolicyReconciler(ctx context.Context, reconciler ListenerConnectionPolicyReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericListenerConnectionPolicyReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(ListenerConnectionPolicyFinalizer); ok {
		reconcilerWrapper = genericListenerConnectionPolicyFinalizer{
			genericListenerConnectionPolicyReconciler: genericReconciler,
			finalizingReconciler:                      finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericListenerConnectionPolicyHandler implements a generic reconcile.Reconciler
type genericListenerConnectionPolicyReconciler struct {
	reconciler ListenerConnectionPolicyReconciler
}

func (r genericListenerConnectionPolicyReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: ListenerConnectionPolicy handler received event for %T", object)
	}
	return r.reconciler.ReconcileListenerConnectionPolicy(obj)
}

func (r genericListenerConnectionPolicyReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(ListenerConnectionPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileListenerConnectionPolicyDeletion(request)
	}
	return nil
}

// genericListenerConnectionPolicyFinalizer implements a generic reconcile.FinalizingReconciler
type genericListenerConnectionPolicyFinalizer struct {
	genericListenerConnectionPolicyReconciler
	finalizingReconciler ListenerConnectionPolicyFinalizer
}

func (r genericListenerConnectionPolicyFinalizer) FinalizerName() string {
	return r.finalizingReconciler.ListenerConnectionPolicyFinalizerName()
}

func (r genericListenerConnectionPolicyFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy)
	if !ok {
		return errors.Errorf("internal error: ListenerConnectionPolicy handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeListenerConnectionPolicy(obj)
}
