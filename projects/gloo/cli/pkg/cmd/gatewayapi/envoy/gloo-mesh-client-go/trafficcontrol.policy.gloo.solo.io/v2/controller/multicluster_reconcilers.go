// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./multicluster_reconcilers.go -destination mocks/multicluster_reconcilers.go

// Definitions for the multicluster Kubernetes Controllers
package controller

import (
	"context"

	trafficcontrol_policy_gloo_solo_io_v2 "github.com/solo-io/gloo/projects/gloo/cli/pkg/cmd/gatewayapi/envoy/gloo-mesh-client-go/trafficcontrol.policy.gloo.solo.io/v2"

	"github.com/pkg/errors"
	"github.com/solo-io/skv2/pkg/ezkube"
	"github.com/solo-io/skv2/pkg/multicluster"
	mc_reconcile "github.com/solo-io/skv2/pkg/multicluster/reconcile"
	"github.com/solo-io/skv2/pkg/reconcile"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
)

// Reconcile Upsert events for the MirrorPolicy Resource across clusters.
// implemented by the user
type MulticlusterMirrorPolicyReconciler interface {
	ReconcileMirrorPolicy(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.MirrorPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the MirrorPolicy Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterMirrorPolicyDeletionReconciler interface {
	ReconcileMirrorPolicyDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterMirrorPolicyReconcilerFuncs struct {
	OnReconcileMirrorPolicy         func(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.MirrorPolicy) (reconcile.Result, error)
	OnReconcileMirrorPolicyDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterMirrorPolicyReconcilerFuncs) ReconcileMirrorPolicy(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.MirrorPolicy) (reconcile.Result, error) {
	if f.OnReconcileMirrorPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileMirrorPolicy(clusterName, obj)
}

func (f *MulticlusterMirrorPolicyReconcilerFuncs) ReconcileMirrorPolicyDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileMirrorPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileMirrorPolicyDeletion(clusterName, req)
}

type MulticlusterMirrorPolicyReconcileLoop interface {
	// AddMulticlusterMirrorPolicyReconciler adds a MulticlusterMirrorPolicyReconciler to the MulticlusterMirrorPolicyReconcileLoop.
	AddMulticlusterMirrorPolicyReconciler(ctx context.Context, rec MulticlusterMirrorPolicyReconciler, predicates ...predicate.Predicate)
}

type multiclusterMirrorPolicyReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterMirrorPolicyReconcileLoop) AddMulticlusterMirrorPolicyReconciler(ctx context.Context, rec MulticlusterMirrorPolicyReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericMirrorPolicyMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterMirrorPolicyReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterMirrorPolicyReconcileLoop {
	return &multiclusterMirrorPolicyReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &trafficcontrol_policy_gloo_solo_io_v2.MirrorPolicy{}, options)}
}

type genericMirrorPolicyMulticlusterReconciler struct {
	reconciler MulticlusterMirrorPolicyReconciler
}

func (g genericMirrorPolicyMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterMirrorPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileMirrorPolicyDeletion(cluster, req)
	}
	return nil
}

func (g genericMirrorPolicyMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*trafficcontrol_policy_gloo_solo_io_v2.MirrorPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: MirrorPolicy handler received event for %T", object)
	}
	return g.reconciler.ReconcileMirrorPolicy(cluster, obj)
}

// Reconcile Upsert events for the RateLimitPolicy Resource across clusters.
// implemented by the user
type MulticlusterRateLimitPolicyReconciler interface {
	ReconcileRateLimitPolicy(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.RateLimitPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the RateLimitPolicy Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterRateLimitPolicyDeletionReconciler interface {
	ReconcileRateLimitPolicyDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterRateLimitPolicyReconcilerFuncs struct {
	OnReconcileRateLimitPolicy         func(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.RateLimitPolicy) (reconcile.Result, error)
	OnReconcileRateLimitPolicyDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterRateLimitPolicyReconcilerFuncs) ReconcileRateLimitPolicy(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.RateLimitPolicy) (reconcile.Result, error) {
	if f.OnReconcileRateLimitPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileRateLimitPolicy(clusterName, obj)
}

func (f *MulticlusterRateLimitPolicyReconcilerFuncs) ReconcileRateLimitPolicyDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileRateLimitPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileRateLimitPolicyDeletion(clusterName, req)
}

type MulticlusterRateLimitPolicyReconcileLoop interface {
	// AddMulticlusterRateLimitPolicyReconciler adds a MulticlusterRateLimitPolicyReconciler to the MulticlusterRateLimitPolicyReconcileLoop.
	AddMulticlusterRateLimitPolicyReconciler(ctx context.Context, rec MulticlusterRateLimitPolicyReconciler, predicates ...predicate.Predicate)
}

type multiclusterRateLimitPolicyReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterRateLimitPolicyReconcileLoop) AddMulticlusterRateLimitPolicyReconciler(ctx context.Context, rec MulticlusterRateLimitPolicyReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericRateLimitPolicyMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterRateLimitPolicyReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterRateLimitPolicyReconcileLoop {
	return &multiclusterRateLimitPolicyReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &trafficcontrol_policy_gloo_solo_io_v2.RateLimitPolicy{}, options)}
}

type genericRateLimitPolicyMulticlusterReconciler struct {
	reconciler MulticlusterRateLimitPolicyReconciler
}

func (g genericRateLimitPolicyMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterRateLimitPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileRateLimitPolicyDeletion(cluster, req)
	}
	return nil
}

func (g genericRateLimitPolicyMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*trafficcontrol_policy_gloo_solo_io_v2.RateLimitPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: RateLimitPolicy handler received event for %T", object)
	}
	return g.reconciler.ReconcileRateLimitPolicy(cluster, obj)
}

// Reconcile Upsert events for the RateLimitClientConfig Resource across clusters.
// implemented by the user
type MulticlusterRateLimitClientConfigReconciler interface {
	ReconcileRateLimitClientConfig(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.RateLimitClientConfig) (reconcile.Result, error)
}

// Reconcile deletion events for the RateLimitClientConfig Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterRateLimitClientConfigDeletionReconciler interface {
	ReconcileRateLimitClientConfigDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterRateLimitClientConfigReconcilerFuncs struct {
	OnReconcileRateLimitClientConfig         func(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.RateLimitClientConfig) (reconcile.Result, error)
	OnReconcileRateLimitClientConfigDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterRateLimitClientConfigReconcilerFuncs) ReconcileRateLimitClientConfig(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.RateLimitClientConfig) (reconcile.Result, error) {
	if f.OnReconcileRateLimitClientConfig == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileRateLimitClientConfig(clusterName, obj)
}

func (f *MulticlusterRateLimitClientConfigReconcilerFuncs) ReconcileRateLimitClientConfigDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileRateLimitClientConfigDeletion == nil {
		return nil
	}
	return f.OnReconcileRateLimitClientConfigDeletion(clusterName, req)
}

type MulticlusterRateLimitClientConfigReconcileLoop interface {
	// AddMulticlusterRateLimitClientConfigReconciler adds a MulticlusterRateLimitClientConfigReconciler to the MulticlusterRateLimitClientConfigReconcileLoop.
	AddMulticlusterRateLimitClientConfigReconciler(ctx context.Context, rec MulticlusterRateLimitClientConfigReconciler, predicates ...predicate.Predicate)
}

type multiclusterRateLimitClientConfigReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterRateLimitClientConfigReconcileLoop) AddMulticlusterRateLimitClientConfigReconciler(ctx context.Context, rec MulticlusterRateLimitClientConfigReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericRateLimitClientConfigMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterRateLimitClientConfigReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterRateLimitClientConfigReconcileLoop {
	return &multiclusterRateLimitClientConfigReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &trafficcontrol_policy_gloo_solo_io_v2.RateLimitClientConfig{}, options)}
}

type genericRateLimitClientConfigMulticlusterReconciler struct {
	reconciler MulticlusterRateLimitClientConfigReconciler
}

func (g genericRateLimitClientConfigMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterRateLimitClientConfigDeletionReconciler); ok {
		return deletionReconciler.ReconcileRateLimitClientConfigDeletion(cluster, req)
	}
	return nil
}

func (g genericRateLimitClientConfigMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*trafficcontrol_policy_gloo_solo_io_v2.RateLimitClientConfig)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: RateLimitClientConfig handler received event for %T", object)
	}
	return g.reconciler.ReconcileRateLimitClientConfig(cluster, obj)
}

// Reconcile Upsert events for the HeaderManipulationPolicy Resource across clusters.
// implemented by the user
type MulticlusterHeaderManipulationPolicyReconciler interface {
	ReconcileHeaderManipulationPolicy(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.HeaderManipulationPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the HeaderManipulationPolicy Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterHeaderManipulationPolicyDeletionReconciler interface {
	ReconcileHeaderManipulationPolicyDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterHeaderManipulationPolicyReconcilerFuncs struct {
	OnReconcileHeaderManipulationPolicy         func(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.HeaderManipulationPolicy) (reconcile.Result, error)
	OnReconcileHeaderManipulationPolicyDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterHeaderManipulationPolicyReconcilerFuncs) ReconcileHeaderManipulationPolicy(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.HeaderManipulationPolicy) (reconcile.Result, error) {
	if f.OnReconcileHeaderManipulationPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileHeaderManipulationPolicy(clusterName, obj)
}

func (f *MulticlusterHeaderManipulationPolicyReconcilerFuncs) ReconcileHeaderManipulationPolicyDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileHeaderManipulationPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileHeaderManipulationPolicyDeletion(clusterName, req)
}

type MulticlusterHeaderManipulationPolicyReconcileLoop interface {
	// AddMulticlusterHeaderManipulationPolicyReconciler adds a MulticlusterHeaderManipulationPolicyReconciler to the MulticlusterHeaderManipulationPolicyReconcileLoop.
	AddMulticlusterHeaderManipulationPolicyReconciler(ctx context.Context, rec MulticlusterHeaderManipulationPolicyReconciler, predicates ...predicate.Predicate)
}

type multiclusterHeaderManipulationPolicyReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterHeaderManipulationPolicyReconcileLoop) AddMulticlusterHeaderManipulationPolicyReconciler(ctx context.Context, rec MulticlusterHeaderManipulationPolicyReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericHeaderManipulationPolicyMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterHeaderManipulationPolicyReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterHeaderManipulationPolicyReconcileLoop {
	return &multiclusterHeaderManipulationPolicyReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &trafficcontrol_policy_gloo_solo_io_v2.HeaderManipulationPolicy{}, options)}
}

type genericHeaderManipulationPolicyMulticlusterReconciler struct {
	reconciler MulticlusterHeaderManipulationPolicyReconciler
}

func (g genericHeaderManipulationPolicyMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterHeaderManipulationPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileHeaderManipulationPolicyDeletion(cluster, req)
	}
	return nil
}

func (g genericHeaderManipulationPolicyMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*trafficcontrol_policy_gloo_solo_io_v2.HeaderManipulationPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: HeaderManipulationPolicy handler received event for %T", object)
	}
	return g.reconciler.ReconcileHeaderManipulationPolicy(cluster, obj)
}

// Reconcile Upsert events for the TransformationPolicy Resource across clusters.
// implemented by the user
type MulticlusterTransformationPolicyReconciler interface {
	ReconcileTransformationPolicy(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.TransformationPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the TransformationPolicy Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterTransformationPolicyDeletionReconciler interface {
	ReconcileTransformationPolicyDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterTransformationPolicyReconcilerFuncs struct {
	OnReconcileTransformationPolicy         func(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.TransformationPolicy) (reconcile.Result, error)
	OnReconcileTransformationPolicyDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterTransformationPolicyReconcilerFuncs) ReconcileTransformationPolicy(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.TransformationPolicy) (reconcile.Result, error) {
	if f.OnReconcileTransformationPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileTransformationPolicy(clusterName, obj)
}

func (f *MulticlusterTransformationPolicyReconcilerFuncs) ReconcileTransformationPolicyDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileTransformationPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileTransformationPolicyDeletion(clusterName, req)
}

type MulticlusterTransformationPolicyReconcileLoop interface {
	// AddMulticlusterTransformationPolicyReconciler adds a MulticlusterTransformationPolicyReconciler to the MulticlusterTransformationPolicyReconcileLoop.
	AddMulticlusterTransformationPolicyReconciler(ctx context.Context, rec MulticlusterTransformationPolicyReconciler, predicates ...predicate.Predicate)
}

type multiclusterTransformationPolicyReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterTransformationPolicyReconcileLoop) AddMulticlusterTransformationPolicyReconciler(ctx context.Context, rec MulticlusterTransformationPolicyReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericTransformationPolicyMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterTransformationPolicyReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterTransformationPolicyReconcileLoop {
	return &multiclusterTransformationPolicyReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &trafficcontrol_policy_gloo_solo_io_v2.TransformationPolicy{}, options)}
}

type genericTransformationPolicyMulticlusterReconciler struct {
	reconciler MulticlusterTransformationPolicyReconciler
}

func (g genericTransformationPolicyMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterTransformationPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileTransformationPolicyDeletion(cluster, req)
	}
	return nil
}

func (g genericTransformationPolicyMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*trafficcontrol_policy_gloo_solo_io_v2.TransformationPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: TransformationPolicy handler received event for %T", object)
	}
	return g.reconciler.ReconcileTransformationPolicy(cluster, obj)
}

// Reconcile Upsert events for the LoadBalancerPolicy Resource across clusters.
// implemented by the user
type MulticlusterLoadBalancerPolicyReconciler interface {
	ReconcileLoadBalancerPolicy(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.LoadBalancerPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the LoadBalancerPolicy Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterLoadBalancerPolicyDeletionReconciler interface {
	ReconcileLoadBalancerPolicyDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterLoadBalancerPolicyReconcilerFuncs struct {
	OnReconcileLoadBalancerPolicy         func(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.LoadBalancerPolicy) (reconcile.Result, error)
	OnReconcileLoadBalancerPolicyDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterLoadBalancerPolicyReconcilerFuncs) ReconcileLoadBalancerPolicy(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.LoadBalancerPolicy) (reconcile.Result, error) {
	if f.OnReconcileLoadBalancerPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileLoadBalancerPolicy(clusterName, obj)
}

func (f *MulticlusterLoadBalancerPolicyReconcilerFuncs) ReconcileLoadBalancerPolicyDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileLoadBalancerPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileLoadBalancerPolicyDeletion(clusterName, req)
}

type MulticlusterLoadBalancerPolicyReconcileLoop interface {
	// AddMulticlusterLoadBalancerPolicyReconciler adds a MulticlusterLoadBalancerPolicyReconciler to the MulticlusterLoadBalancerPolicyReconcileLoop.
	AddMulticlusterLoadBalancerPolicyReconciler(ctx context.Context, rec MulticlusterLoadBalancerPolicyReconciler, predicates ...predicate.Predicate)
}

type multiclusterLoadBalancerPolicyReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterLoadBalancerPolicyReconcileLoop) AddMulticlusterLoadBalancerPolicyReconciler(ctx context.Context, rec MulticlusterLoadBalancerPolicyReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericLoadBalancerPolicyMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterLoadBalancerPolicyReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterLoadBalancerPolicyReconcileLoop {
	return &multiclusterLoadBalancerPolicyReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &trafficcontrol_policy_gloo_solo_io_v2.LoadBalancerPolicy{}, options)}
}

type genericLoadBalancerPolicyMulticlusterReconciler struct {
	reconciler MulticlusterLoadBalancerPolicyReconciler
}

func (g genericLoadBalancerPolicyMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterLoadBalancerPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileLoadBalancerPolicyDeletion(cluster, req)
	}
	return nil
}

func (g genericLoadBalancerPolicyMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*trafficcontrol_policy_gloo_solo_io_v2.LoadBalancerPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: LoadBalancerPolicy handler received event for %T", object)
	}
	return g.reconciler.ReconcileLoadBalancerPolicy(cluster, obj)
}

// Reconcile Upsert events for the ProxyProtocolPolicy Resource across clusters.
// implemented by the user
type MulticlusterProxyProtocolPolicyReconciler interface {
	ReconcileProxyProtocolPolicy(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.ProxyProtocolPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the ProxyProtocolPolicy Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterProxyProtocolPolicyDeletionReconciler interface {
	ReconcileProxyProtocolPolicyDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterProxyProtocolPolicyReconcilerFuncs struct {
	OnReconcileProxyProtocolPolicy         func(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.ProxyProtocolPolicy) (reconcile.Result, error)
	OnReconcileProxyProtocolPolicyDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterProxyProtocolPolicyReconcilerFuncs) ReconcileProxyProtocolPolicy(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.ProxyProtocolPolicy) (reconcile.Result, error) {
	if f.OnReconcileProxyProtocolPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileProxyProtocolPolicy(clusterName, obj)
}

func (f *MulticlusterProxyProtocolPolicyReconcilerFuncs) ReconcileProxyProtocolPolicyDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileProxyProtocolPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileProxyProtocolPolicyDeletion(clusterName, req)
}

type MulticlusterProxyProtocolPolicyReconcileLoop interface {
	// AddMulticlusterProxyProtocolPolicyReconciler adds a MulticlusterProxyProtocolPolicyReconciler to the MulticlusterProxyProtocolPolicyReconcileLoop.
	AddMulticlusterProxyProtocolPolicyReconciler(ctx context.Context, rec MulticlusterProxyProtocolPolicyReconciler, predicates ...predicate.Predicate)
}

type multiclusterProxyProtocolPolicyReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterProxyProtocolPolicyReconcileLoop) AddMulticlusterProxyProtocolPolicyReconciler(ctx context.Context, rec MulticlusterProxyProtocolPolicyReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericProxyProtocolPolicyMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterProxyProtocolPolicyReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterProxyProtocolPolicyReconcileLoop {
	return &multiclusterProxyProtocolPolicyReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &trafficcontrol_policy_gloo_solo_io_v2.ProxyProtocolPolicy{}, options)}
}

type genericProxyProtocolPolicyMulticlusterReconciler struct {
	reconciler MulticlusterProxyProtocolPolicyReconciler
}

func (g genericProxyProtocolPolicyMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterProxyProtocolPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileProxyProtocolPolicyDeletion(cluster, req)
	}
	return nil
}

func (g genericProxyProtocolPolicyMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*trafficcontrol_policy_gloo_solo_io_v2.ProxyProtocolPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: ProxyProtocolPolicy handler received event for %T", object)
	}
	return g.reconciler.ReconcileProxyProtocolPolicy(cluster, obj)
}

// Reconcile Upsert events for the HTTPBufferPolicy Resource across clusters.
// implemented by the user
type MulticlusterHTTPBufferPolicyReconciler interface {
	ReconcileHTTPBufferPolicy(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.HTTPBufferPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the HTTPBufferPolicy Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterHTTPBufferPolicyDeletionReconciler interface {
	ReconcileHTTPBufferPolicyDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterHTTPBufferPolicyReconcilerFuncs struct {
	OnReconcileHTTPBufferPolicy         func(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.HTTPBufferPolicy) (reconcile.Result, error)
	OnReconcileHTTPBufferPolicyDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterHTTPBufferPolicyReconcilerFuncs) ReconcileHTTPBufferPolicy(clusterName string, obj *trafficcontrol_policy_gloo_solo_io_v2.HTTPBufferPolicy) (reconcile.Result, error) {
	if f.OnReconcileHTTPBufferPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileHTTPBufferPolicy(clusterName, obj)
}

func (f *MulticlusterHTTPBufferPolicyReconcilerFuncs) ReconcileHTTPBufferPolicyDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileHTTPBufferPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileHTTPBufferPolicyDeletion(clusterName, req)
}

type MulticlusterHTTPBufferPolicyReconcileLoop interface {
	// AddMulticlusterHTTPBufferPolicyReconciler adds a MulticlusterHTTPBufferPolicyReconciler to the MulticlusterHTTPBufferPolicyReconcileLoop.
	AddMulticlusterHTTPBufferPolicyReconciler(ctx context.Context, rec MulticlusterHTTPBufferPolicyReconciler, predicates ...predicate.Predicate)
}

type multiclusterHTTPBufferPolicyReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterHTTPBufferPolicyReconcileLoop) AddMulticlusterHTTPBufferPolicyReconciler(ctx context.Context, rec MulticlusterHTTPBufferPolicyReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericHTTPBufferPolicyMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterHTTPBufferPolicyReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterHTTPBufferPolicyReconcileLoop {
	return &multiclusterHTTPBufferPolicyReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &trafficcontrol_policy_gloo_solo_io_v2.HTTPBufferPolicy{}, options)}
}

type genericHTTPBufferPolicyMulticlusterReconciler struct {
	reconciler MulticlusterHTTPBufferPolicyReconciler
}

func (g genericHTTPBufferPolicyMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterHTTPBufferPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileHTTPBufferPolicyDeletion(cluster, req)
	}
	return nil
}

func (g genericHTTPBufferPolicyMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*trafficcontrol_policy_gloo_solo_io_v2.HTTPBufferPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: HTTPBufferPolicy handler received event for %T", object)
	}
	return g.reconciler.ReconcileHTTPBufferPolicy(cluster, obj)
}
