// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./multicluster_reconcilers.go -destination mocks/multicluster_reconcilers.go

// Definitions for the multicluster Kubernetes Controllers
package controller

import (
	"context"

	resilience_policy_gloo_solo_io_v2 "github.com/solo-io/gloo/projects/gloo/cli/pkg/cmd/gatewayapi/envoy/gloo-mesh-client-go/resilience.policy.gloo.solo.io/v2"

	"github.com/pkg/errors"
	"github.com/solo-io/skv2/pkg/ezkube"
	"github.com/solo-io/skv2/pkg/multicluster"
	mc_reconcile "github.com/solo-io/skv2/pkg/multicluster/reconcile"
	"github.com/solo-io/skv2/pkg/reconcile"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
)

// Reconcile Upsert events for the GraphQLPersistedQueryCachePolicy Resource across clusters.
// implemented by the user
type MulticlusterGraphQLPersistedQueryCachePolicyReconciler interface {
	ReconcileGraphQLPersistedQueryCachePolicy(clusterName string, obj *resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the GraphQLPersistedQueryCachePolicy Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterGraphQLPersistedQueryCachePolicyDeletionReconciler interface {
	ReconcileGraphQLPersistedQueryCachePolicyDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterGraphQLPersistedQueryCachePolicyReconcilerFuncs struct {
	OnReconcileGraphQLPersistedQueryCachePolicy         func(clusterName string, obj *resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) (reconcile.Result, error)
	OnReconcileGraphQLPersistedQueryCachePolicyDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterGraphQLPersistedQueryCachePolicyReconcilerFuncs) ReconcileGraphQLPersistedQueryCachePolicy(clusterName string, obj *resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) (reconcile.Result, error) {
	if f.OnReconcileGraphQLPersistedQueryCachePolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileGraphQLPersistedQueryCachePolicy(clusterName, obj)
}

func (f *MulticlusterGraphQLPersistedQueryCachePolicyReconcilerFuncs) ReconcileGraphQLPersistedQueryCachePolicyDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileGraphQLPersistedQueryCachePolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileGraphQLPersistedQueryCachePolicyDeletion(clusterName, req)
}

type MulticlusterGraphQLPersistedQueryCachePolicyReconcileLoop interface {
	// AddMulticlusterGraphQLPersistedQueryCachePolicyReconciler adds a MulticlusterGraphQLPersistedQueryCachePolicyReconciler to the MulticlusterGraphQLPersistedQueryCachePolicyReconcileLoop.
	AddMulticlusterGraphQLPersistedQueryCachePolicyReconciler(ctx context.Context, rec MulticlusterGraphQLPersistedQueryCachePolicyReconciler, predicates ...predicate.Predicate)
}

type multiclusterGraphQLPersistedQueryCachePolicyReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterGraphQLPersistedQueryCachePolicyReconcileLoop) AddMulticlusterGraphQLPersistedQueryCachePolicyReconciler(ctx context.Context, rec MulticlusterGraphQLPersistedQueryCachePolicyReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericGraphQLPersistedQueryCachePolicyMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterGraphQLPersistedQueryCachePolicyReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterGraphQLPersistedQueryCachePolicyReconcileLoop {
	return &multiclusterGraphQLPersistedQueryCachePolicyReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy{}, options)}
}

type genericGraphQLPersistedQueryCachePolicyMulticlusterReconciler struct {
	reconciler MulticlusterGraphQLPersistedQueryCachePolicyReconciler
}

func (g genericGraphQLPersistedQueryCachePolicyMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterGraphQLPersistedQueryCachePolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileGraphQLPersistedQueryCachePolicyDeletion(cluster, req)
	}
	return nil
}

func (g genericGraphQLPersistedQueryCachePolicyMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: GraphQLPersistedQueryCachePolicy handler received event for %T", object)
	}
	return g.reconciler.ReconcileGraphQLPersistedQueryCachePolicy(cluster, obj)
}

// Reconcile Upsert events for the FailoverPolicy Resource across clusters.
// implemented by the user
type MulticlusterFailoverPolicyReconciler interface {
	ReconcileFailoverPolicy(clusterName string, obj *resilience_policy_gloo_solo_io_v2.FailoverPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the FailoverPolicy Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterFailoverPolicyDeletionReconciler interface {
	ReconcileFailoverPolicyDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterFailoverPolicyReconcilerFuncs struct {
	OnReconcileFailoverPolicy         func(clusterName string, obj *resilience_policy_gloo_solo_io_v2.FailoverPolicy) (reconcile.Result, error)
	OnReconcileFailoverPolicyDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterFailoverPolicyReconcilerFuncs) ReconcileFailoverPolicy(clusterName string, obj *resilience_policy_gloo_solo_io_v2.FailoverPolicy) (reconcile.Result, error) {
	if f.OnReconcileFailoverPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileFailoverPolicy(clusterName, obj)
}

func (f *MulticlusterFailoverPolicyReconcilerFuncs) ReconcileFailoverPolicyDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileFailoverPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileFailoverPolicyDeletion(clusterName, req)
}

type MulticlusterFailoverPolicyReconcileLoop interface {
	// AddMulticlusterFailoverPolicyReconciler adds a MulticlusterFailoverPolicyReconciler to the MulticlusterFailoverPolicyReconcileLoop.
	AddMulticlusterFailoverPolicyReconciler(ctx context.Context, rec MulticlusterFailoverPolicyReconciler, predicates ...predicate.Predicate)
}

type multiclusterFailoverPolicyReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterFailoverPolicyReconcileLoop) AddMulticlusterFailoverPolicyReconciler(ctx context.Context, rec MulticlusterFailoverPolicyReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericFailoverPolicyMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterFailoverPolicyReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterFailoverPolicyReconcileLoop {
	return &multiclusterFailoverPolicyReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &resilience_policy_gloo_solo_io_v2.FailoverPolicy{}, options)}
}

type genericFailoverPolicyMulticlusterReconciler struct {
	reconciler MulticlusterFailoverPolicyReconciler
}

func (g genericFailoverPolicyMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterFailoverPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileFailoverPolicyDeletion(cluster, req)
	}
	return nil
}

func (g genericFailoverPolicyMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.FailoverPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: FailoverPolicy handler received event for %T", object)
	}
	return g.reconciler.ReconcileFailoverPolicy(cluster, obj)
}

// Reconcile Upsert events for the OutlierDetectionPolicy Resource across clusters.
// implemented by the user
type MulticlusterOutlierDetectionPolicyReconciler interface {
	ReconcileOutlierDetectionPolicy(clusterName string, obj *resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the OutlierDetectionPolicy Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterOutlierDetectionPolicyDeletionReconciler interface {
	ReconcileOutlierDetectionPolicyDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterOutlierDetectionPolicyReconcilerFuncs struct {
	OnReconcileOutlierDetectionPolicy         func(clusterName string, obj *resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) (reconcile.Result, error)
	OnReconcileOutlierDetectionPolicyDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterOutlierDetectionPolicyReconcilerFuncs) ReconcileOutlierDetectionPolicy(clusterName string, obj *resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) (reconcile.Result, error) {
	if f.OnReconcileOutlierDetectionPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileOutlierDetectionPolicy(clusterName, obj)
}

func (f *MulticlusterOutlierDetectionPolicyReconcilerFuncs) ReconcileOutlierDetectionPolicyDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileOutlierDetectionPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileOutlierDetectionPolicyDeletion(clusterName, req)
}

type MulticlusterOutlierDetectionPolicyReconcileLoop interface {
	// AddMulticlusterOutlierDetectionPolicyReconciler adds a MulticlusterOutlierDetectionPolicyReconciler to the MulticlusterOutlierDetectionPolicyReconcileLoop.
	AddMulticlusterOutlierDetectionPolicyReconciler(ctx context.Context, rec MulticlusterOutlierDetectionPolicyReconciler, predicates ...predicate.Predicate)
}

type multiclusterOutlierDetectionPolicyReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterOutlierDetectionPolicyReconcileLoop) AddMulticlusterOutlierDetectionPolicyReconciler(ctx context.Context, rec MulticlusterOutlierDetectionPolicyReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericOutlierDetectionPolicyMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterOutlierDetectionPolicyReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterOutlierDetectionPolicyReconcileLoop {
	return &multiclusterOutlierDetectionPolicyReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy{}, options)}
}

type genericOutlierDetectionPolicyMulticlusterReconciler struct {
	reconciler MulticlusterOutlierDetectionPolicyReconciler
}

func (g genericOutlierDetectionPolicyMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterOutlierDetectionPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileOutlierDetectionPolicyDeletion(cluster, req)
	}
	return nil
}

func (g genericOutlierDetectionPolicyMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: OutlierDetectionPolicy handler received event for %T", object)
	}
	return g.reconciler.ReconcileOutlierDetectionPolicy(cluster, obj)
}

// Reconcile Upsert events for the AdaptiveRequestConcurrencyPolicy Resource across clusters.
// implemented by the user
type MulticlusterAdaptiveRequestConcurrencyPolicyReconciler interface {
	ReconcileAdaptiveRequestConcurrencyPolicy(clusterName string, obj *resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the AdaptiveRequestConcurrencyPolicy Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterAdaptiveRequestConcurrencyPolicyDeletionReconciler interface {
	ReconcileAdaptiveRequestConcurrencyPolicyDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterAdaptiveRequestConcurrencyPolicyReconcilerFuncs struct {
	OnReconcileAdaptiveRequestConcurrencyPolicy         func(clusterName string, obj *resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy) (reconcile.Result, error)
	OnReconcileAdaptiveRequestConcurrencyPolicyDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterAdaptiveRequestConcurrencyPolicyReconcilerFuncs) ReconcileAdaptiveRequestConcurrencyPolicy(clusterName string, obj *resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy) (reconcile.Result, error) {
	if f.OnReconcileAdaptiveRequestConcurrencyPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileAdaptiveRequestConcurrencyPolicy(clusterName, obj)
}

func (f *MulticlusterAdaptiveRequestConcurrencyPolicyReconcilerFuncs) ReconcileAdaptiveRequestConcurrencyPolicyDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileAdaptiveRequestConcurrencyPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileAdaptiveRequestConcurrencyPolicyDeletion(clusterName, req)
}

type MulticlusterAdaptiveRequestConcurrencyPolicyReconcileLoop interface {
	// AddMulticlusterAdaptiveRequestConcurrencyPolicyReconciler adds a MulticlusterAdaptiveRequestConcurrencyPolicyReconciler to the MulticlusterAdaptiveRequestConcurrencyPolicyReconcileLoop.
	AddMulticlusterAdaptiveRequestConcurrencyPolicyReconciler(ctx context.Context, rec MulticlusterAdaptiveRequestConcurrencyPolicyReconciler, predicates ...predicate.Predicate)
}

type multiclusterAdaptiveRequestConcurrencyPolicyReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterAdaptiveRequestConcurrencyPolicyReconcileLoop) AddMulticlusterAdaptiveRequestConcurrencyPolicyReconciler(ctx context.Context, rec MulticlusterAdaptiveRequestConcurrencyPolicyReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericAdaptiveRequestConcurrencyPolicyMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterAdaptiveRequestConcurrencyPolicyReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterAdaptiveRequestConcurrencyPolicyReconcileLoop {
	return &multiclusterAdaptiveRequestConcurrencyPolicyReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy{}, options)}
}

type genericAdaptiveRequestConcurrencyPolicyMulticlusterReconciler struct {
	reconciler MulticlusterAdaptiveRequestConcurrencyPolicyReconciler
}

func (g genericAdaptiveRequestConcurrencyPolicyMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterAdaptiveRequestConcurrencyPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileAdaptiveRequestConcurrencyPolicyDeletion(cluster, req)
	}
	return nil
}

func (g genericAdaptiveRequestConcurrencyPolicyMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.AdaptiveRequestConcurrencyPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: AdaptiveRequestConcurrencyPolicy handler received event for %T", object)
	}
	return g.reconciler.ReconcileAdaptiveRequestConcurrencyPolicy(cluster, obj)
}

// Reconcile Upsert events for the FaultInjectionPolicy Resource across clusters.
// implemented by the user
type MulticlusterFaultInjectionPolicyReconciler interface {
	ReconcileFaultInjectionPolicy(clusterName string, obj *resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the FaultInjectionPolicy Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterFaultInjectionPolicyDeletionReconciler interface {
	ReconcileFaultInjectionPolicyDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterFaultInjectionPolicyReconcilerFuncs struct {
	OnReconcileFaultInjectionPolicy         func(clusterName string, obj *resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) (reconcile.Result, error)
	OnReconcileFaultInjectionPolicyDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterFaultInjectionPolicyReconcilerFuncs) ReconcileFaultInjectionPolicy(clusterName string, obj *resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) (reconcile.Result, error) {
	if f.OnReconcileFaultInjectionPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileFaultInjectionPolicy(clusterName, obj)
}

func (f *MulticlusterFaultInjectionPolicyReconcilerFuncs) ReconcileFaultInjectionPolicyDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileFaultInjectionPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileFaultInjectionPolicyDeletion(clusterName, req)
}

type MulticlusterFaultInjectionPolicyReconcileLoop interface {
	// AddMulticlusterFaultInjectionPolicyReconciler adds a MulticlusterFaultInjectionPolicyReconciler to the MulticlusterFaultInjectionPolicyReconcileLoop.
	AddMulticlusterFaultInjectionPolicyReconciler(ctx context.Context, rec MulticlusterFaultInjectionPolicyReconciler, predicates ...predicate.Predicate)
}

type multiclusterFaultInjectionPolicyReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterFaultInjectionPolicyReconcileLoop) AddMulticlusterFaultInjectionPolicyReconciler(ctx context.Context, rec MulticlusterFaultInjectionPolicyReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericFaultInjectionPolicyMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterFaultInjectionPolicyReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterFaultInjectionPolicyReconcileLoop {
	return &multiclusterFaultInjectionPolicyReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy{}, options)}
}

type genericFaultInjectionPolicyMulticlusterReconciler struct {
	reconciler MulticlusterFaultInjectionPolicyReconciler
}

func (g genericFaultInjectionPolicyMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterFaultInjectionPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileFaultInjectionPolicyDeletion(cluster, req)
	}
	return nil
}

func (g genericFaultInjectionPolicyMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: FaultInjectionPolicy handler received event for %T", object)
	}
	return g.reconciler.ReconcileFaultInjectionPolicy(cluster, obj)
}

// Reconcile Upsert events for the RetryTimeoutPolicy Resource across clusters.
// implemented by the user
type MulticlusterRetryTimeoutPolicyReconciler interface {
	ReconcileRetryTimeoutPolicy(clusterName string, obj *resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the RetryTimeoutPolicy Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterRetryTimeoutPolicyDeletionReconciler interface {
	ReconcileRetryTimeoutPolicyDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterRetryTimeoutPolicyReconcilerFuncs struct {
	OnReconcileRetryTimeoutPolicy         func(clusterName string, obj *resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) (reconcile.Result, error)
	OnReconcileRetryTimeoutPolicyDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterRetryTimeoutPolicyReconcilerFuncs) ReconcileRetryTimeoutPolicy(clusterName string, obj *resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) (reconcile.Result, error) {
	if f.OnReconcileRetryTimeoutPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileRetryTimeoutPolicy(clusterName, obj)
}

func (f *MulticlusterRetryTimeoutPolicyReconcilerFuncs) ReconcileRetryTimeoutPolicyDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileRetryTimeoutPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileRetryTimeoutPolicyDeletion(clusterName, req)
}

type MulticlusterRetryTimeoutPolicyReconcileLoop interface {
	// AddMulticlusterRetryTimeoutPolicyReconciler adds a MulticlusterRetryTimeoutPolicyReconciler to the MulticlusterRetryTimeoutPolicyReconcileLoop.
	AddMulticlusterRetryTimeoutPolicyReconciler(ctx context.Context, rec MulticlusterRetryTimeoutPolicyReconciler, predicates ...predicate.Predicate)
}

type multiclusterRetryTimeoutPolicyReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterRetryTimeoutPolicyReconcileLoop) AddMulticlusterRetryTimeoutPolicyReconciler(ctx context.Context, rec MulticlusterRetryTimeoutPolicyReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericRetryTimeoutPolicyMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterRetryTimeoutPolicyReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterRetryTimeoutPolicyReconcileLoop {
	return &multiclusterRetryTimeoutPolicyReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy{}, options)}
}

type genericRetryTimeoutPolicyMulticlusterReconciler struct {
	reconciler MulticlusterRetryTimeoutPolicyReconciler
}

func (g genericRetryTimeoutPolicyMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterRetryTimeoutPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileRetryTimeoutPolicyDeletion(cluster, req)
	}
	return nil
}

func (g genericRetryTimeoutPolicyMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: RetryTimeoutPolicy handler received event for %T", object)
	}
	return g.reconciler.ReconcileRetryTimeoutPolicy(cluster, obj)
}

// Reconcile Upsert events for the ConnectionPolicy Resource across clusters.
// implemented by the user
type MulticlusterConnectionPolicyReconciler interface {
	ReconcileConnectionPolicy(clusterName string, obj *resilience_policy_gloo_solo_io_v2.ConnectionPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the ConnectionPolicy Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterConnectionPolicyDeletionReconciler interface {
	ReconcileConnectionPolicyDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterConnectionPolicyReconcilerFuncs struct {
	OnReconcileConnectionPolicy         func(clusterName string, obj *resilience_policy_gloo_solo_io_v2.ConnectionPolicy) (reconcile.Result, error)
	OnReconcileConnectionPolicyDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterConnectionPolicyReconcilerFuncs) ReconcileConnectionPolicy(clusterName string, obj *resilience_policy_gloo_solo_io_v2.ConnectionPolicy) (reconcile.Result, error) {
	if f.OnReconcileConnectionPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileConnectionPolicy(clusterName, obj)
}

func (f *MulticlusterConnectionPolicyReconcilerFuncs) ReconcileConnectionPolicyDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileConnectionPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileConnectionPolicyDeletion(clusterName, req)
}

type MulticlusterConnectionPolicyReconcileLoop interface {
	// AddMulticlusterConnectionPolicyReconciler adds a MulticlusterConnectionPolicyReconciler to the MulticlusterConnectionPolicyReconcileLoop.
	AddMulticlusterConnectionPolicyReconciler(ctx context.Context, rec MulticlusterConnectionPolicyReconciler, predicates ...predicate.Predicate)
}

type multiclusterConnectionPolicyReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterConnectionPolicyReconcileLoop) AddMulticlusterConnectionPolicyReconciler(ctx context.Context, rec MulticlusterConnectionPolicyReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericConnectionPolicyMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterConnectionPolicyReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterConnectionPolicyReconcileLoop {
	return &multiclusterConnectionPolicyReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &resilience_policy_gloo_solo_io_v2.ConnectionPolicy{}, options)}
}

type genericConnectionPolicyMulticlusterReconciler struct {
	reconciler MulticlusterConnectionPolicyReconciler
}

func (g genericConnectionPolicyMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterConnectionPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileConnectionPolicyDeletion(cluster, req)
	}
	return nil
}

func (g genericConnectionPolicyMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: ConnectionPolicy handler received event for %T", object)
	}
	return g.reconciler.ReconcileConnectionPolicy(cluster, obj)
}

// Reconcile Upsert events for the TrimProxyConfigPolicy Resource across clusters.
// implemented by the user
type MulticlusterTrimProxyConfigPolicyReconciler interface {
	ReconcileTrimProxyConfigPolicy(clusterName string, obj *resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the TrimProxyConfigPolicy Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterTrimProxyConfigPolicyDeletionReconciler interface {
	ReconcileTrimProxyConfigPolicyDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterTrimProxyConfigPolicyReconcilerFuncs struct {
	OnReconcileTrimProxyConfigPolicy         func(clusterName string, obj *resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy) (reconcile.Result, error)
	OnReconcileTrimProxyConfigPolicyDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterTrimProxyConfigPolicyReconcilerFuncs) ReconcileTrimProxyConfigPolicy(clusterName string, obj *resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy) (reconcile.Result, error) {
	if f.OnReconcileTrimProxyConfigPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileTrimProxyConfigPolicy(clusterName, obj)
}

func (f *MulticlusterTrimProxyConfigPolicyReconcilerFuncs) ReconcileTrimProxyConfigPolicyDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileTrimProxyConfigPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileTrimProxyConfigPolicyDeletion(clusterName, req)
}

type MulticlusterTrimProxyConfigPolicyReconcileLoop interface {
	// AddMulticlusterTrimProxyConfigPolicyReconciler adds a MulticlusterTrimProxyConfigPolicyReconciler to the MulticlusterTrimProxyConfigPolicyReconcileLoop.
	AddMulticlusterTrimProxyConfigPolicyReconciler(ctx context.Context, rec MulticlusterTrimProxyConfigPolicyReconciler, predicates ...predicate.Predicate)
}

type multiclusterTrimProxyConfigPolicyReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterTrimProxyConfigPolicyReconcileLoop) AddMulticlusterTrimProxyConfigPolicyReconciler(ctx context.Context, rec MulticlusterTrimProxyConfigPolicyReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericTrimProxyConfigPolicyMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterTrimProxyConfigPolicyReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterTrimProxyConfigPolicyReconcileLoop {
	return &multiclusterTrimProxyConfigPolicyReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy{}, options)}
}

type genericTrimProxyConfigPolicyMulticlusterReconciler struct {
	reconciler MulticlusterTrimProxyConfigPolicyReconciler
}

func (g genericTrimProxyConfigPolicyMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterTrimProxyConfigPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileTrimProxyConfigPolicyDeletion(cluster, req)
	}
	return nil
}

func (g genericTrimProxyConfigPolicyMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.TrimProxyConfigPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: TrimProxyConfigPolicy handler received event for %T", object)
	}
	return g.reconciler.ReconcileTrimProxyConfigPolicy(cluster, obj)
}

// Reconcile Upsert events for the ActiveHealthCheckPolicy Resource across clusters.
// implemented by the user
type MulticlusterActiveHealthCheckPolicyReconciler interface {
	ReconcileActiveHealthCheckPolicy(clusterName string, obj *resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the ActiveHealthCheckPolicy Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterActiveHealthCheckPolicyDeletionReconciler interface {
	ReconcileActiveHealthCheckPolicyDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterActiveHealthCheckPolicyReconcilerFuncs struct {
	OnReconcileActiveHealthCheckPolicy         func(clusterName string, obj *resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy) (reconcile.Result, error)
	OnReconcileActiveHealthCheckPolicyDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterActiveHealthCheckPolicyReconcilerFuncs) ReconcileActiveHealthCheckPolicy(clusterName string, obj *resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy) (reconcile.Result, error) {
	if f.OnReconcileActiveHealthCheckPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileActiveHealthCheckPolicy(clusterName, obj)
}

func (f *MulticlusterActiveHealthCheckPolicyReconcilerFuncs) ReconcileActiveHealthCheckPolicyDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileActiveHealthCheckPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileActiveHealthCheckPolicyDeletion(clusterName, req)
}

type MulticlusterActiveHealthCheckPolicyReconcileLoop interface {
	// AddMulticlusterActiveHealthCheckPolicyReconciler adds a MulticlusterActiveHealthCheckPolicyReconciler to the MulticlusterActiveHealthCheckPolicyReconcileLoop.
	AddMulticlusterActiveHealthCheckPolicyReconciler(ctx context.Context, rec MulticlusterActiveHealthCheckPolicyReconciler, predicates ...predicate.Predicate)
}

type multiclusterActiveHealthCheckPolicyReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterActiveHealthCheckPolicyReconcileLoop) AddMulticlusterActiveHealthCheckPolicyReconciler(ctx context.Context, rec MulticlusterActiveHealthCheckPolicyReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericActiveHealthCheckPolicyMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterActiveHealthCheckPolicyReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterActiveHealthCheckPolicyReconcileLoop {
	return &multiclusterActiveHealthCheckPolicyReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy{}, options)}
}

type genericActiveHealthCheckPolicyMulticlusterReconciler struct {
	reconciler MulticlusterActiveHealthCheckPolicyReconciler
}

func (g genericActiveHealthCheckPolicyMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterActiveHealthCheckPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileActiveHealthCheckPolicyDeletion(cluster, req)
	}
	return nil
}

func (g genericActiveHealthCheckPolicyMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.ActiveHealthCheckPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: ActiveHealthCheckPolicy handler received event for %T", object)
	}
	return g.reconciler.ReconcileActiveHealthCheckPolicy(cluster, obj)
}

// Reconcile Upsert events for the ListenerConnectionPolicy Resource across clusters.
// implemented by the user
type MulticlusterListenerConnectionPolicyReconciler interface {
	ReconcileListenerConnectionPolicy(clusterName string, obj *resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the ListenerConnectionPolicy Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterListenerConnectionPolicyDeletionReconciler interface {
	ReconcileListenerConnectionPolicyDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterListenerConnectionPolicyReconcilerFuncs struct {
	OnReconcileListenerConnectionPolicy         func(clusterName string, obj *resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy) (reconcile.Result, error)
	OnReconcileListenerConnectionPolicyDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterListenerConnectionPolicyReconcilerFuncs) ReconcileListenerConnectionPolicy(clusterName string, obj *resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy) (reconcile.Result, error) {
	if f.OnReconcileListenerConnectionPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileListenerConnectionPolicy(clusterName, obj)
}

func (f *MulticlusterListenerConnectionPolicyReconcilerFuncs) ReconcileListenerConnectionPolicyDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileListenerConnectionPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileListenerConnectionPolicyDeletion(clusterName, req)
}

type MulticlusterListenerConnectionPolicyReconcileLoop interface {
	// AddMulticlusterListenerConnectionPolicyReconciler adds a MulticlusterListenerConnectionPolicyReconciler to the MulticlusterListenerConnectionPolicyReconcileLoop.
	AddMulticlusterListenerConnectionPolicyReconciler(ctx context.Context, rec MulticlusterListenerConnectionPolicyReconciler, predicates ...predicate.Predicate)
}

type multiclusterListenerConnectionPolicyReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterListenerConnectionPolicyReconcileLoop) AddMulticlusterListenerConnectionPolicyReconciler(ctx context.Context, rec MulticlusterListenerConnectionPolicyReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericListenerConnectionPolicyMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterListenerConnectionPolicyReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterListenerConnectionPolicyReconcileLoop {
	return &multiclusterListenerConnectionPolicyReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy{}, options)}
}

type genericListenerConnectionPolicyMulticlusterReconciler struct {
	reconciler MulticlusterListenerConnectionPolicyReconciler
}

func (g genericListenerConnectionPolicyMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterListenerConnectionPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileListenerConnectionPolicyDeletion(cluster, req)
	}
	return nil
}

func (g genericListenerConnectionPolicyMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.ListenerConnectionPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: ListenerConnectionPolicy handler received event for %T", object)
	}
	return g.reconciler.ReconcileListenerConnectionPolicy(cluster, obj)
}
