// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./multicluster_reconcilers.go -destination mocks/multicluster_reconcilers.go

// Definitions for the multicluster Kubernetes Controllers
package controller

import (
	"context"

	internal_gloo_solo_io_v2 "github.com/solo-io/gloo/projects/gloo/cli/pkg/cmd/gatewayapi/envoy/gloo-mesh-client-go/internal.gloo.solo.io/v2"

	"github.com/pkg/errors"
	"github.com/solo-io/skv2/pkg/ezkube"
	"github.com/solo-io/skv2/pkg/multicluster"
	mc_reconcile "github.com/solo-io/skv2/pkg/multicluster/reconcile"
	"github.com/solo-io/skv2/pkg/reconcile"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
)

// Reconcile Upsert events for the IssuedCertificate Resource across clusters.
// implemented by the user
type MulticlusterIssuedCertificateReconciler interface {
	ReconcileIssuedCertificate(clusterName string, obj *internal_gloo_solo_io_v2.IssuedCertificate) (reconcile.Result, error)
}

// Reconcile deletion events for the IssuedCertificate Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterIssuedCertificateDeletionReconciler interface {
	ReconcileIssuedCertificateDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterIssuedCertificateReconcilerFuncs struct {
	OnReconcileIssuedCertificate         func(clusterName string, obj *internal_gloo_solo_io_v2.IssuedCertificate) (reconcile.Result, error)
	OnReconcileIssuedCertificateDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterIssuedCertificateReconcilerFuncs) ReconcileIssuedCertificate(clusterName string, obj *internal_gloo_solo_io_v2.IssuedCertificate) (reconcile.Result, error) {
	if f.OnReconcileIssuedCertificate == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileIssuedCertificate(clusterName, obj)
}

func (f *MulticlusterIssuedCertificateReconcilerFuncs) ReconcileIssuedCertificateDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileIssuedCertificateDeletion == nil {
		return nil
	}
	return f.OnReconcileIssuedCertificateDeletion(clusterName, req)
}

type MulticlusterIssuedCertificateReconcileLoop interface {
	// AddMulticlusterIssuedCertificateReconciler adds a MulticlusterIssuedCertificateReconciler to the MulticlusterIssuedCertificateReconcileLoop.
	AddMulticlusterIssuedCertificateReconciler(ctx context.Context, rec MulticlusterIssuedCertificateReconciler, predicates ...predicate.Predicate)
}

type multiclusterIssuedCertificateReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterIssuedCertificateReconcileLoop) AddMulticlusterIssuedCertificateReconciler(ctx context.Context, rec MulticlusterIssuedCertificateReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericIssuedCertificateMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterIssuedCertificateReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterIssuedCertificateReconcileLoop {
	return &multiclusterIssuedCertificateReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &internal_gloo_solo_io_v2.IssuedCertificate{}, options)}
}

type genericIssuedCertificateMulticlusterReconciler struct {
	reconciler MulticlusterIssuedCertificateReconciler
}

func (g genericIssuedCertificateMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterIssuedCertificateDeletionReconciler); ok {
		return deletionReconciler.ReconcileIssuedCertificateDeletion(cluster, req)
	}
	return nil
}

func (g genericIssuedCertificateMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*internal_gloo_solo_io_v2.IssuedCertificate)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: IssuedCertificate handler received event for %T", object)
	}
	return g.reconciler.ReconcileIssuedCertificate(cluster, obj)
}

// Reconcile Upsert events for the CertificateRequest Resource across clusters.
// implemented by the user
type MulticlusterCertificateRequestReconciler interface {
	ReconcileCertificateRequest(clusterName string, obj *internal_gloo_solo_io_v2.CertificateRequest) (reconcile.Result, error)
}

// Reconcile deletion events for the CertificateRequest Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterCertificateRequestDeletionReconciler interface {
	ReconcileCertificateRequestDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterCertificateRequestReconcilerFuncs struct {
	OnReconcileCertificateRequest         func(clusterName string, obj *internal_gloo_solo_io_v2.CertificateRequest) (reconcile.Result, error)
	OnReconcileCertificateRequestDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterCertificateRequestReconcilerFuncs) ReconcileCertificateRequest(clusterName string, obj *internal_gloo_solo_io_v2.CertificateRequest) (reconcile.Result, error) {
	if f.OnReconcileCertificateRequest == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileCertificateRequest(clusterName, obj)
}

func (f *MulticlusterCertificateRequestReconcilerFuncs) ReconcileCertificateRequestDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileCertificateRequestDeletion == nil {
		return nil
	}
	return f.OnReconcileCertificateRequestDeletion(clusterName, req)
}

type MulticlusterCertificateRequestReconcileLoop interface {
	// AddMulticlusterCertificateRequestReconciler adds a MulticlusterCertificateRequestReconciler to the MulticlusterCertificateRequestReconcileLoop.
	AddMulticlusterCertificateRequestReconciler(ctx context.Context, rec MulticlusterCertificateRequestReconciler, predicates ...predicate.Predicate)
}

type multiclusterCertificateRequestReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterCertificateRequestReconcileLoop) AddMulticlusterCertificateRequestReconciler(ctx context.Context, rec MulticlusterCertificateRequestReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericCertificateRequestMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterCertificateRequestReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterCertificateRequestReconcileLoop {
	return &multiclusterCertificateRequestReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &internal_gloo_solo_io_v2.CertificateRequest{}, options)}
}

type genericCertificateRequestMulticlusterReconciler struct {
	reconciler MulticlusterCertificateRequestReconciler
}

func (g genericCertificateRequestMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterCertificateRequestDeletionReconciler); ok {
		return deletionReconciler.ReconcileCertificateRequestDeletion(cluster, req)
	}
	return nil
}

func (g genericCertificateRequestMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*internal_gloo_solo_io_v2.CertificateRequest)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: CertificateRequest handler received event for %T", object)
	}
	return g.reconciler.ReconcileCertificateRequest(cluster, obj)
}

// Reconcile Upsert events for the PodBounceDirective Resource across clusters.
// implemented by the user
type MulticlusterPodBounceDirectiveReconciler interface {
	ReconcilePodBounceDirective(clusterName string, obj *internal_gloo_solo_io_v2.PodBounceDirective) (reconcile.Result, error)
}

// Reconcile deletion events for the PodBounceDirective Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterPodBounceDirectiveDeletionReconciler interface {
	ReconcilePodBounceDirectiveDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterPodBounceDirectiveReconcilerFuncs struct {
	OnReconcilePodBounceDirective         func(clusterName string, obj *internal_gloo_solo_io_v2.PodBounceDirective) (reconcile.Result, error)
	OnReconcilePodBounceDirectiveDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterPodBounceDirectiveReconcilerFuncs) ReconcilePodBounceDirective(clusterName string, obj *internal_gloo_solo_io_v2.PodBounceDirective) (reconcile.Result, error) {
	if f.OnReconcilePodBounceDirective == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcilePodBounceDirective(clusterName, obj)
}

func (f *MulticlusterPodBounceDirectiveReconcilerFuncs) ReconcilePodBounceDirectiveDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcilePodBounceDirectiveDeletion == nil {
		return nil
	}
	return f.OnReconcilePodBounceDirectiveDeletion(clusterName, req)
}

type MulticlusterPodBounceDirectiveReconcileLoop interface {
	// AddMulticlusterPodBounceDirectiveReconciler adds a MulticlusterPodBounceDirectiveReconciler to the MulticlusterPodBounceDirectiveReconcileLoop.
	AddMulticlusterPodBounceDirectiveReconciler(ctx context.Context, rec MulticlusterPodBounceDirectiveReconciler, predicates ...predicate.Predicate)
}

type multiclusterPodBounceDirectiveReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterPodBounceDirectiveReconcileLoop) AddMulticlusterPodBounceDirectiveReconciler(ctx context.Context, rec MulticlusterPodBounceDirectiveReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericPodBounceDirectiveMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterPodBounceDirectiveReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterPodBounceDirectiveReconcileLoop {
	return &multiclusterPodBounceDirectiveReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &internal_gloo_solo_io_v2.PodBounceDirective{}, options)}
}

type genericPodBounceDirectiveMulticlusterReconciler struct {
	reconciler MulticlusterPodBounceDirectiveReconciler
}

func (g genericPodBounceDirectiveMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterPodBounceDirectiveDeletionReconciler); ok {
		return deletionReconciler.ReconcilePodBounceDirectiveDeletion(cluster, req)
	}
	return nil
}

func (g genericPodBounceDirectiveMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*internal_gloo_solo_io_v2.PodBounceDirective)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: PodBounceDirective handler received event for %T", object)
	}
	return g.reconciler.ReconcilePodBounceDirective(cluster, obj)
}

// Reconcile Upsert events for the XdsConfig Resource across clusters.
// implemented by the user
type MulticlusterXdsConfigReconciler interface {
	ReconcileXdsConfig(clusterName string, obj *internal_gloo_solo_io_v2.XdsConfig) (reconcile.Result, error)
}

// Reconcile deletion events for the XdsConfig Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterXdsConfigDeletionReconciler interface {
	ReconcileXdsConfigDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterXdsConfigReconcilerFuncs struct {
	OnReconcileXdsConfig         func(clusterName string, obj *internal_gloo_solo_io_v2.XdsConfig) (reconcile.Result, error)
	OnReconcileXdsConfigDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterXdsConfigReconcilerFuncs) ReconcileXdsConfig(clusterName string, obj *internal_gloo_solo_io_v2.XdsConfig) (reconcile.Result, error) {
	if f.OnReconcileXdsConfig == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileXdsConfig(clusterName, obj)
}

func (f *MulticlusterXdsConfigReconcilerFuncs) ReconcileXdsConfigDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileXdsConfigDeletion == nil {
		return nil
	}
	return f.OnReconcileXdsConfigDeletion(clusterName, req)
}

type MulticlusterXdsConfigReconcileLoop interface {
	// AddMulticlusterXdsConfigReconciler adds a MulticlusterXdsConfigReconciler to the MulticlusterXdsConfigReconcileLoop.
	AddMulticlusterXdsConfigReconciler(ctx context.Context, rec MulticlusterXdsConfigReconciler, predicates ...predicate.Predicate)
}

type multiclusterXdsConfigReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterXdsConfigReconcileLoop) AddMulticlusterXdsConfigReconciler(ctx context.Context, rec MulticlusterXdsConfigReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericXdsConfigMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterXdsConfigReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterXdsConfigReconcileLoop {
	return &multiclusterXdsConfigReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &internal_gloo_solo_io_v2.XdsConfig{}, options)}
}

type genericXdsConfigMulticlusterReconciler struct {
	reconciler MulticlusterXdsConfigReconciler
}

func (g genericXdsConfigMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterXdsConfigDeletionReconciler); ok {
		return deletionReconciler.ReconcileXdsConfigDeletion(cluster, req)
	}
	return nil
}

func (g genericXdsConfigMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*internal_gloo_solo_io_v2.XdsConfig)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: XdsConfig handler received event for %T", object)
	}
	return g.reconciler.ReconcileXdsConfig(cluster, obj)
}

// Reconcile Upsert events for the DiscoveredGateway Resource across clusters.
// implemented by the user
type MulticlusterDiscoveredGatewayReconciler interface {
	ReconcileDiscoveredGateway(clusterName string, obj *internal_gloo_solo_io_v2.DiscoveredGateway) (reconcile.Result, error)
}

// Reconcile deletion events for the DiscoveredGateway Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterDiscoveredGatewayDeletionReconciler interface {
	ReconcileDiscoveredGatewayDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterDiscoveredGatewayReconcilerFuncs struct {
	OnReconcileDiscoveredGateway         func(clusterName string, obj *internal_gloo_solo_io_v2.DiscoveredGateway) (reconcile.Result, error)
	OnReconcileDiscoveredGatewayDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterDiscoveredGatewayReconcilerFuncs) ReconcileDiscoveredGateway(clusterName string, obj *internal_gloo_solo_io_v2.DiscoveredGateway) (reconcile.Result, error) {
	if f.OnReconcileDiscoveredGateway == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileDiscoveredGateway(clusterName, obj)
}

func (f *MulticlusterDiscoveredGatewayReconcilerFuncs) ReconcileDiscoveredGatewayDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileDiscoveredGatewayDeletion == nil {
		return nil
	}
	return f.OnReconcileDiscoveredGatewayDeletion(clusterName, req)
}

type MulticlusterDiscoveredGatewayReconcileLoop interface {
	// AddMulticlusterDiscoveredGatewayReconciler adds a MulticlusterDiscoveredGatewayReconciler to the MulticlusterDiscoveredGatewayReconcileLoop.
	AddMulticlusterDiscoveredGatewayReconciler(ctx context.Context, rec MulticlusterDiscoveredGatewayReconciler, predicates ...predicate.Predicate)
}

type multiclusterDiscoveredGatewayReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterDiscoveredGatewayReconcileLoop) AddMulticlusterDiscoveredGatewayReconciler(ctx context.Context, rec MulticlusterDiscoveredGatewayReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericDiscoveredGatewayMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterDiscoveredGatewayReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterDiscoveredGatewayReconcileLoop {
	return &multiclusterDiscoveredGatewayReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &internal_gloo_solo_io_v2.DiscoveredGateway{}, options)}
}

type genericDiscoveredGatewayMulticlusterReconciler struct {
	reconciler MulticlusterDiscoveredGatewayReconciler
}

func (g genericDiscoveredGatewayMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterDiscoveredGatewayDeletionReconciler); ok {
		return deletionReconciler.ReconcileDiscoveredGatewayDeletion(cluster, req)
	}
	return nil
}

func (g genericDiscoveredGatewayMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*internal_gloo_solo_io_v2.DiscoveredGateway)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: DiscoveredGateway handler received event for %T", object)
	}
	return g.reconciler.ReconcileDiscoveredGateway(cluster, obj)
}

// Reconcile Upsert events for the Mesh Resource across clusters.
// implemented by the user
type MulticlusterMeshReconciler interface {
	ReconcileMesh(clusterName string, obj *internal_gloo_solo_io_v2.Mesh) (reconcile.Result, error)
}

// Reconcile deletion events for the Mesh Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterMeshDeletionReconciler interface {
	ReconcileMeshDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterMeshReconcilerFuncs struct {
	OnReconcileMesh         func(clusterName string, obj *internal_gloo_solo_io_v2.Mesh) (reconcile.Result, error)
	OnReconcileMeshDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterMeshReconcilerFuncs) ReconcileMesh(clusterName string, obj *internal_gloo_solo_io_v2.Mesh) (reconcile.Result, error) {
	if f.OnReconcileMesh == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileMesh(clusterName, obj)
}

func (f *MulticlusterMeshReconcilerFuncs) ReconcileMeshDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileMeshDeletion == nil {
		return nil
	}
	return f.OnReconcileMeshDeletion(clusterName, req)
}

type MulticlusterMeshReconcileLoop interface {
	// AddMulticlusterMeshReconciler adds a MulticlusterMeshReconciler to the MulticlusterMeshReconcileLoop.
	AddMulticlusterMeshReconciler(ctx context.Context, rec MulticlusterMeshReconciler, predicates ...predicate.Predicate)
}

type multiclusterMeshReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterMeshReconcileLoop) AddMulticlusterMeshReconciler(ctx context.Context, rec MulticlusterMeshReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericMeshMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterMeshReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterMeshReconcileLoop {
	return &multiclusterMeshReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &internal_gloo_solo_io_v2.Mesh{}, options)}
}

type genericMeshMulticlusterReconciler struct {
	reconciler MulticlusterMeshReconciler
}

func (g genericMeshMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterMeshDeletionReconciler); ok {
		return deletionReconciler.ReconcileMeshDeletion(cluster, req)
	}
	return nil
}

func (g genericMeshMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*internal_gloo_solo_io_v2.Mesh)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: Mesh handler received event for %T", object)
	}
	return g.reconciler.ReconcileMesh(cluster, obj)
}

// Reconcile Upsert events for the DiscoveredCNI Resource across clusters.
// implemented by the user
type MulticlusterDiscoveredCNIReconciler interface {
	ReconcileDiscoveredCNI(clusterName string, obj *internal_gloo_solo_io_v2.DiscoveredCNI) (reconcile.Result, error)
}

// Reconcile deletion events for the DiscoveredCNI Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterDiscoveredCNIDeletionReconciler interface {
	ReconcileDiscoveredCNIDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterDiscoveredCNIReconcilerFuncs struct {
	OnReconcileDiscoveredCNI         func(clusterName string, obj *internal_gloo_solo_io_v2.DiscoveredCNI) (reconcile.Result, error)
	OnReconcileDiscoveredCNIDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterDiscoveredCNIReconcilerFuncs) ReconcileDiscoveredCNI(clusterName string, obj *internal_gloo_solo_io_v2.DiscoveredCNI) (reconcile.Result, error) {
	if f.OnReconcileDiscoveredCNI == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileDiscoveredCNI(clusterName, obj)
}

func (f *MulticlusterDiscoveredCNIReconcilerFuncs) ReconcileDiscoveredCNIDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileDiscoveredCNIDeletion == nil {
		return nil
	}
	return f.OnReconcileDiscoveredCNIDeletion(clusterName, req)
}

type MulticlusterDiscoveredCNIReconcileLoop interface {
	// AddMulticlusterDiscoveredCNIReconciler adds a MulticlusterDiscoveredCNIReconciler to the MulticlusterDiscoveredCNIReconcileLoop.
	AddMulticlusterDiscoveredCNIReconciler(ctx context.Context, rec MulticlusterDiscoveredCNIReconciler, predicates ...predicate.Predicate)
}

type multiclusterDiscoveredCNIReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterDiscoveredCNIReconcileLoop) AddMulticlusterDiscoveredCNIReconciler(ctx context.Context, rec MulticlusterDiscoveredCNIReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericDiscoveredCNIMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterDiscoveredCNIReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterDiscoveredCNIReconcileLoop {
	return &multiclusterDiscoveredCNIReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &internal_gloo_solo_io_v2.DiscoveredCNI{}, options)}
}

type genericDiscoveredCNIMulticlusterReconciler struct {
	reconciler MulticlusterDiscoveredCNIReconciler
}

func (g genericDiscoveredCNIMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterDiscoveredCNIDeletionReconciler); ok {
		return deletionReconciler.ReconcileDiscoveredCNIDeletion(cluster, req)
	}
	return nil
}

func (g genericDiscoveredCNIMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*internal_gloo_solo_io_v2.DiscoveredCNI)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: DiscoveredCNI handler received event for %T", object)
	}
	return g.reconciler.ReconcileDiscoveredCNI(cluster, obj)
}

// Reconcile Upsert events for the PortalConfig Resource across clusters.
// implemented by the user
type MulticlusterPortalConfigReconciler interface {
	ReconcilePortalConfig(clusterName string, obj *internal_gloo_solo_io_v2.PortalConfig) (reconcile.Result, error)
}

// Reconcile deletion events for the PortalConfig Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterPortalConfigDeletionReconciler interface {
	ReconcilePortalConfigDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterPortalConfigReconcilerFuncs struct {
	OnReconcilePortalConfig         func(clusterName string, obj *internal_gloo_solo_io_v2.PortalConfig) (reconcile.Result, error)
	OnReconcilePortalConfigDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterPortalConfigReconcilerFuncs) ReconcilePortalConfig(clusterName string, obj *internal_gloo_solo_io_v2.PortalConfig) (reconcile.Result, error) {
	if f.OnReconcilePortalConfig == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcilePortalConfig(clusterName, obj)
}

func (f *MulticlusterPortalConfigReconcilerFuncs) ReconcilePortalConfigDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcilePortalConfigDeletion == nil {
		return nil
	}
	return f.OnReconcilePortalConfigDeletion(clusterName, req)
}

type MulticlusterPortalConfigReconcileLoop interface {
	// AddMulticlusterPortalConfigReconciler adds a MulticlusterPortalConfigReconciler to the MulticlusterPortalConfigReconcileLoop.
	AddMulticlusterPortalConfigReconciler(ctx context.Context, rec MulticlusterPortalConfigReconciler, predicates ...predicate.Predicate)
}

type multiclusterPortalConfigReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterPortalConfigReconcileLoop) AddMulticlusterPortalConfigReconciler(ctx context.Context, rec MulticlusterPortalConfigReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericPortalConfigMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterPortalConfigReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterPortalConfigReconcileLoop {
	return &multiclusterPortalConfigReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &internal_gloo_solo_io_v2.PortalConfig{}, options)}
}

type genericPortalConfigMulticlusterReconciler struct {
	reconciler MulticlusterPortalConfigReconciler
}

func (g genericPortalConfigMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterPortalConfigDeletionReconciler); ok {
		return deletionReconciler.ReconcilePortalConfigDeletion(cluster, req)
	}
	return nil
}

func (g genericPortalConfigMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*internal_gloo_solo_io_v2.PortalConfig)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: PortalConfig handler received event for %T", object)
	}
	return g.reconciler.ReconcilePortalConfig(cluster, obj)
}

// Reconcile Upsert events for the ClusterIstioInstallation Resource across clusters.
// implemented by the user
type MulticlusterClusterIstioInstallationReconciler interface {
	ReconcileClusterIstioInstallation(clusterName string, obj *internal_gloo_solo_io_v2.ClusterIstioInstallation) (reconcile.Result, error)
}

// Reconcile deletion events for the ClusterIstioInstallation Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterClusterIstioInstallationDeletionReconciler interface {
	ReconcileClusterIstioInstallationDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterClusterIstioInstallationReconcilerFuncs struct {
	OnReconcileClusterIstioInstallation         func(clusterName string, obj *internal_gloo_solo_io_v2.ClusterIstioInstallation) (reconcile.Result, error)
	OnReconcileClusterIstioInstallationDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterClusterIstioInstallationReconcilerFuncs) ReconcileClusterIstioInstallation(clusterName string, obj *internal_gloo_solo_io_v2.ClusterIstioInstallation) (reconcile.Result, error) {
	if f.OnReconcileClusterIstioInstallation == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileClusterIstioInstallation(clusterName, obj)
}

func (f *MulticlusterClusterIstioInstallationReconcilerFuncs) ReconcileClusterIstioInstallationDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileClusterIstioInstallationDeletion == nil {
		return nil
	}
	return f.OnReconcileClusterIstioInstallationDeletion(clusterName, req)
}

type MulticlusterClusterIstioInstallationReconcileLoop interface {
	// AddMulticlusterClusterIstioInstallationReconciler adds a MulticlusterClusterIstioInstallationReconciler to the MulticlusterClusterIstioInstallationReconcileLoop.
	AddMulticlusterClusterIstioInstallationReconciler(ctx context.Context, rec MulticlusterClusterIstioInstallationReconciler, predicates ...predicate.Predicate)
}

type multiclusterClusterIstioInstallationReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterClusterIstioInstallationReconcileLoop) AddMulticlusterClusterIstioInstallationReconciler(ctx context.Context, rec MulticlusterClusterIstioInstallationReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericClusterIstioInstallationMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterClusterIstioInstallationReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterClusterIstioInstallationReconcileLoop {
	return &multiclusterClusterIstioInstallationReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &internal_gloo_solo_io_v2.ClusterIstioInstallation{}, options)}
}

type genericClusterIstioInstallationMulticlusterReconciler struct {
	reconciler MulticlusterClusterIstioInstallationReconciler
}

func (g genericClusterIstioInstallationMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterClusterIstioInstallationDeletionReconciler); ok {
		return deletionReconciler.ReconcileClusterIstioInstallationDeletion(cluster, req)
	}
	return nil
}

func (g genericClusterIstioInstallationMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*internal_gloo_solo_io_v2.ClusterIstioInstallation)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: ClusterIstioInstallation handler received event for %T", object)
	}
	return g.reconciler.ReconcileClusterIstioInstallation(cluster, obj)
}
